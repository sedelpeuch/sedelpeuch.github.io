---
title: "API : REST vs GraphQL"
description: "Comparaison dÃ©taillÃ©e entre les API GraphQL et REST : principes, avantages, limites et cas dâ€™usage."
tags: [Devops, Python, API]
---


GraphQL et REST sont deux paradigmes majeurs pour la conception dâ€™API, chacun reposant sur des fondements thÃ©oriques et des choix architecturaux distincts. Comprendre leurs diffÃ©rences est essentiel pour concevoir des systÃ¨mes distribuÃ©s robustes, Ã©volutifs et maintenables.

<!--truncate-->

## Quâ€™est-ce quâ€™une API REST ? ğŸŒ

REST (Representational State Transfer), formalisÃ© par Roy Fielding en 2000, est un style architectural pour les systÃ¨mes distribuÃ©s. Il repose sur lâ€™identification des ressources via des URI, la manipulation de ces ressources Ã  lâ€™aide de mÃ©thodes HTTP standardisÃ©es (GET, POST, PUT, DELETE), et lâ€™absence dâ€™Ã©tat cÃ´tÃ© serveur (statelessness).

REST favorise une sÃ©paration stricte entre client et serveur, permettant une Ã©volutivitÃ© horizontale et une interopÃ©rabilitÃ© accrue. Les ressources sont reprÃ©sentÃ©es sous forme de documents (souvent JSON), et lâ€™API expose un ensemble dâ€™endpoints correspondant Ã  des entitÃ©s mÃ©tier.

### Principes clÃ©s REST

- **Ressources identifiÃ©es par des URLs** : chaque entitÃ© mÃ©tier possÃ¨de une URI unique
- **Stateless** : chaque requÃªte HTTP est indÃ©pendante, facilitant la scalabilitÃ©
- **Utilisation sÃ©mantique des mÃ©thodes HTTP** : GET (lecture), POST (crÃ©ation), PUT/PATCH (modification), DELETE (suppression)
- **Format de rÃ©ponse standardisÃ©** : JSON, XML, ou autres, selon le header `Accept`
- **CacheabilitÃ©** : possibilitÃ© dâ€™utiliser le cache HTTP pour optimiser les performances

### Exemple dâ€™appel REST

```http
GET /users/123
Accept: application/json
```

RÃ©ponse typiqueâ€¯:

```json
{
  "id": 123,
  "name": "Alice",
  "email": "alice@example.com"
}
```

## Quâ€™est-ce que GraphQL ? ğŸ§©

GraphQL, introduit par Facebook en 2015, est un langage de requÃªte et un runtime pour les API. Il propose une approche dÃ©clarativeâ€¯: le client dÃ©crit prÃ©cisÃ©ment la forme et la structure des donnÃ©es attendues, et le serveur rÃ©pond en consÃ©quence, via un unique endpoint.

GraphQL sâ€™appuie sur un schÃ©ma fortement typÃ©, dÃ©fini cÃ´tÃ© serveur, qui dÃ©crit lâ€™ensemble des types, des relations et des opÃ©rations (queries, mutations, subscriptions) disponibles. Cette introspection permet une documentation automatique et une validation statique des requÃªtes.

### Principes clÃ©s GraphQL

- **Un seul endpoint** (gÃ©nÃ©ralement `/graphql`)â€¯: simplifie la gestion rÃ©seau et la sÃ©curitÃ©
- **RequÃªtes dÃ©claratives et flexibles**â€¯: le client spÃ©cifie exactement les champs et relations dÃ©sirÃ©s, limitant lâ€™overfetching et lâ€™underfetching
- **SchÃ©ma fortement typÃ©**â€¯: chaque type, champ et opÃ©ration est explicitement dÃ©fini, permettant la validation et lâ€™autocomplÃ©tion
- **AgrÃ©gation de ressources**â€¯: possibilitÃ© de rÃ©cupÃ©rer des graphes de donnÃ©es complexes en une seule requÃªte
- **Introspection**â€¯: le schÃ©ma est auto-documentÃ© et interrogeable dynamiquement

### Exemple de requÃªte GraphQL

```graphql
query {
  user(id: "123") {
    name
    email
    posts {
      title
    }
  }
}
```

RÃ©ponse typiqueâ€¯:

```json
{
  "data": {
    "user": {
      "name": "Alice",
      "email": "alice@example.com",
      "posts": [
        { "title": "Premier post" },
        { "title": "Second post" }
      ]
    }
  }
}
```

## ModÃ©lisation et sÃ©mantique des donnÃ©es

REST modÃ©lise les entitÃ©s mÃ©tier comme des ressources indÃ©pendantes, accessibles via des URI. Les relations entre ressources sont gÃ©nÃ©ralement exprimÃ©es par des liens ou des sous-routes (exâ€¯: `/users/123/posts`).

GraphQL modÃ©lise les donnÃ©es comme un graphe typÃ©â€¯: chaque type peut rÃ©fÃ©rencer dâ€™autres types, et les requÃªtes peuvent naviguer dans ce graphe de maniÃ¨re rÃ©cursive. Cela permet dâ€™exprimer des relations complexes et dâ€™optimiser la rÃ©cupÃ©ration des donnÃ©es.

## Comparaison des concepts ğŸ”

| CritÃ¨re                | REST                                 | GraphQL                              |
|------------------------|--------------------------------------|--------------------------------------|
| Endpoint               | Plusieurs (par ressource)            | Un seul                              |
| Format de rÃ©ponse      | Fixe (souvent tout lâ€™objet)          | Flexible (le client choisit)         |
| Overfetching           | Oui (donnÃ©es inutiles)               | Non                                  |
| Underfetching          | Oui (requÃªtes multiples nÃ©cessaires) | Non                                  |
| Documentation          | Swagger, OpenAPI                     | SchÃ©ma introspectif, autogÃ©nÃ©rÃ©      |
| Versioning             | Par URL ou header                    | Ã‰volution incrÃ©mentale du schÃ©ma     |
| Erreurs                | Codes HTTP                           | Objet dâ€™erreur structurÃ© dans la rÃ©ponse |
| Typage                 | Faible (contrats implicites)         | Fort (contrats explicites)           |
| DÃ©couverte             | Manuelle, via documentation externe  | Automatique, via introspection       |

## Gestion des erreurs et robustesse

REST sâ€™appuie sur les codes de statut HTTP pour signaler les erreurs (404, 500, etc.), ce qui permet une gestion standardisÃ©e mais parfois peu granulaire.

GraphQL encapsule les erreurs dans la rÃ©ponse JSON, permettant de signaler des erreurs partielles (exâ€¯: certains champs en erreur, dâ€™autres valides), ce qui amÃ©liore la rÃ©silience cÃ´tÃ© client.

## Avantages et limites âš–ï¸

### REST

- âœ… SimplicitÃ©, standardisation HTTP
- âœ… Large Ã©cosystÃ¨me
- âŒ Overfetching/Underfetching
- âŒ Multiplication des endpoints

### GraphQL

- âœ… FlexibilitÃ© des requÃªtes
- âœ… Moins de requÃªtes rÃ©seau
- âœ… Typage fort et introspection
- âŒ Courbe dâ€™apprentissage
- âŒ ComplexitÃ© cÃ´tÃ© serveur
- âŒ Pas de cache HTTP natif

## Quand choisir lâ€™un ou lâ€™autre ? ğŸ¤”

- **REST** : API simples, forte compatibilitÃ©, besoin de cache HTTP
- **GraphQL** : Applications complexes, besoins mobiles, agrÃ©gation de donnÃ©es, Ã©volutivitÃ© du schÃ©ma

## Conclusion ğŸ¯

REST reste pertinent pour de nombreux cas, mais GraphQL sâ€™impose pour des besoins de flexibilitÃ© et dâ€™optimisation des Ã©changes. Le choix dÃ©pend du contexte technique et des besoins mÃ©tier.
