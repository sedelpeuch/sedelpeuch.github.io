"use strict";(self.webpackChunksedelpeuch_net=self.webpackChunksedelpeuch_net||[]).push([[3197],{28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>u});var t=s(96540);const r={},i=t.createContext(r);function o(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function u(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:n},e.children)}},91373:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>u,default:()=>c,frontMatter:()=>o,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"enseirb/s8/se/2","title":"Processus et ex\xe9cution","description":"Description des processus","source":"@site/docs/enseirb/s8/se/2.md","sourceDirName":"enseirb/s8/se","slug":"/enseirb/s8/se/2","permalink":"/docs/enseirb/s8/se/2","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Processus et ex\xe9cution"},"sidebar":"tutorialSidebar","previous":{"title":"Introduction et Concepts G\xe9n\xe9raux","permalink":"/docs/enseirb/s8/se/1"},"next":{"title":"Gestion m\xe9moire","permalink":"/docs/enseirb/s8/se/3"}}');var r=s(74848),i=s(28453);const o={title:"Processus et ex\xe9cution"},u=void 0,l={},a=[{value:"Description des processus",id:"description-des-processus",level:2},{value:"Ex\xe9cution des processus",id:"ex\xe9cution-des-processus",level:2},{value:"Modes d&#39;ex\xe9cution",id:"modes-dex\xe9cution",level:3},{value:"Exceptions et interruptions",id:"exceptions-et-interruptions",level:3},{value:"Appels-syst\xe8me",id:"appels-syst\xe8me",level:3},{value:"Processus et threads",id:"processus-et-threads",level:2},{value:"Vie et mort des processus",id:"vie-et-mort-des-processus",level:3},{value:"Ordonnancement",id:"ordonnancement",level:3},{value:"Processus et threads",id:"processus-et-threads-1",level:2},{value:"Mod\xe8le 1 on 1",id:"mod\xe8le-1-on-1",level:3},{value:"Threads en espace utilisateur",id:"threads-en-espace-utilisateur",level:3},{value:"Mod\xe8le M on N",id:"mod\xe8le-m-on-n",level:3},{value:"Algorithmes d&#39;ordonnancement",id:"algorithmes-dordonnancement",level:2},{value:"Crit\xe8res d&#39;ordonnancement",id:"crit\xe8res-dordonnancement",level:3},{value:"Liste tri\xe9e par priorit\xe9s",id:"liste-tri\xe9e-par-priorit\xe9s",level:3},{value:"Listes par priorit\xe9s",id:"listes-par-priorit\xe9s",level:3},{value:"Ajuster la timeslice aux priorit\xe9s",id:"ajuster-la-timeslice-aux-priorit\xe9s",level:3},{value:"Le multicoeurs et multiprocesseur",id:"le-multicoeurs-et-multiprocesseur",level:3},{value:"Ordonnancement dans Linux",id:"ordonnancement-dans-linux",level:3},{value:"Ex\xe9cution du syst\xe8me",id:"ex\xe9cution-du-syst\xe8me",level:2}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"description-des-processus",children:"Description des processus"}),"\n",(0,r.jsx)(n.p,{children:"Les processus permettent \xe0 toutes les applications de progresser simultan\xe9ment,\nles processeurs physiques les ex\xe9cutent en alternance et chaque application a\nl'illusion d'\xeatre seule sur la machine. Les processus ont pour objectif de\npartager les ressources disponibles entre de multiples applications pour\nutiliser les ressources efficacement."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"D\xe9finition :"})," Un processus est un programme en ex\xe9cution, une instance d'un\nprogramme s'ex\xe9cutant sur un ordinateur, une entit\xe9 pouvant \xeatre assign\xe9e et\nex\xe9cut\xe9e sur un processeur ou une unit\xe9 d'activit\xe9 caract\xe9ris\xe9e par l'ex\xe9cution\nd'une suite d'instructions, un \xe9tant courant et un ensemble de ressources\nsyst\xe8me."]}),"\n",(0,r.jsx)(n.p,{children:"Les processus sont caract\xe9ris\xe9s par leur initialisation (code du programme,\nensemble de donn\xe9e en entr\xe9e), leur phase durant l'ex\xe9cution (bloc de contr\xf4le)\net un identifiant (pid)"}),"\n",(0,r.jsxs)(n.p,{children:["Le ",(0,r.jsx)(n.strong,{children:"bloc de contr\xf4le"})," d'un processus est compos\xe9 par"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"un identifiant"}),"\n",(0,r.jsx)(n.li,{children:"des adresses m\xe9moires"}),"\n",(0,r.jsx)(n.li,{children:"program counter"}),"\n",(0,r.jsx)(n.li,{children:"\xe9tat d'ordonnancement"}),"\n",(0,r.jsx)(n.li,{children:"\xe9tat des entr\xe9es / sorties"}),"\n",(0,r.jsx)(n.li,{children:"privil\xe8ges"}),"\n",(0,r.jsx)(n.li,{children:"statistiques"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Chaque processus a une g\xe9n\xe9alogie c'est \xe0 dire un processus p\xe8re et\npotentiellement des processus fils. Le p\xe8re de chaque processus est notifi\xe9 de\nla mort des fils, peut l'attendre et savoir si il a r\xe9ussi. Un processus peut\n\xeatre orphelin (et donc adopt\xe9 par le processus init pid=1)"}),"\n",(0,r.jsx)(n.h2,{id:"ex\xe9cution-des-processus",children:"Ex\xe9cution des processus"}),"\n",(0,r.jsx)(n.p,{children:"Les procesuss sont ordonnanc\xe9s par cycle (par pipeline), la dur\xe9e du cycle est\nfixe et est reli\xe9e \xe0 la fr\xe9quence. L'horloge interrompt r\xe9guli\xe8rement pour\nredonner la main au syst\xe8me r\xe9guli\xe8rement (environ 1 fois par milliseconde sous\nlinux). Chaque processus poss\xe8de un mode d'ex\xe9cution avec diff\xe9rents privil\xe8ges."}),"\n",(0,r.jsx)(n.h3,{id:"modes-dex\xe9cution",children:"Modes d'ex\xe9cution"}),"\n",(0,r.jsx)(n.p,{children:"Il existe plusieurs niveaux de privil\xe8ges qui sont mis en place mat\xe9riellement\npar le processus (acc\xe8s aux registres de contr\xf4le, instructions d'entr\xe9es /\nsorties de bas niveau, gestion m\xe9moire). Les diff\xe9rents niveaux de privil\xe8ges\nd\xe9finissent un jeu d'instructions. Le noyau peut tout faire sauf en cas de\nvirtualisation mat\xe9rielle. Seul l'hyperviseur peut tout faire."}),"\n",(0,r.jsx)(n.p,{children:"Quant \xe0 lui l'utilisateur est tr\xe8s limit\xe9 (protection ring 3 sur x86) et n'a pas\nacc\xe8s \xe0 la m\xe9moire du noyau."}),"\n",(0,r.jsx)(n.h3,{id:"exceptions-et-interruptions",children:"Exceptions et interruptions"}),"\n",(0,r.jsx)(n.p,{children:"Ce sont des \xe9v\xe9nements inattendus qui interrompent temporairement l'ex\xe9cution en\ncours. Le processeur saute automatiquement et imm\xe9diatement \xe0 un traitant\n(fonction dont l'adresse a \xe9t\xe9 d\xe9finie par le syst\xe8me d'exploitation au\nd\xe9marrage). Le traitant d\xe9pend du type d'exception ou d'interruption."}),"\n",(0,r.jsxs)(n.p,{children:["Un ",(0,r.jsx)(n.strong,{children:"exception"})," est une interruption par le processeur lui-m\xeame en cas d'erreur\net ne sait pas comment continuer, il demande alors \xe0 l'OS de l'aider puis\nreprend ensuite l'ex\xe9cution au m\xeame endroit. Au final l'application ne se rend\ncompte de rien."]}),"\n",(0,r.jsx)(n.p,{children:"Cependant les exceptions ne sont possible que quand le processeur travaille. Les\nreprise de l'ex\xe9cution sont possible uniquement si le traitant a r\xe9par\xe9 l'erreur\navec succ\xe8s."}),"\n",(0,r.jsxs)(n.p,{children:["Les ",(0,r.jsx)(n.strong,{children:"interruptions"})," sont des messages d'un p\xe9riph\xe9rique (signal \xe9lectrique sur\nune broche d\xe9di\xe9e du processeur ou \xe9criture \xe0 une adresse m\xe9moire sp\xe9ciale).\nC'est un \xe9v\xe9nement asynchrone, le processeur pourrait continuer \xe0 tourner en\nl'ignorant pendant un certain temps."]}),"\n",(0,r.jsx)(n.p,{children:"Les interruptions ont l'avantage d'\xeatre possible n'importe quand, m\xeame si le\nprocesseur ne fait rien de plus il n'y a pas d'influence directe sur la t\xe2che\nqui s'ex\xe9cutait (l'application ne se rend compte de rien)."}),"\n",(0,r.jsxs)(n.p,{children:["Les ",(0,r.jsx)(n.strong,{children:"appels-syst\xe8me"})," sont des exception forc\xe9e par une application pour\neffectuer une op\xe9ration privil\xe9gie. Elle se produit uniquement depuis l'espace\nutilisateur \xe0 la demande des applications."]}),"\n",(0,r.jsx)(n.h3,{id:"appels-syst\xe8me",children:"Appels-syst\xe8me"}),"\n",(0,r.jsx)(n.p,{children:"Le traitement de l'appel syst\xe8me est effectu\xe9 dans le traitant de l'instruction\nsp\xe9ciale, l'adresse du traitant d\xe9fine par le noyau au boot, le processeur y\nsaute imm\xe9diatement lors de l'appel syst\xe8me. En suit une ex\xe9cution temporaire en\nmode privil\xe9gie (le processus n'est pas encore, son ex\xe9cution est d\xe9rout\xe9e)."}),"\n",(0,r.jsx)(n.p,{children:"L'appel de l'appel syst\xe8me se fait en passant les param\xe8tres au traitant. Convention de passage des param\xe8tres : num\xe9ro dans %eax et arguments dans %ebx\n%ecx %edx %esi et %edi."}),"\n",(0,r.jsx)(n.p,{children:"Une fois termin\xe9, il y a une restauration des registres utilisateurs et retour\nconcret en espace utilisateur par instruction sp\xe9ciale (iret, sysexit)."}),"\n",(0,r.jsxs)(n.p,{children:["Les ",(0,r.jsx)(n.strong,{children:"appels syst\xe8me virtuels"})," sont des appels syst\xe8me chers et parfois\ninutiles (le retour de ",(0,r.jsx)(n.code,{children:"getpid()"})," varie peu) on cherche donc \xe0 optimiser\ncertains appels en espace utilisateur."]}),"\n",(0,r.jsx)(n.h2,{id:"processus-et-threads",children:"Processus et threads"}),"\n",(0,r.jsx)(n.h3,{id:"vie-et-mort-des-processus",children:"Vie et mort des processus"}),"\n",(0,r.jsxs)(n.p,{children:["Sous Unix la cr\xe9ation de processus se fait via la cr\xe9ation d'un nouveau\nprocessus puis l'ex\xe9cution d'une commande (",(0,r.jsx)(n.code,{children:"fork() + exec()"}),"). Le ",(0,r.jsx)(n.code,{children:"fork()"}),"\npermet de dupliquer l'espace d'adressage, de cr\xe9er une nouvelle file d'ex\xe9cution\ndans cet espace. Le fils cr\xe9\xe9 est identique au p\xe8re, sauf pour son PID."]}),"\n",(0,r.jsxs)(n.p,{children:["La cr\xe9ation d'un threads est \xe9quivalent \xe0 rajouter une file d'ex\xe9cution dans\nl'espace d'adressage courant via les commandes ",(0,r.jsx)(n.code,{children:"pthread_create()"})," ou ",(0,r.jsx)(n.code,{children:"clone()"}),".\nPour lancer une t\xe2che le noyau cr\xe9\xe9 un contexte utilisateur. Ce contexte pointe\nvers une fonction \xe0 ex\xe9cuter, poss\xe8de une nouvelle pile. Lors de la terminaison\nd'une t\xe2che il faut passer en mode noyaux. Pour cela il faut un moyen d'entrer\n(appel syst\xe8me ",(0,r.jsx)(n.code,{children:"exit"})," ou ",(0,r.jsx)(n.code,{children:"exception"}),"). La file d'ex\xe9cution est alors d\xe9truite et\nrel\xe2che les ressources qu'elle utilisait. Lorsqu'une t\xe2che se termine elle\nrenvoie un code de retour destin\xe9 au p\xe8re. Le p\xe8re peut attendre la terminaison\nd'un ou n'importe quel fils (",(0,r.jsx)(n.code,{children:"wait()"})," et ",(0,r.jsx)(n.code,{children:"waitpid()"}),"). C'est une t\xe2che zombie\ntant que le p\xe8re ne s'en occupe pas."]}),"\n",(0,r.jsxs)(n.p,{children:["Les processus pr\xeats \xe0 s'ex\xe9cuter sont dans une file d'attente sp\xe9ciale appel\xe9e\n",(0,r.jsx)(n.strong,{children:"runqueue"}),". Cette liste est utilis\xe9e uniquement pour les processus pret, les\nprocessus non pr\xeats sont dans des files sp\xe9ciales avec un moyen de les\nretrouver. Il ne sert \xe0 rien de parcourir une liste de 1000 processus pour\ntrouver le seul pr\xeat \xe0 s'ex\xe9cuter."]}),"\n",(0,r.jsxs)(n.p,{children:["Les ",(0,r.jsx)(n.strong,{children:"attente active"})," sont des boucle infinie qui attendent un \xe9v\xe9nement, elles\nmonopolisent le processeur jusqu'\xe0 l'\xe9v\xe9nement. Ils poss\xe8dent une tr\xe8s bonne\nr\xe9activit\xe9 mais gaspillent des cycles processus. L'",(0,r.jsx)(n.strong,{children:"attente semi-active"})," est\nune attente active en renadant la main. L'op\xe9ration ",(0,r.jsx)(n.code,{children:"yield()"})," \xe0 chaque it\xe9ration\nd'une boucle while est effectu\xe9e et la r\xe9activit\xe9 est impr\xe9visible (pas de\ngarantie de reprise de main rapide). Cela peut gaspiller autant de temps CPU\n(d\xe9pend de l'activit\xe9 des autres t\xe2ches). L'attente semi active n'est \xe0 utiliser\nque quand une attente passive est totalement impossible."]}),"\n",(0,r.jsxs)(n.p,{children:["L'",(0,r.jsx)(n.strong,{children:"attente passive"})," d'un \xe9v\xe9nement est une m\xe9canisme de r\xe9veil lors d'un\n\xe9v\xe9nement. La t\xe2ches est plac\xe9e sur une file d'attente et elle n'est plus dans\nla runqueue (ignor\xe9e par l'ordonnanceur). Lors de l'\xe9v\xe9nement, celui qui produit\nl'\xe9v\xe9nement d\xe9place la t\xe2che de la file d'attente vers la runqueue. En revanche\nl'endormissement et le r\xe9veil d'un processus co\xfbte assez cher puisqu'il est\nn\xe9cessaire d'effectuer un changements de contexte. Il est donc rentable de\nmettre en sommeil si processus uniquement si le d\xe9lai d'attente n'est pas tr\xe8s court."]}),"\n",(0,r.jsx)(n.h3,{id:"ordonnancement",children:"Ordonnancement"}),"\n",(0,r.jsx)(n.p,{children:"Les \xe9tats des processus sont repr\xe9sent\xe9s par un automate de transition entre les\n\xe9tats"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Running"}),"\n",(0,r.jsx)(n.li,{children:"Ready (pr\xeat mais pas en train de s'ex\xe9cuter)"}),"\n",(0,r.jsx)(n.li,{children:"Blocked (non-pr\xeat, en attente d'un \xe9v\xe9nement)"}),"\n",(0,r.jsx)(n.li,{children:"New (en cours de cr\xe9ation)"}),"\n",(0,r.jsx)(n.li,{children:"Exit (en cours de destruction, zombie)"}),"\n",(0,r.jsx)(n.li,{children:"Suspend (suspendu par l'utilisateur)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["L'ex\xe9cution de l'ordonnanceur n\xe9cessite l'existence du noyau, si le noyau\nn'existe pas il n'y a pas d'homme en noir pour ordonnancer les t\xe2ches en arri\xe8re\nplan. L'ordonnancement n\xe9cessite l'ex\xe9cution du code de l'ordonnanceur.\nL'ordonnancement peut \xeatre activ\xe9 ",(0,r.jsx)(n.strong,{children:"explicitement"})," par les applications (processus\nqui rend la main ",(0,r.jsx)(n.code,{children:"_yield"})," ou processus qui attend ",(0,r.jsx)(n.code,{children:"sleep()"}),") ou\n",(0,r.jsx)(n.strong,{children:"implicitement"})," par des appel syst\xe8me bloquant (",(0,r.jsx)(n.code,{children:"read()"}),", ",(0,r.jsx)(n.code,{children:"poll()"}),"). Cependant\nnous n'avons aucune garantie d'un ordonnancement r\xe9gulier, cela d\xe9pend du bon\nvouloir des applications. Il y a aussi un probl\xe8me d'\xe9quit\xe9 et de r\xe9activit\xe9, un\nprocessus peut conserver le processeur ind\xe9finiment. Les t\xe2ches doivent donc\n",(0,r.jsx)(n.strong,{children:"coop\xe9rer"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Il faut donc qu'une t\xe2che s'ex\xe9cutant en mode noyau, sur le bon processeur qui\ndoit appeler le code de l'ordonnanceur. Il faut donc trouver un moyen d'appeler\nl'ordonnanceur m\xeame si l'application ne fait pas d'ordonnancement explicite ou\nimplicite. Il faut donc utiliser le m\xe9canisme de ",(0,r.jsx)(n.strong,{children:"pr\xe9emption"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"La pr\xe9emption est le m\xe9canisme qui permet de d\xe9sordonnancer une t\xe2che de force\nsi une t\xe2che s'ex\xe9cute depuis trop longtemps ou si une autre t\xe2che est\nprioritaire. La pr\xe9emption engrange un l\xe9ger surco\xfbt puisque l'on doit v\xe9rifier\nde temps en temps s'il faut d\xe9sordonnancer de force mais c'est un gain \xe9norme en\n\xe9quit\xe9 et r\xe9activit\xe9. Il n'y a plus besoin de coop\xe9ration des processus."}),"\n",(0,r.jsx)(n.p,{children:"Sous Linux l'ordonnanceur v\xe9rifie s'il faut passer la main \xe0 une autre t\xe2che\nlors du retour en espace utilisateur sur le code utilisateur (le code du noyau\npeut \xeatre long et nuire \xe0 la r\xe9activit\xe9 du syst\xe8me). Il n'y a pas de pr\xe9emption\ndirecte en espace utilisateur (il faut \xeatre dans le noyau pour ex\xe9cuter le code\nde l'ordonnancement), les processus sont pr\xe9empt\xe9s dans le noyau de la m\xeame\nfa\xe7on (par exemple juste avant leur retour en espace utilisateur). Les\ninterruptions peuvent pr\xe9empter n'importe quand."}),"\n",(0,r.jsx)(n.h2,{id:"processus-et-threads-1",children:"Processus et threads"}),"\n",(0,r.jsx)(n.p,{children:"L'int\xe9r\xeat des threads est le partage de ressources entre les t\xe2ches permettant\nune meilleur exploitation des processeurs, un seul programme peut tourner sur\nplusieurs processus (critique depuis l'av\xe8nement des multicores)."}),"\n",(0,r.jsxs)(n.p,{children:["Un ",(0,r.jsx)(n.strong,{children:"thread"})," est une file d'ex\xe9cution interne \xe0 un processus. Le processus\ndevient un conteneur (au moins un thread et des ressources partag\xe9es). Certaines\ndonn\xe9es ne peuvent pas \xeatre partag\xe9es (piles registres) alors que d'autre le\npeuvent (espace d'adressage m\xe9moire, fichiers ouverts, signaux, identifiant des\nprocessus ...)"]}),"\n",(0,r.jsx)(n.h3,{id:"mod\xe8le-1-on-1",children:"Mod\xe8le 1 on 1"}),"\n",(0,r.jsx)(n.p,{children:"Un thread noyau est actif pour chaque thread, la cr\xe9ation / destruction /\nchangement de contexte sont aussi co\xfbteux que les processus, les processus\nmulti-threads sont avantag\xe9s."}),"\n",(0,r.jsx)(n.h3,{id:"threads-en-espace-utilisateur",children:"Threads en espace utilisateur"}),"\n",(0,r.jsx)(n.p,{children:"Un seul thread noyau propulse plusieurs threads utilisateurs, le co\xfbt\nd'ordonnancement est tr\xe8s r\xe9duit (on reste en espace utilisateur), le\nmultithreads est ignor\xe9 par le syst\xe8me"}),"\n",(0,r.jsx)(n.h3,{id:"mod\xe8le-m-on-n",children:"Mod\xe8le M on N"}),"\n",(0,r.jsx)(n.p,{children:"Dans ce mod\xe8le il y a plusieurs threads utilisateurs sur plusieurs threads\nnoyau. Si un thread bloque une t\xe2che, les autres t\xe2ches peuvent continuer \xe0\ntravailler, l'ajout de threads noyau se fait \xe0 la vol\xe9e."}),"\n",(0,r.jsx)(n.h2,{id:"algorithmes-dordonnancement",children:"Algorithmes d'ordonnancement"}),"\n",(0,r.jsx)(n.p,{children:"Actuellement nous devons r\xe9soudre le probl\xe8me suivant, nous avons besoin d'une\n\xe9quit\xe9 et de l'interactivit\xe9 de progression de toutes les t\xe2ches sans que cela\nne d\xe9pende de la bonne volont\xe9 des t\xe2ches (pr\xe9emption). Il est donc n\xe9cessaire\nde d\xe9terminer la dur\xe9e d'ordonnancement (choix de la dur\xe9e des Timesclices). Il\nnous faut un temps pas trop court sinon le co\xfbt d'ordonnancement devient\nprohibitif. Ni trop long sinon les processus n'avancent pas assez r\xe9guli\xe8rement."}),"\n",(0,r.jsx)(n.p,{children:"En revanche il faut noter qu'il est difficile de savoir pr\xe9cis\xe9ment si un\nprocessus est gourmand en temps processeur, l'ordonnancement est essentiellement\nbas\xe9 sur les ticks d'holorge (peu pr\xe9cis)."}),"\n",(0,r.jsx)(n.h3,{id:"crit\xe8res-dordonnancement",children:"Crit\xe8res d'ordonnancement"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Pour l'utilisateur : il est n\xe9cessaire d'avoir des performances (rapidit\xe9\nd'ex\xe9cution ou de terminaison, r\xe9activit\xe9, deadlines ...), d'\xe9quit\xe9 et de\npr\xe9dictabilit\xe9"}),"\n",(0,r.jsx)(n.li,{children:"Pour le syst\xe8me : performance (quantit\xe9 de travail, utilisation du\nprocessus), \xe9quit\xe9 et respect des priorit\xe9s"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Nous avons donc quelques id\xe9es pour l'ordonnancement :"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"FIFO"}),"\n",(0,r.jsx)(n.li,{children:"Round-Robin"}),"\n",(0,r.jsx)(n.li,{children:"Short First ou Short Remaining Next"}),"\n",(0,r.jsx)(n.li,{children:"Feedback"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"liste-tri\xe9e-par-priorit\xe9s",children:"Liste tri\xe9e par priorit\xe9s"}),"\n",(0,r.jsx)(n.p,{children:"Trier par priorit\xe9 la liste des t\xe2ches s'effectue en complexit\xe9 lin\xe9aire en\nfonction du nombre de t\xe2ches. Chaque op\xe9ration d'ordonnancement co\xfbtera cher. Il\nfaut aussi faire attention aux famines, les processus non-prioritaires ne\ndoivent pas rester ind\xe9finiment en fin de liste."}),"\n",(0,r.jsx)(n.h3,{id:"listes-par-priorit\xe9s",children:"Listes par priorit\xe9s"}),"\n",(0,r.jsx)(n.p,{children:"Nous pouvons aussi effectuer plusieurs listes de t\xe2ches poss\xe9dant toutes les\nm\xeames priorit\xe9s, la manipulation se fait alors en temps constant. Les listes\nsont alors parcourues plus ou moins souvent selon la priorit\xe9."}),"\n",(0,r.jsx)(n.h3,{id:"ajuster-la-timeslice-aux-priorit\xe9s",children:"Ajuster la timeslice aux priorit\xe9s"}),"\n",(0,r.jsx)(n.p,{children:"Cela implique de d\xe9finir un quantum de temps d'ex\xe9cution variable (Timeslice)\nselon la priorit\xe9. Cela est \xe9ventuellement dynamique et calculable en temps\nconstant."}),"\n",(0,r.jsx)(n.h3,{id:"le-multicoeurs-et-multiprocesseur",children:"Le multicoeurs et multiprocesseur"}),"\n",(0,r.jsx)(n.p,{children:"Nous rappelons que la pr\xe9emption est la concurrence entre t\xe2ches sur un seul\nprocesseur. Le multiprocesseur implique une concurrence r\xe9elle entre les t\xe2ches.\nLa question se pose sur quel processeur / coeur ex\xe9cuter quelles t\xe2ches."}),"\n",(0,r.jsx)(n.p,{children:"Il y a donc deux modes de fonctionnement"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Une seule runqueue (load sharing) o\xf9 tous les processeurs piochent"}),"\n",(0,r.jsx)(n.li,{children:"Une runqueue par processeur, qu'il faudra \xe9quilibre (load balancing)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"ordonnancement-dans-linux",children:"Ordonnancement dans Linux"}),"\n",(0,r.jsx)(n.p,{children:"L'ordonnanceur dans Linux est assez classique poss\xe9dant une bonne interactivit\xe9\net \xe9quit\xe9. Il poss\xe8de une priorit\xe9 effective avec un bonus ou p\xe9nalit\xe9."}),"\n",(0,r.jsx)(n.h2,{id:"ex\xe9cution-du-syst\xe8me",children:"Ex\xe9cution du syst\xe8me"}),"\n",(0,r.jsx)(n.p,{children:"En r\xe9alit\xe9 il n'y a pas de processus noyau qui surveille tout le monde, le\nsyst\xe8me s'ex\xe9cute essentiellement dans le contexte des processus lorsqu'ils sont\nen mode noyau. Il peut seulement exister \xe9ventuellement des d\xe9mons d\xe9di\xe9s \xe0 des\nt\xe2ches p\xe9riodiques."}),"\n",(0,r.jsx)(n.p,{children:"Le noyau s'ex\xe9cute \xe0 travers des hooks un peu partout dans le code qui n'a rien\n\xe0 voir (pendant les appels syst\xe8mes, dans le cas d'interruptions / exceptions)."}),"\n",(0,r.jsx)(n.p,{children:"L'ex\xe9cution en mode noyau est possible gr\xe2ce \xe0 un changement de contexte (qui\nimplique un changement des privil\xe8ges) et l'utilisation d'une pile sp\xe9ciale\n(\xe9viter de stocker des informations critiques en espace utilisateur). Le\ncontexte utilisateur est sauvegard\xe9 puis restaur\xe9."}),"\n",(0,r.jsx)(n.p,{children:"Dans le cas des micro-noyaux on r\xe9alise les appels syst\xe8mes minimaux, la gestion\neffective du syst\xe8me d'exploitation est r\xe9alis\xe9 en dehors du noyau (dans les\nprocessus serveurs d\xe9di\xe9s)."}),"\n",(0,r.jsx)(n.p,{children:"Nous pouvons noter que les noyaux monolithiques ont besoin de traitement annexes\n(appels syst\xe8mes impr\xe9visibles, traitants d'interruption dans contexte trop\nlimit\xe9). Nous mettons donc en place l'utilisation de threads d\xe9di\xe9s, qui\ntournent toujours en mode noyau (pas d'espace d'utilisateur). Les threads noyau\nsont partout, tout processus est propuls\xe9 par un thread noyau, il passe en mode\nutilisateur juste apr\xe8s sa cr\xe9ation. Il revient en mode noyau de temps en temps."})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);