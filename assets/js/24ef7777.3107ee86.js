"use strict";(self.webpackChunksedelpeuch_net=self.webpackChunksedelpeuch_net||[]).push([[4248],{28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>l});var i=s(96540);const a={},d=i.createContext(a);function t(e){const n=i.useContext(d);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),i.createElement(d.Provider,{value:n},e.children)}},74456:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>t,metadata:()=>i,toc:()=>r});const i=JSON.parse('{"id":"enseirb/s7/cpp/6","title":"Les espaces de nommage","description":"Les espaces de nommage sont des zones de d\xe9claration qui permettent de d\xe9limiter","source":"@site/docs/enseirb/s7/cpp/6.md","sourceDirName":"enseirb/s7/cpp","slug":"/enseirb/s7/cpp/6","permalink":"/docs/enseirb/s7/cpp/6","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Les espaces de nommage"},"sidebar":"tutorialSidebar","previous":{"title":"Les exceptions en C++","permalink":"/docs/enseirb/s7/cpp/5"},"next":{"title":"Les templates","permalink":"/docs/enseirb/s7/cpp/7"}}');var a=s(74848),d=s(28453);const t={title:"Les espaces de nommage"},l=void 0,c={},r=[{value:"D\xe9finition des espaces de nommage",id:"d\xe9finition-des-espaces-de-nommage",level:2},{value:"Espaces de nommage nomm\xe9es",id:"espaces-de-nommage-nomm\xe9es",level:3},{value:"Espaces de nommage anonymes",id:"espaces-de-nommage-anonymes",level:3},{value:"Alias d&#39;espaces de nommage",id:"alias-despaces-de-nommage",level:3},{value:"D\xe9claration <code>using</code>",id:"d\xe9claration-using",level:2},{value:"Syntaxe des d\xe9clarations <code>using</code>",id:"syntaxe-des-d\xe9clarations-using",level:3},{value:"Utilisation des d\xe9clarations using dans les classes",id:"utilisation-des-d\xe9clarations-using-dans-les-classes",level:3},{value:"Directive using",id:"directive-using",level:2}];function o(e){const n={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,d.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Les espaces de nommage sont des zones de d\xe9claration qui permettent de d\xe9limiter\nla recherche des noms des identificateurs par le compilateur. Leur but est\nessentiellement de regrouper les identificateurs logiquement et d'\xe9viter les\nconflits de noms entre plusieurs parties d'un m\xeame projet. Par exemple, si deux\nprogrammeurs d\xe9finissent diff\xe9remment une m\xeame structure dans deux fichiers\ndiff\xe9rents, un conflit entre ces deux structures aura lieu au mieux \xe0 l'\xe9dition\ndes liens, et au pire lors de l'utilisation commune des sources de ces deux\nprogrammeurs. Ce type de conflit provient du fait que le C++ ne fournit qu'un\nseul espace de nommage de port\xe9e globale, dans lequel il ne doit y avoir aucun\nconflit de nom. Gr\xe2ce aux espaces de nommage non globaux, ce type de probl\xe8me\npeut \xeatre plus facilement \xe9vit\xe9, parce que l'on peut \xe9viter de d\xe9finir les\nobjets globaux dans la port\xe9e globale."}),"\n",(0,a.jsx)(n.h2,{id:"d\xe9finition-des-espaces-de-nommage",children:"D\xe9finition des espaces de nommage"}),"\n",(0,a.jsx)(n.h3,{id:"espaces-de-nommage-nomm\xe9es",children:"Espaces de nommage nomm\xe9es"}),"\n",(0,a.jsx)(n.p,{children:"Lorsque le programmeur donne un nom \xe0 un espace de nommage, celui-ci est appel\xe9\nun espace de nommage nomm\xe9. La syntaxe de ce type d'espace de nommage est la\nsuivante"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"namespace nom{\n    d\xe9clarations | d\xe9finitions\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"nom"})," est le nom de l'espace de nommage, et ",(0,a.jsx)(n.strong,{children:"d\xe9clarations"})," et\n",(0,a.jsx)(n.strong,{children:"d\xe9finitions"})," sont les d\xe9clarations et les d\xe9finitions des identificateurs qui\nlui appartiennent."]}),"\n",(0,a.jsx)(n.p,{children:"Contrairement aux r\xe9gions d\xe9claratives classiques du langage (comme par exemple\nles classes), un namespace peut \xeatre d\xe9coup\xe9 en plusieurs morceaux. Le premier\nmorceaux sert de d\xe9claration, et les suivants d'extensions. La syntaxe pour une\nextension d'espace de nommage est exactement la m\xeame que celle de la partie de\nd\xe9claration."}),"\n",(0,a.jsx)(n.p,{children:"Les identificateurs d\xe9clar\xe9s ou d\xe9finis \xe0 l'int\xe9rieur d'un m\xeame espace de\nnommage ne doivent pas entrer en conflit. Ils peuvent avoir les m\xeames noms, mais\nseulement dans le cadre de la surcharge. Un espace de nommage se comporte donc\nexactement comme les zones de d\xe9clarations des classes et de la port\xe9e globale."}),"\n",(0,a.jsx)(n.p,{children:"L4acc\xe8s aux identificateurs des espaces de nommage se fait par d\xe9faut gr\xe2ce \xe0\nl'op\xe9rateur de r\xe9solution de port\xe9e, et en qualifiant le nom de l'identificateur\n\xe0 utiliser du nom de son espace de nommage. Cependant, cette qualification est\ninutile \xe0 l'int\xe9rieur de l'espace de nommage lui-m\xeame, exactement comme pour les\nmembres des classes \xe0 l'int\xe9rieur de leur classe."}),"\n",(0,a.jsx)(n.p,{children:"Les fonctions membres d'un espace de nommage peuvent \xeatre d\xe9finies \xe0 l'int\xe9rieur\nde cet espace, exactement comme les fonctions membres de classes. Elles peuvent\n\xe9galement \xeatre d\xe9finies en dehors de cet espace, si l'on utilise l'op\xe9rateur de\nr\xe9solution de port\xe9e. Les fonctions ainsi d\xe9finies doivent appara\xeetre apr\xe8s leur\nd\xe9claration dans l'espace de nommage."}),"\n",(0,a.jsx)(n.p,{children:"Il est possible de d\xe9finir un espace de nommage \xe0 l'int\xe9rieur d'un autre espace\nde nommage. Cependant, cette d\xe9claration doit obligatoirement avoir lieu au\nniveau d\xe9claratif le plus externe de l'espace de nommage qui contient le\nsous-espace de nommage. On ne peut donc pas d\xe9clarer d'espaces de nommage \xe0\nl'int\xe9rieur d'une fonction ou \xe0 l'int\xe9rieur d'une classe."}),"\n",(0,a.jsx)(n.h3,{id:"espaces-de-nommage-anonymes",children:"Espaces de nommage anonymes"}),"\n",(0,a.jsx)(n.p,{children:"Lorsque, lors de la d\xe9claration d'un espace de nommage, aucun nom n'est donn\xe9,\nun espace de nommage anonyme est cr\xe9e. Ce type d'espace de nommage permet\nd'assurer l'unicit\xe9 du nom de l'espace de nommage ainsi d\xe9clar\xe9. Les espaces de\nnommage anonymes peuvent donc remplacer efficacement le mot cl\xe9 static pour\nrendre unique des identificateurs dans un fichier. Cependant, elles sont plus\npuissantes, parce que l'on peut \xe9galement d\xe9clarer des espaces de nommage\nanonymes \xe0 l'int\xe9rieur d'autres espaces de nommage."}),"\n",(0,a.jsx)(n.p,{children:"Si, dans un espace de nommage, un identificateur est d\xe9clar\xe9 avec le m\xeame nom\nqu'un autre identificateur d\xe9clar\xe9 dans un espace de nommage plus global,\nl'identificateur global est masqu\xe9. De plus, l'identificateur ainsi d\xe9fini ne\npeut \xeatre acc\xe9d\xe9 en dehors de son espace de nommage que par un nom compl\xe8tement\nqualifi\xe9 \xe0 l'aide de l'op\xe9rateur de r\xe9solution de port\xe9e. Toutefois, si l'espace\nde nommage dans lequel il est d\xe9fini est un espace de nommage anonyme, cet\nidentificateur ne pourra pas \xeatre r\xe9f\xe9renc\xe9, puisqu'on ne peut pas pr\xe9ciser le\nnom des espaces de nommage anonymes."}),"\n",(0,a.jsx)(n.h3,{id:"alias-despaces-de-nommage",children:"Alias d'espaces de nommage"}),"\n",(0,a.jsx)(n.p,{children:"Lorsqu'un espace de nommage porte un nom tr\xe8s compliqu\xe9, il peut \xeatre avantageux\nde d\xe9finir un alias pour ce nom. L'alias aura alors un nom plus simple. Cette\nop\xe9ration peut \xeatre r\xe9alis\xe9e \xe0 l'aide de la syntaxe suivante :"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"namespace nom_alias = nom;\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"nom_alias"})," est ici le nom de l'alias de l'espace de nomamge, et nom est le nom\nde l'espace de nommage lui-m\xeame."]}),"\n",(0,a.jsx)(n.p,{children:"Les noms donn\xe9s aux alias d'espaces de nommage ne doivent pas entrer en conflit\navec les noms des autres identificateurs du m\xeame espace de nommage, que celui-ci\nsoit l'espace de nommage de port\xe9e globale ou non."}),"\n",(0,a.jsxs)(n.h2,{id:"d\xe9claration-using",children:["D\xe9claration ",(0,a.jsx)(n.code,{children:"using"})]}),"\n",(0,a.jsxs)(n.p,{children:["Les d\xe9clarations ",(0,a.jsx)(n.code,{children:"using"})," permettent d'utiliser un identificateur de nommage de\nmani\xe8re simpl\xe9fi\xe9e, sans avoir \xe0 sp\xe9cifier son nom complet (c'est \xe0 dire le nom\nde l'espace de nommage suivi du nom de l'identificateur)."]}),"\n",(0,a.jsxs)(n.h3,{id:"syntaxe-des-d\xe9clarations-using",children:["Syntaxe des d\xe9clarations ",(0,a.jsx)(n.code,{children:"using"})]}),"\n",(0,a.jsxs)(n.p,{children:["La syntaxe des d\xe9clarations ",(0,a.jsx)(n.code,{children:"using"})," est la suivante"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"using identificateur;\n"})}),"\n",(0,a.jsx)(n.p,{children:"o\xf9 identificateur est le nom complet de l'identificateur \xe0 utiliser, avec\nqualification d'espace de nommage."}),"\n",(0,a.jsxs)(n.p,{children:["Les d\xe9clarations ",(0,a.jsx)(n.code,{children:"using"})," permettent en fait de d\xe9clarer des alias des\nidentificateurs. Ces alias doivent \xeatre consid\xe9r\xe9s exactement comme des\nd\xe9clarations normales. Cela signifie qu'ils ne peuvent \xeatre d\xe9clar\xe9s plusieurs\nfois que lorsque les d\xe9clarations multiples sont autoris\xe9es (d\xe9clarations de\nvariables ou de fonctions en dehors des classes), et de plus ils appartiennent \xe0\nl'espace de nommage dans lequel ils sont d\xe9finis."]}),"\n",(0,a.jsxs)(n.p,{children:["L'alias cr\xe9\xe9 par une d\xe9claration ",(0,a.jsx)(n.code,{children:"using"})," permet de r\xe9f\xe9rencer uniquement les\nidentificateurs qui sont visibles au moment o\xf9 la d\xe9claration ",(0,a.jsx)(n.code,{children:"using"})," est faite.\nSi l'espace de nomamge concern\xe9 par la d\xe9claration ",(0,a.jsx)(n.code,{children:"using"})," est \xe9tendu apr\xe8s\ncette derni\xe8re, les nouveaux identificateurs de m\xeame nom que celui de l'alias ne\nseront pas pris en compte."]}),"\n",(0,a.jsxs)(n.p,{children:["Si plusieurs d\xe9clarations locales et ",(0,a.jsx)(n.code,{children:"using"})," d\xe9clarent des identificateurs de\nm\xeame nom, ou bien ces identificateurs doivent tous se rapporter au m\xeame objet\nils doivent repr\xe9senter des fonctions ayant des signatures diff\xe9rentes (les\nfonctions d\xe9clar\xe9es sont des surcharg\xe9es). Dans le cas contraire, des ambigu\xeft\xe9s\npeuvent appara\xeetre et le compilateur signale une erreur lors de la d\xe9claration ",(0,a.jsx)(n.code,{children:"using"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"utilisation-des-d\xe9clarations-using-dans-les-classes",children:"Utilisation des d\xe9clarations using dans les classes"}),"\n",(0,a.jsxs)(n.p,{children:["Une d\xe9claration ",(0,a.jsx)(n.code,{children:"using"})," peut \xeatre utilis\xe9e dans la d\xe9finition d'une classe. Dans\nce cas, elle doit se rapporter \xe0 une classe de base de la classe dans laquelle\nest est utilis\xe9e. De plus l'identificateur donn\xe9 \xe0 la d\xe9claration ",(0,a.jsx)(n.code,{children:"using"})," doit\n\xeatre accessible dans la classe de base (c'est \xe0 dire du type protected ou\npublic)."]}),"\n",(0,a.jsxs)(n.p,{children:["En g\xe9n\xe9ral, les membres des classes de base sont accessibles directement. Quelle\nest donc l'utilit\xe9 des d\xe9clarations ",(0,a.jsx)(n.code,{children:"using"})," dans les classes ? En fait, elles\npeuvent \xeatre utilis\xe9es pour r\xe9tablir les droits d'acc\xe8s, modifi\xe9s par un\nh\xe9ritage, \xe0 des membres de classes de base. Pour cela, il suffit de placer la\nd\xe9claration ",(0,a.jsx)(n.code,{children:"using"})," dans une zone de d\xe9claration du m\xeame type que celle dans\nlaquelle le membre se trouvait dans la classe de base."]}),"\n",(0,a.jsxs)(n.p,{children:["Quand une fonction d'une classe de base est introduite dans une classe d\xe9riv\xe9e \xe0\nl'aide d'une d\xe9claration ",(0,a.jsx)(n.code,{children:"using"}),", et qu'une fonction de m\xeame nom et de m\xeame\nsignature est d\xe9finie dans la classe d\xe9riv\xe9e, cette derni\xe8re fonction surcharge\nla fonction de la classe de base. Il n'y a pas d'ambigu\xeft\xe9 dans ce cas."]}),"\n",(0,a.jsx)(n.h2,{id:"directive-using",children:"Directive using"}),"\n",(0,a.jsxs)(n.p,{children:["La directive using permet d'utiliser, sans sp\xe9cification d'espace de nomamge,\nnon pas un identificateur comme dans le cas de la d\xe9claration ",(0,a.jsx)(n.code,{children:"using"}),", mais tous\nles identificateurs de cet espace de nommage."]}),"\n",(0,a.jsxs)(n.p,{children:["La syntaxe de la directive ",(0,a.jsx)(n.code,{children:"using"})," est la suivante"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"using namespace nom;\n"})}),"\n",(0,a.jsx)(n.p,{children:"o\xf9 nom est le nom de l'espace de nommage dont les identificateurs doivent \xeatre\nutilis\xe9s sans qualification compl\xe8te."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"namespace A\n{\n    int i;        // D\xe9clare A::i.\n    int j;        // D\xe9clare A::j.\n}\n\nvoid f(void)\n{\n    using namespace A; // On utilise les identificateurs de A.\n    i=1;          // \xc9quivalent \xe0 A::i=1.\n    j=1;          // \xc9quivalent \xe0 A::j=1.\n    return ;\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Apr\xe8s une directive ",(0,a.jsx)(n.code,{children:"using"}),", il est toujours possible d'utiliser les noms\ncomplets des identificateurs de l'espace de nommage, mais ce n'est plus\nn\xe9cessaire. Les directives using sont valides \xe0 partir de la ligne o\xf9 elles sont\nd\xe9clar\xe9es jusqu'\xe0 la fin du bloc de porte courante. Si un espace de nommage est\n\xe9tendu apr\xe8s une directive ",(0,a.jsx)(n.code,{children:"using"}),", les identificateurs d\xe9finis dans l'extension\nde l'espace de nommage peuvent \xeatre utilis\xe9s exactement comme les\nidentificateurs d\xe9finis avant la directive using."]}),"\n",(0,a.jsx)(n.p,{children:"Il se peut que lors de l'introduction des identificateurs d'un espace de nommage par une directive using, des conflits de noms apparaissent. Dans ce cas, aucune erreur n'est signal\xe9e lors de la directive using. En revanche, une erreur se produit si un des identificateurs pour lesquels il y a conflit est utilis\xe9.l se peut"})]})}function u(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}}}]);