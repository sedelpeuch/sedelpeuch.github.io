"use strict";(self.webpackChunksedelpeuch_net=self.webpackChunksedelpeuch_net||[]).push([[8784],{38138:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"enseirb/s7/cpp/7","title":"Les templates","description":"G\xe9n\xe9ralit\xe9s","source":"@site/docs/enseirb/s7/cpp/7.md","sourceDirName":"enseirb/s7/cpp","slug":"/enseirb/s7/cpp/7","permalink":"/docs/enseirb/s7/cpp/7","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Les templates"},"sidebar":"tutorialSidebar","previous":{"title":"Les espaces de nommage","permalink":"/docs/enseirb/s7/cpp/6"},"next":{"title":"Programmation Orient\xe9e Objets","permalink":"/docs/enseirb/s7/poo/"}}');var a=t(74848),l=t(28453);const i={title:"Les templates"},r=void 0,c={},o=[{value:"G\xe9n\xe9ralit\xe9s",id:"g\xe9n\xe9ralit\xe9s",level:2},{value:"D\xe9claration des param\xe8tres template",id:"d\xe9claration-des-param\xe8tres-template",level:2},{value:"D\xe9claration des types template",id:"d\xe9claration-des-types-template",level:3},{value:"D\xe9claration des constantes template",id:"d\xe9claration-des-constantes-template",level:3},{value:"Fonctions et classes template",id:"fonctions-et-classes-template",level:2},{value:"Fonctions template",id:"fonctions-template",level:3},{value:"Les classes template",id:"les-classes-template",level:3},{value:"Fonctions membres template",id:"fonctions-membres-template",level:3},{value:"Instanciation des template",id:"instanciation-des-template",level:2},{value:"Instanciation implicite",id:"instanciation-implicite",level:3},{value:"Instanciation explicite",id:"instanciation-explicite",level:3}];function p(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"g\xe9n\xe9ralit\xe9s",children:"G\xe9n\xe9ralit\xe9s"}),"\n",(0,a.jsx)(n.p,{children:"Nous avons vu pr\xe9c\xe9demment comment r\xe9aliser des structures de donn\xe9es\nrelativement ind\xe9pendantes de la classe de leurs donn\xe9es (c'est \xe0 dire leur\ntype) avec les classes abstraites. Par ailleurs, il est faisable de faire des\nfonctions travaillant sur de nombreux types gr\xe2ce \xe0 la surcharge. Rappelons\nqu'en C++, tous les types sont en fait des classes."}),"\n",(0,a.jsx)(n.p,{children:"Cependant, l'emploi des classes abstraites est assez fastidieux et a\nl'inconv\xe9nient d'affaiblir le contr\xf4le des types r\xe9alis\xe9 par le compilateur. De\nplus, la surcharge n'est pas g\xe9n\xe9ralisable pour tous les types de donn\xe9es. Il\nserait possible d'utiliser des macros pour faire des fonctions atypiques mais\ncela serait au d\xe9triment de la taille du code."}),"\n",(0,a.jsx)(n.p,{children:"Le C++ permet de r\xe9soudre ces probl\xe8mes gr\xe2ce aux param\xe8tres g\xe9n\xe9riques, que\nl'on appelle encore param\xe8tre template. Un param\xe8tre template est soit un type\ng\xe9n\xe9rique, soit une constante dont le type est assimilable \xe0 un type int\xe9gral.\nComme leur nom l'indique, les param\xe8tres template permettent de param\xe9trer la\nd\xe9finition des fonctions et des classes. Les fonctions et les classes ainsi\nparam\xe9tr\xe9es sont appel\xe9es respectivement fonctions template et classes template."}),"\n",(0,a.jsx)(n.p,{children:"LEs fonctions template sont donc des fonctions qui peuvent travailler sur des\nobjets dont le type est un type g\xe9n\xe9rique (c'est \xe0 dire un type quelconque), ou\nqui peuvent \xeatres param\xe9tr\xe9s par une constante de type int\xe9gral. Les classes\ntemplate sont des classes qui contiennent des membres dont le type est g\xe9n\xe9rique\nou qui d\xe9pendent d'un param\xe8tre int\xe9gral."}),"\n",(0,a.jsx)(n.p,{children:"En g\xe9n\xe9ral, la g\xe9n\xe9ration du code a lieu lors d'une op\xe9ration au cours de\nlaquelle les types g\xe9n\xe9riques sont remplac\xe9s par des vrais types et les\nparam\xe8tres de type int\xe9gral prennent leur valeur. Cette op\xe9ration s'appelle\nl'instanciation des template. Elle a lieu lorsqu'on utilise une fonction ou la\nclasse template pour la premi\xe8re fois. Les types r\xe9els \xe0 utiliser \xe0 la place des\ntypes g\xe9n\xe9riques sont d\xe9termin\xe9s lors de cette premi\xe8re utilisation par le\ncompilateur, soit implicitement \xe0 partir du contexte d'utilisation du template,\nsoit par les param\xe8tres donn\xe9s explicitement par le programmeur."}),"\n",(0,a.jsx)(n.h2,{id:"d\xe9claration-des-param\xe8tres-template",children:"D\xe9claration des param\xe8tres template"}),"\n",(0,a.jsx)(n.p,{children:"Les param\xe8tres template sont, comme on l'a vu, soit des types g\xe9n\xe9riques, soit\ndes constantes dont le type peut \xeatre assimil\xe9 \xe0 un type int\xe9gral."}),"\n",(0,a.jsx)(n.h3,{id:"d\xe9claration-des-types-template",children:"D\xe9claration des types template"}),"\n",(0,a.jsx)(n.p,{children:"Les template qui sont des types g\xe9n\xe9riques sont d\xe9clar\xe9s par la syntaxe\nsuivante"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"template <class|typename nom[=type]\n         [, class|typename nom[=type]\n         [...]>\n"})}),"\n",(0,a.jsx)(n.p,{children:"o\xf9 nom est le nom que l'on donne au type g\xe9n\xe9rique dans cette d\xe9claration. Le\nmot cl\xe9 class a ici exactement la signification de \"type\". Il peut d'ailleurs\n\xeatre remplac\xe9 indiff\xe9remment dans cette syntaxe par le mot cl\xe9 typename. La m\xeame\nd\xe9claration peut \xeatre utilis\xe9e pour d\xe9clarer un nombre arbitraire de types\ng\xe9n\xe9riques, en les s\xe9parant par des virgules. Les param\xe8tres template qui sont\ndes types peuvent prendre des valeurs par d\xe9faut, en faisant suivre le nom du\nparam\xe8tre d'un signe \xe9gale et de la valeur. Ici, la valeur par d\xe9faut doit\n\xe9videmment \xeatre un type d\xe9j\xe0 d\xe9clar\xe9."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"template <class T, typename U, class V=int>\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Dans cet exemple, T, U et V sont des types g\xe9n\xe9riques. Ils peuvent remplacer\nn'importe quel type de langage d\xe9j\xe0 d\xe9clar\xe9 au moment o\xf9 la d\xe9claration template\nest faite. De plus, le type g\xe9n\xe9rique V a pour valeur par d\xe9faut le type entier\n",(0,a.jsx)(n.code,{children:"int"}),". On voit bien dans cet exemple que les mots cl\xe9s ",(0,a.jsx)(n.code,{children:"typename"})," et ",(0,a.jsx)(n.code,{children:"class"}),"\npeuvent \xeatre utilis\xe9s indiff\xe9remment."]}),"\n",(0,a.jsxs)(n.p,{children:["Lorsqu'on donne des valeurs par d\xe9faut \xe0 un type g\xe9n\xe9rique, on doit donner des\nvaleurs par d\xe9faut \xe0 tous les types g\xe9n\xe9riques qui le suivent dans la\nd\xe9claration ",(0,a.jsx)(n.code,{children:"template"}),". La ligne suivante provoquera donc une erreur de\ncompilation ",(0,a.jsx)(n.code,{children:"template <class T=int, class V>"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Ils est possible d'utiliser une classe template en tant que type g\xe9n\xe9rique. Dans\nce cas, la classe doit \xeatre d\xe9clar\xe9e comme \xe9tant template \xe0 l'int\xe9rieur m\xeame de\nla d\xe9claration ",(0,a.jsx)(n.code,{children:"template"}),". La syntaxe est donc la suivante"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"template <template <class Type> class Classe [,...]>\n"})}),"\n",(0,a.jsxs)(n.p,{children:["o\xf9 ",(0,a.jsx)(n.code,{children:"Type"})," est le type g\xe9n\xe9rique utilis\xe9 dans la d\xe9claration de la classe\n",(0,a.jsx)(n.code,{children:"template"})," Classe. On appelle les param\xe8tres ",(0,a.jsx)(n.code,{children:"template"})," qui sont des classes\n",(0,a.jsx)(n.code,{children:"template"})," des param\xe8tres ",(0,a.jsx)(n.code,{children:"template template"}),". Rien n'interdit de donner une\nvaleur par d\xe9faut \xe0 un param\xe8tre ",(0,a.jsx)(n.code,{children:"template template"})," : le type utilis\xe9 doit\nalors \xeatre une classe ",(0,a.jsx)(n.code,{children:"template"})," d\xe9clar\xe9e avec la d\xe9claration ",(0,a.jsx)(n.code,{children:"template"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"template <class T>\nclass Tableau\n{\n    // D\xe9finition de la classe template Tableau.\n};\n\ntemplate <class U, class V, template <class T> class C=Tableau>\nclass Dictionnaire\n{\n    C<U> Clef;\n    C<V> Valeur;\n    // Reste de la d\xe9finition de la classe Dictionnaire.\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Dans cet exemple, la classe ",(0,a.jsx)(n.code,{children:"template"})," Dictionnaire permet de relier des cl\xe9s \xe0\nleurs \xe9l\xe9ments. Ces cl\xe9s et ces valeurs peuvent prendre n'importe quel type. Les\ncl\xe9s et les valeurs stock\xe9es parall\xe8lement dans les membres Clef et Valeur. Ces\nmembres sont en fait des conteneurs ",(0,a.jsx)(n.code,{children:"template"}),", dont la classe est g\xe9n\xe9rique et\nd\xe9sign\xe9e par le param\xe8tre ",(0,a.jsx)(n.code,{children:"template template"})," C. Le param\xe8tre ",(0,a.jsx)(n.code,{children:"template"})," de C\nest utilis\xe9 pour donner le type des donn\xe9es stock\xe9es, \xe0 savoir les types\ng\xe9n\xe9riques U et V dans le cas de la classe Dictionnaire. Enfin, la classe\nDictionnaire peut utiliser un conteneur par d\xe9faut, qui est la classe ",(0,a.jsx)(n.code,{children:"template"}),"\nTableau."]}),"\n",(0,a.jsx)(n.h3,{id:"d\xe9claration-des-constantes-template",children:"D\xe9claration des constantes template"}),"\n",(0,a.jsxs)(n.p,{children:["La d\xe9claration des param\xe8tres de ",(0,a.jsx)(n.code,{children:"type"})," constante se fait de la mani\xe8re suivante"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"template <type param\xe8tre[=valeur][,...]>\n"})}),"\n",(0,a.jsx)(n.p,{children:"o\xf9 type est le type du param\xe8tre constant, param\xe8tre est le nom du param\xe8tre et\nvaleur est sa valeur par d\xe9faut. Il est possible de donner des param\xe8tres\ntemplate qui sont des types g\xe9n\xe9riques et des param\xe8tres template qui sont des\nconstantes dans la m\xeame d\xe9claration."}),"\n",(0,a.jsx)(n.p,{children:"Le type des constantes template doit obligatoirement \xeatre l'un des types\nsuivants"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"type int\xe9gral ou \xe9num\xe9r\xe9"}),"\n",(0,a.jsx)(n.li,{children:"pointeur ou r\xe9f\xe9rence d'objet"}),"\n",(0,a.jsx)(n.li,{children:"pointeur ou r\xe9f\xe9rence de fonction"}),"\n",(0,a.jsx)(n.li,{children:"pointeur sur membre"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Ce sont donc tous les types qui peuvent \xeatre assimil\xe9s \xe0 des valeurs enti\xe8re\n(entier, \xe9num\xe9r\xe9s ou adresses)."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"template <class T, int i, void (*f)(int)>\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Cette d\xe9claration template comprend un type g\xe9n\xe9rique T, une constante template\n",(0,a.jsx)(n.code,{children:"i"})," de type int, et une constante template ",(0,a.jsx)(n.code,{children:"f"})," de type pointeur sur fonction\nprenant un entier en param\xe8tre et ne renvoyant rien."]}),"\n",(0,a.jsx)(n.h2,{id:"fonctions-et-classes-template",children:"Fonctions et classes template"}),"\n",(0,a.jsx)(n.p,{children:"Apr\xe8s la d\xe9claration d'un ou de plusieurs param\xe8tres template suit en g\xe9n\xe9ral la\nd\xe9claration ou la d\xe9finition d'une fonction ou d'une classe template. Dans cette\nd\xe9finition, les types g\xe9n\xe9riques peuvent \xeatre utilis\xe9s exactement comme s'il\ns'agissait de types normaux. Les constantes template peuvent \xeatre utilis\xe9es pour\nla fonction ou la classe template comme des constantes locales."}),"\n",(0,a.jsx)(n.h3,{id:"fonctions-template",children:"Fonctions template"}),"\n",(0,a.jsx)(n.p,{children:"La d\xe9claration et la d\xe9finition des fonctions template se fait exactement comme\ns'il s'agissait de types normaux, \xe0 ceci pr\xe8s qu'elle doit \xeatre pr\xe9c\xe9d\xe9e de la\nd\xe9claration des param\xe8tres template. La syntaxe d'une d\xe9claration de fonction\ntemplate est donc la suivante"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"template <param\xe8tres_template>\ntype fonction(param\xe8tres_fonction);\n"})}),"\n",(0,a.jsx)(n.p,{children:"o\xf9 param\xe8tres_template est la liste des param\xe8tres template et\nparam\xe8tres_fonction est la liste des param\xe8tres de la fonction. type est le\ntype de la valeur de retour de la fonction, ce peut \xeatre un des types g\xe9n\xe9riques\nde la liste des param\xe8tres template."}),"\n",(0,a.jsx)(n.p,{children:"Tous les param\xe8tres template qui sont des types doivent \xeatre utilis\xe9s dans la\nliste des param\xe8tres de la fonction, \xe0 moins qu'une instanciation explicite de\nla fonction ne soit utilis\xe9e. Cela permet au compilateur de r\xe9aliser\nl'identification des types g\xe9n\xe9riques avec les types \xe0 utiliser lors de\nl'instanciation de la fonction."}),"\n",(0,a.jsx)(n.p,{children:"La d\xe9finition d'une fonction template se fait comme une d\xe9claration avec le\ncorps de la fonction. Il est alors possible d'y utiliser les param\xe8tres template\ncomme s'ils \xe9taient des types normaux : des variables peuvent \xeatre d\xe9clar\xe9es\navec un type g\xe9n\xe9rique, et les constantes template peuvent \xeatre utilis\xe9es comme\ndes variables d\xe9finies localement avec la classe de stockage const. Les\nfonctions template s'\xe9crivent donc exactement comme des fonctions classiques."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"template <class T>\nT Min(T x, T y){\n    return x<y ? x:y;\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["La fonction Min ainsi d\xe9finie fonctionnera parfaitement pour toute classe pour\nlaquelle l'op\xe9rateur ",(0,a.jsx)(n.code,{children:"<"})," est d\xe9fini. Le compilateur d\xe9terminera automatiquement\nquel est l'op\xe9rateur \xe0 employer pour chaque fonction Min qu'il rencontrera."]}),"\n",(0,a.jsx)(n.p,{children:"Les fonctions template peuvent \xeatre surcharg\xe9es, aussi bien par des fonctions\nclassiques que par d'autres fonctions template. Lorsqu'il y a ambigu\xeft\xe9 entre\nune fonction template et une fonction normale qui la surcharge, toutes les\nr\xe9f\xe9rences sur le nom commun \xe0 ces fonctions se rapporteront \xe0 la fonction\nclassique."}),"\n",(0,a.jsx)(n.p,{children:"Une fonction template peut \xeatre d\xe9clar\xe9e amie d'une classe, template ou non,\npourvu que cette classe ne soit pas locale. Toutes les instances g\xe9n\xe9r\xe9es \xe0\npartir d'une fonction amie template sont amies de la classe donnant l'amiti\xe9, et\nont donc libre acc\xe8s sur toutes les donn\xe9es de cette classe."}),"\n",(0,a.jsx)(n.h3,{id:"les-classes-template",children:"Les classes template"}),"\n",(0,a.jsx)(n.p,{children:"La d\xe9claration et la d\xe9finition d'une classe template se font comme celles d'une\nfonction template : elles doivent \xeatre pr\xe9c\xe9d\xe9es de la d\xe9claration template des\ntypes g\xe9n\xe9riques. La d\xe9claration suit donc la syntaxe suivante"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"template <param\xe8tres_template>\nclass|struct|union nom;\n"})}),"\n",(0,a.jsx)(n.p,{children:"La seule particularit\xe9 dans la d\xe9finition des classes template est que si les\nm\xe9thodes de la classe ne sont pas d\xe9finies dans la d\xe9claration de la classe,\nelles devront elles aussi \xeatre d\xe9clar\xe9es template"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"template <param\xe8tres_template>\ntype classe<param\xe8tres>::nom(param\xe8tres_m\xe9thode){\n...\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Il est absolument n\xe9cessaire dans ce cas de sp\xe9cifier tous les param\xe8tres\ntemplate de la lise param\xe8tres_template dans param\xe8tres, s\xe9par\xe9s par des\nvirgules, afin de caract\xe9riser le fait que c'est la classe qui est template et\nqu'il ne s'agit pas d'une m\xe9thode template d'une classe normale. D'une mani\xe8re\ng\xe9n\xe9rale, il faudra toujours sp\xe9cifier les types g\xe9n\xe9riques de la classe entre\nles signes d'inf\xe9riorit\xe9 et de sup\xe9riorit\xe9, juste apr\xe8s son nom, \xe0 chaque fois\nqu'on voudra r\xe9f\xe9rencer. Cette r\xe8gle est cependant facultative lorsque la classe\nest r\xe9f\xe9renc\xe9e \xe0 l'int\xe9rieur d'une fonction membre."}),"\n",(0,a.jsx)(n.p,{children:"Contrairement aux fonctions template non membres, les m\xe9thodes des classes\ntemplate peuvent utiliser des types g\xe9n\xe9riques de leur classe  sans pour autant\nqu'ils soient utilis\xe9s dans la liste de leurs param\xe8tres. En effet, le\ncompilateur d\xe9termine quels sont les types \xe0 identifier aux types g\xe9n\xe9riques\nlors de l'instanciation de la classe template, et n'a donc pas besoin\nd'effectuer cette identification avec les types des param\xe8tres utilis\xe9s."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'template <class T>\nclass Stack\n{\n    typedef struct stackitem\n    {\n        T Item;                 // On utilise le type T comme\n        struct stackitem *Next; // si c\'\xe9tait un type normal.\n    } StackItem;\n\n    StackItem *Tete;\n\npublic:         // Les fonctions de la pile :\n    Stack(void);\n    Stack(const Stack<T> &);\n                 // La classe est r\xe9f\xe9renc\xe9e en indiquant\n                 // son type entre < et > ("Stack<T>").\n                 // Ici, ce n\'est pas une n\xe9cessit\xe9\n                 // cependant.\n    ~Stack(void);\n    Stack<T> &operator=(const Stack<T> &);\n    void push(T);\n    T pop(void);\n    bool is_empty(void) const;\n    void flush(void);\n};\n\n// Pour les fonctions membres d\xe9finies en dehors de la d\xe9claration\n// de la classe, il faut une d\xe9claration de type g\xe9n\xe9rique :\n\ntemplate <class T>\nStack<T>::Stack(void) // La classe est r\xe9f\xe9renc\xe9e en indiquant\n                      // son type entre < et > ("Stack<T>").\n                      // C\'est imp\xe9ratif en dehors de la\n                      // d\xe9claration de la classe.\n{\n    Tete = NULL;\n    return;\n}\n\ntemplate <class T>\nStack<T>::Stack(const Stack<T> &Init)\n{\n    Tete = NULL;\n    StackItem *tmp1 = Init.Tete, *tmp2 = NULL;\n    while (tmp1!=NULL)\n    {\n        if (tmp2==NULL)\n        {\n            Tete= new StackItem;\n            tmp2 = Tete;\n        }\n        else\n        {\n            tmp2->Next = new StackItem;\n            tmp2 = tmp2->Next;\n        }\n        tmp2->Item = tmp1->Item;\n        tmp1 = tmp1->Next;\n    }\n    if (tmp2!=NULL) tmp2->Next = NULL;\n    return;\n}\n\ntemplate <class T>\nStack<T>::~Stack(void)\n{\n    flush();\n    return;\n}\n\ntemplate <class T>\nStack<T> &Stack<T>::operator=(const Stack<T> &Init)\n{\n    flush();\n    StackItem *tmp1 = Init.Tete, *tmp2 = NULL;\n\n    while (tmp1!=NULL)\n    {\n        if (tmp2==NULL)\n        {\n            Tete = new StackItem;\n            tmp2 = Tete;\n        }\n        else\n        {\n            tmp2->Next = new StackItem;\n            tmp2 = tmp2->Next;\n        }\n        tmp2->Item = tmp1->Item;\n        tmp1 = tmp1->Next;\n    }\n    if (tmp2!=NULL) tmp2->Next = NULL;\n    return *this;\n}\n\ntemplate <class T>\nvoid Stack<T>::push(T Item)\n{\n    StackItem *tmp = new StackItem;\n    tmp->Item = Item;\n    tmp->Next = Tete;\n    Tete = tmp;\n    return;\n}\n\ntemplate <class T>\nT Stack<T>::pop(void)\n{\n    T tmp;\n    StackItem *ptmp = Tete;\n\n    if (Tete!=NULL)\n    {\n        tmp = Tete->Item;\n        Tete = Tete->Next;\n        delete ptmp;\n    }\n    return tmp;\n}\n\ntemplate <class T>\nbool Stack<T>::is_empty(void) const\n{\n    return (Tete==NULL);\n}\n\ntemplate <class T>\nvoid Stack<T>::flush(void)\n{\n    while (Tete!=NULL) pop();\n    return;\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Les classes template peuvent parfaitement avoir des fonctions amies, que ces\nfonctions soient elles-m\xeame template ou non."}),"\n",(0,a.jsx)(n.h3,{id:"fonctions-membres-template",children:"Fonctions membres template"}),"\n",(0,a.jsx)(n.p,{children:"Les destructeurs mis \xe0 part, les m\xe9thodes d'une classe peuvent \xeatre template,\nque la classe elle-m\xeame soit template ou non, pourvu que la classe ne soit pas\nune classe locale."}),"\n",(0,a.jsx)(n.p,{children:"Les fonctions membres template peuvent appartenir \xe0 une classe template ou \xe0 une\nclasse normale."}),"\n",(0,a.jsx)(n.p,{children:"Lorsque la classe \xe0 laquelle elles appartiennent n'est pas template, leur\nsyntaxe est exactement la m\xeame que pour les fonctions template non membre."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"class A\n{\n    int i;   // Valeur de la classe.\npublic:\n    template <class T>\n    void add(T valeur);\n};\n\ntemplate <class T>\nvoid A::add(T valeur)\n{\n    i=i+((int) valeur);   // Ajoute valeur \xe0 A::i.\n    return ;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Si, en revanche, la classe dont la fonction membre fait partie est elle aussi\ntemplate, il faut sp\xe9cifier deux fois la syntaxe template : une fois pour la\nclasse, et une fois pour la fonction. Si la fonction membre template est d\xe9finie\n\xe0 l'int\xe9rieur de la classe, il n'est pas n\xe9cessaire de donner les param\xe8tres\ntemplate de la classe, et la fonction membre template se fait donc exactement\ncomme celle d'une fonction template classique."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"template<class T>\nclass Chaine\n{\npublic:\n    // Fonction membre template d\xe9finie\n    // \xe0 l'ext\xe9rieur de la classe template :\n\n    template<class T2> int compare(const T2 &);\n\n    // Fonction membre template d\xe9finie\n    // \xe0 l'int\xe9rieur de la classe template :\n\n    template<class T2>\n    Chaine(const Chaine<T2> &s)\n    {\n        // ...\n    }\n};\n\n// \xc0 l'ext\xe9rieur de la classe template, on doit donner\n// les d\xe9clarations template pour la classe\n// et pour la fonction membre template :\n\ntemplate<class T> template<class T2>\nint Chaine<T>::compare(const T2 &s)\n{\n    // ...\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Les fonctions membres virtuelles ne peuvent pas \xeatre template. Si une fonction\nmembre template a le m\xeame nom qu'une fonction membre virtuelle d'une classe de\nbase, elle ne constitue pas une red\xe9finition de cette fonction. Par cons\xe9quent,\nles m\xe9canismes de virtualit\xe9 sont inutilisables avec les fonctions membres\ntemplate. On peut contourner ce probl\xe8me de la mani\xe8re suivante : on d\xe9finira\nune fonction membre virtuelle non template qui appellera la fonction membre template."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"class B\n{\n    virtual void f(int);\n};\n\nclass D : public B\n{\n    template <class T>\n    void f(T);     // Cette fonction ne red\xe9finit pas B::f(int).\n\n    void f(int i)  // Cette fonction surcharge B::f(int).\n    {\n        f<>(i);    // Elle appelle de la fonction template.\n        return ;\n    }\n};\n"})}),"\n",(0,a.jsx)(n.p,{children:"Dans l'exemple pr\xe9c\xe9dent, on est oblig\xe9 de pr\xe9ciser que la fonction \xe0 appeler\ndans la fonction virtuelle est template, et qu'il ne s'agit donc pas d'un appel\nr\xe9cursif de la fonction virtuelle. Pour cela, on fait suivre le nom de la\nfonction template d'une paire de signes inf\xe9rieur et sup\xe9rieur."}),"\n",(0,a.jsx)(n.p,{children:"Plus g\xe9n\xe9ralement, si une fonction membre template d'une classe peut \xeatre\nsp\xe9cialis\xe9e en une fonction qui a la m\xeame signature qu'une autre fonction membre\nde la m\xeame classe, et que ces deux fonctions ont le m\xeame nom, toute r\xe9f\xe9rence \xe0\nce nom utilisera la fonction non-template. Il est possible de passer outre cette\nr\xe8gle, \xe0 condition de donner explicitement la liste des param\xe8tres template\nentre les signes inf\xe9rieur et sup\xe9rieur lors de l'appel de la fonction."}),"\n",(0,a.jsx)(n.h2,{id:"instanciation-des-template",children:"Instanciation des template"}),"\n",(0,a.jsx)(n.p,{children:"La d\xe9finition des fonctions et des classes template ne g\xe9n\xe8re aucun code tant\nque tous les param\xe8tres template n'ont pas pris chacun une valeur sp\xe9cifique. Il\nfaut donc, lors de l'utilisation d'une fonction ou d'une classe template,\nfournir les valeurs pour tous les param\xe8tres qui n'ont pas de valeur de d\xe9faut.\nLorsque suffisamment de valeurs sont donn\xe9es, le code est g\xe9n\xe9r\xe9 pour ce jeu de\nvaleurs. On appelle cette op\xe9ration l'instanciation des template."}),"\n",(0,a.jsx)(n.p,{children:"Plusieurs possibilit\xe9s sont offertes pour parvenir \xe0 ce r\xe9sultat :\nl'instanciation implicite et l'instanciation explicite."}),"\n",(0,a.jsx)(n.h3,{id:"instanciation-implicite",children:"Instanciation implicite"}),"\n",(0,a.jsx)(n.p,{children:"L'instanciation implicite est utilis\xe9e par le compilateur lorsqu'il rencontre\nune expression qu'il utilise pour la premi\xe8re fois une fonction ou une classe\ntemplate, et qu'il doit instancier pour continuer son travail. Le compilateur se\nbase alors sur le contexte courant pour d\xe9terminer les types des param\xe8tres\ntemplate \xe0 utiliser. Si aucune ambigu\xeft\xe9 n'a lieu, il g\xe9n\xe8re le code pour ce jeu\nde param\xe8tres."}),"\n",(0,a.jsx)(n.p,{children:"La d\xe9termination des types des param\xe8tres template peut se faire simplement ou\n\xeatre d\xe9duite de l'expression \xe0 compiler. Par exemple, les fonctions membres\ntemplate sont instanci\xe9es en fonction du type de leurs param\xe8tres. Si l'on\nreprend l'exemple de la fonction template Min, c'est son utilisation directe qui\nprovoque l'instanciation implicite."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"int i = Min(2,3);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["dans cet exemple, le param\xe8tre template est forc\xe9 \xe0 ",(0,a.jsx)(n.code,{children:"int"}),", et 3.0 est converti\nen entier."]}),"\n",(0,a.jsx)(n.p,{children:"On prendra garde au fait que le compilateur utiliser une politique minimaliste\npour l'instanciation des template. Cela signifie qu'il ne cr\xe9era que le code\nn\xe9cessaire pour compiler l'expression qui exige une instanciation implicite. Par\nexemple, la d\xe9finition d'un objet d'une classe template dont tous les types\nd\xe9finis provoque l'instanciation de cette classe, mais la d\xe9finition d'un\npointeur sur cette classe ne le fait pas. L'instanciation aura lieu lorsqu'un\nd\xe9r\xe9f\xe9rencement sera fait par l'interm\xe9diaire de ce pointeur. De m\xeame, seules\nles fonctionnalit\xe9s utilis\xe9es de la classe template seront effectivement\nd\xe9finies dans le programme final."}),"\n",(0,a.jsx)(n.h3,{id:"instanciation-explicite",children:"Instanciation explicite"}),"\n",(0,a.jsx)(n.p,{children:"L'instanciation explicite des template est une technique permettant au\nprogrammeur de forcer l'instanciation des template dans son programme. Pour\nr\xe9aliser une instanciation explicite, il faut sp\xe9cifier explicitement tous les\nparam\xe8tres template \xe0 utiliser. Cela se fait simplement en donnant la\nd\xe9claration du template, pr\xe9c\xe9d\xe9e par le mot cl\xe9 template."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"template nom<valeur[, valeur[...]]>;\n"})})]})}function d(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var s=t(96540);const a={},l=s.createContext(a);function i(e){const n=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(l.Provider,{value:n},e.children)}}}]);