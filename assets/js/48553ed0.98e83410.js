"use strict";(self.webpackChunksedelpeuch_net=self.webpackChunksedelpeuch_net||[]).push([[3521],{28453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>a});var t=n(96540);const r={},l=t.createContext(r);function i(e){const s=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(l.Provider,{value:s},e.children)}},66798:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"enseirb/s7/cpp/4","title":"La couche objet - Partie 4 : Les entr\xe9es/sorties, M\xe9thodes virtuelles, D\xe9rivation, Classe abstraites","description":"Des entr\xe9es - sorties simplifi\xe9es","source":"@site/docs/enseirb/s7/cpp/4.md","sourceDirName":"enseirb/s7/cpp","slug":"/enseirb/s7/cpp/4","permalink":"/docs/enseirb/s7/cpp/4","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"La couche objet - Partie 4 : Les entr\xe9es/sorties, M\xe9thodes virtuelles, D\xe9rivation, Classe abstraites"},"sidebar":"tutorialSidebar","previous":{"title":"La couche Objet - Partie 3 : op\xe9rateurs","permalink":"/docs/enseirb/s7/cpp/3"},"next":{"title":"Les exceptions en C++","permalink":"/docs/enseirb/s7/cpp/5"}}');var r=n(74848),l=n(28453);const i={title:"La couche objet - Partie 4 : Les entr\xe9es/sorties, M\xe9thodes virtuelles, D\xe9rivation, Classe abstraites"},a=void 0,d={},o=[{value:"Des entr\xe9es - sorties simplifi\xe9es",id:"des-entr\xe9es---sorties-simplifi\xe9es",level:2},{value:"M\xe9thodes virtuelles",id:"m\xe9thodes-virtuelles",level:2},{value:"D\xe9rivation",id:"d\xe9rivation",level:2},{value:"M\xe9thodes virtuelles pures - Classes abstraites",id:"m\xe9thodes-virtuelles-pures---classes-abstraites",level:2},{value:"Pointeurs sur les membres d&#39;une classe",id:"pointeurs-sur-les-membres-dune-classe",level:2}];function c(e){const s={code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.h2,{id:"des-entr\xe9es---sorties-simplifi\xe9es",children:"Des entr\xe9es - sorties simplifi\xe9es"}),"\n",(0,r.jsxs)(s.p,{children:["Les flux d'entr\xe9e / sortie de la biblioth\xe8que standard C++ constituent sans\ndoute l'une des applications les plus int\xe9ressantes de la surcharge des\nop\xe9rateurs. Comme nous allons le voir, la surcharge des op\xe9rateurs ",(0,r.jsx)(s.code,{children:"<<"})," et ",(0,r.jsx)(s.code,{children:">>"}),"\npermet d'\xe9crire et de lire sur ces flux de mani\xe8re tr\xe8s intuitive."]}),"\n",(0,r.jsxs)(s.p,{children:["En effet, la biblioth\xe8que standard C++ d\xe9finit dans l'en-t\xeate ",(0,r.jsx)(s.code,{children:"iostream"})," des\nclasses extr\xeamement puissantes permettant de manipuler les flux d'entr\xe9e /\nsortie. Ces classes r\xe9alisent en particulier les op\xe9rations d'entr\xe9e / sortie et\nvers les p\xe9riph\xe9riques d'entr\xe9e et les p\xe9riph\xe9riques de sortie standards\n(g\xe9n\xe9ralement, le clavier et l'\xe9cran), mais elles ne s'arr\xeatent pas l\xe0 : elles\npermettent \xe9galement de travailler sur des fichiers ou encore sur des tampons en\nm\xe9moire."]}),"\n",(0,r.jsxs)(s.p,{children:["Les classes d'entr\xe9e / sortie de la biblioth\xe8que standard C++ permettent donc\nd'effectuer les m\xeames op\xe9rations que les fonctions ",(0,r.jsx)(s.code,{children:"printf"})," et ",(0,r.jsx)(s.code,{children:"scanf"})," de la\nbiblioth\xe8que C standard. Cependant, gr\xe2ce au m\xe9canisme de surcharge des\nop\xe9rateurs, elles sont beaucoup plus faciles d'utilisation. En effet, les\nop\xe9rateurs ",(0,r.jsx)(s.code,{children:"<<"})," et ",(0,r.jsx)(s.code,{children:">>"})," de ces classes ont \xe9t\xe9 surcharg\xe9s pour chaque type de\ndonn\xe9e du langage, permettant ainsi de r\xe9aliser des entr\xe9es / sorties typ\xe9es\nextr\xeamement facilement. L'op\xe9rateur ",(0,r.jsx)(s.code,{children:"<<"}),", \xe9galement appel\xe9 op\xe9rateur\nd'insertion, sera utilis\xe9 pour r\xe9aliser des \xe9critures sur un flux de donn\xe9es,\ntant que l'op\xe9rateur ",(0,r.jsx)(s.code,{children:">>"}),", ou op\xe9rateur d'extraction, permettra de r\xe9aliser la\nlecture d'une nouvelle donn\xe9e dans le flux d'entr\xe9e. Ces deux op\xe9rateurs\nrenvoient tous les deux le flux de donn\xe9es utilis\xe9, ce qui permet de r\xe9aliser\nplusieurs op\xe9rations d'entr\xe9e / sortie successivement sur le m\xeame flux."]}),"\n",(0,r.jsxs)(s.p,{children:["La biblioth\xe8que standard d\xe9finit quatre instances particuli\xe8res de ses classes\nd'entr\xe9e / sortie : ",(0,r.jsx)(s.code,{children:"cin"}),", ",(0,r.jsx)(s.code,{children:"cout"}),", ",(0,r.jsx)(s.code,{children:"cerr"})," et ",(0,r.jsx)(s.code,{children:"clog"}),". Ces objets sont des\ninstances des classes ",(0,r.jsx)(s.code,{children:"istream"})," et ",(0,r.jsx)(s.code,{children:"ostream"}),", prenant respectivement en charge\nl'entr\xe9e et la sortie des donn\xe9es des programmes. L'objet ",(0,r.jsx)(s.code,{children:"cin"})," correspond au\nflux d'entr\xe9e standard ",(0,r.jsx)(s.code,{children:"stdin"})," du programme, et l'objet ",(0,r.jsx)(s.code,{children:"cout"})," aux flux de\nsortie standard ",(0,r.jsx)(s.code,{children:"stdout"}),". Enfin, les objets ",(0,r.jsx)(s.code,{children:"cerr"})," et ",(0,r.jsx)(s.code,{children:"clog"})," sont associ\xe9s au\nflux d'erreurs standard ",(0,r.jsx)(s.code,{children:"stderr"}),". Th\xe9oriquement, ",(0,r.jsx)(s.code,{children:"cerr"})," doit \xeatre utilis\xe9 pour\nl'\xe9criture des messages d'erreur des programmes, et ",(0,r.jsx)(s.code,{children:"clog"})," pour les messages\nd'information. Cependant, en pratique, les donn\xe9es \xe9crites sur ces deux flux\nsont \xe9crites dans le m\xeame flux, et l'emploi de l'objet ",(0,r.jsx)(s.code,{children:"clog"})," est assez rare."]}),"\n",(0,r.jsx)(s.p,{children:"L'utilisation des op\xe9rateurs d'insertion et d'extraction sur ces flux se r\xe9sume\ndonc \xe0 la syntaxe suivante"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"cin >> variable [>> variable [...]];\ncout << valeur [<< valeur [...]];\n"})}),"\n",(0,r.jsx)(s.p,{children:"Comme on le voit, il est possible d'effectuer plusieurs entr\xe9es ou plusieurs\nsortie successivement sur un m\xeame flux."}),"\n",(0,r.jsxs)(s.p,{children:["DE plus, la biblioth\xe8que standard d\xe9finie ce que l'on appelle des manipulateurs\npermettant de r\xe9aliser des op\xe9rations simples sur les flux d'entr\xe9e / sortie .\nLe manipulateur le plus utilis\xe9 est sans nul doute le manipulateur ",(0,r.jsx)(s.code,{children:"endl"})," qui,\ncomme son nom l'indique, permet de signaler une fin de ligne et d'effectuer un\nsaut de ligne lorsqu'il est employ\xe9 sur un flux de sortie."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:'#include <iostream>\n\nusing namespace std;\n\nint main(void)\n{\n    int i;\n    // Lit un entier :\n    cin >> i;\n    // Affiche cet entier et le suivant :\n    cout << i << " " << i+1 << endl;\n    return 0;\n}\n'})}),"\n",(0,r.jsx)(s.h2,{id:"m\xe9thodes-virtuelles",children:"M\xe9thodes virtuelles"}),"\n",(0,r.jsxs)(s.p,{children:["Les m\xe9thodes virtuelles ",(0,r.jsx)(s.strong,{children:"n'ont strictement rien \xe0 voir"})," avec les classes\nvirtuelles, bien qu'elles utilisent le m\xeame mot cl\xe9 ",(0,r.jsx)(s.code,{children:"virtual"}),". Ce mot cl\xe9 est\nutilis\xe9 dans un contexte et dans un sens diff\xe9rent."]}),"\n",(0,r.jsx)(s.p,{children:"Nous savons qu'il est possible de red\xe9finir les m\xe9thodes d'une classe m\xe8re dans\nune classe fille. Lors de l'appel d'une fonction ainsi red\xe9finie, la fonction\nappel\xe9e est la derni\xe8re fonction d\xe9finie dans la hi\xe9rarchie de classe. Pour\nappeler la fonction de la classe m\xe8re alors qu'elle a \xe9t\xe9 red\xe9finie, il faut\npr\xe9ciser le nom de la classe \xe0 laquelle elle appartient avec l'op\xe9rateur de\nr\xe9solution de port\xe9e."}),"\n",(0,r.jsx)(s.p,{children:"Bien que simple, cette utilisation de la red\xe9finition des m\xe9thodes peut poser\ndes probl\xe8mes. Supposons qu'une classe B h\xe9rite de sa classe m\xe8re A. Si A\nposs\xe8de une m\xe9thode x appelant une autre m\xe9thode y red\xe9finie dans la classe\nfille B, que se passe-t-il lorsqu'un objet de classe B appelle la m\xe9thode x ? La\nm\xe9thode appel\xe9e \xe9tant celle de la classe A, elle appellera la m\xe9thode y de la\nclasse A. Par cons\xe9quent, la red\xe9finition de y ne sert \xe0 rien d\xe8s qu'on\nl'appelle \xe0 partir d'une des fonctions d'une des classes m\xe8res."}),"\n",(0,r.jsx)(s.p,{children:"Une premi\xe8re solution consisterait \xe0 red\xe9finir la m\xe9thode x dans la classe B.\nMais ce n'est ni \xe9l\xe9gant, ni efficace. Il faut en fait forcer le compilateur \xe0\nne pas faire le lien dans la fonction x de la classe A avec la fonction y de la\nclasse A. Il faut que x appelle soit la fonction y de la classe A si elle est\nappel\xe9e pour un objet de la classe B. Le lien avec l'une des m\xe9thodes y ne doit\n\xeatre fait qu'au moment de l'ex\xe9cution, c'est \xe0 dire qu'on doit faire une \xe9dition\nde liens dynamique."}),"\n",(0,r.jsxs)(s.p,{children:["Le C++ permet de faire cela. Pour cela, il suffit de d\xe9clarer virtuelle la\nfonction de la classe de base qui est red\xe9finie dans la classe fille, c'est \xe0\ndire la fonction y. Cela se fait en faisant pr\xe9c\xe9der par le mot cl\xe9 ",(0,r.jsx)(s.code,{children:"virtual"}),"\ndans la classe de base."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"#include <iostream>\n\nusing namespace std;\n\n// D\xe9finit la classe de base des donn\xe9es.\n\nclass DonneeBase\n{\nprotected:\n    int Numero;   // Les donn\xe9es sont num\xe9rot\xe9es.\n    int Valeur;   // et sont constitu\xe9es d'une valeur enti\xe8re\n                  // pour les donn\xe9es de base.\npublic:\n    void Entre(void);       // Entre une donn\xe9e.\n    void MiseAJour(void);   // Met \xe0 jour la donn\xe9e.\n};\n\nvoid DonneeBase::Entre(void)\n{\n    cin >> Numero;          // Entre le num\xe9ro de la donn\xe9e.\n    cout << endl;\n    cin >> Valeur;          // Entre sa valeur.\n    cout << endl;\n    return;\n}\n\nvoid DonneeBase::MiseAJour(void)\n{\n    Entre();                // Entre une nouvelle donn\xe9e\n                            // \xe0 la place de la donn\xe9e en cours.\n    return;\n}\n\n/* D\xe9finit la classe des donn\xe9es d\xe9taill\xe9es. */\n\nclass DonneeDetaillee : private DonneeBase\n{\n    int ValeurEtendue;      // Les donn\xe9es d\xe9taill\xe9es ont en plus\n                            // une valeur \xe9tendue.\n\npublic:\n    void Entre(void);       // Red\xe9finition de la m\xe9thode d'entr\xe9e.\n};\n\nvoid DonneeDetaillee::Entre(void)\n{\n    DonneeBase::Entre();    // Appelle la m\xe9thode de base.\n    cin >> ValeurEtendue;  // Entre la valeur \xe9tendue.\n    cout << endl;\n    return;\n}\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Si ",(0,r.jsx)(s.code,{children:"d"})," est un objet de la classe ",(0,r.jsx)(s.code,{children:"DonneDetaille"}),", l'appel de ",(0,r.jsx)(s.code,{children:"d.Entre"})," ne\ncausera pas de probl\xe8me. En revanche, l'appel de ",(0,r.jsx)(s.code,{children:"d.MiseAJour"})," ne fonctionnera\npar correctement, car la fonction ",(0,r.jsx)(s.code,{children:"Entre"})," appel\xe9e dans ",(0,r.jsx)(s.code,{children:"MiseAjour"})," est la\nfonction de la classe ",(0,r.jsx)(s.code,{children:"DonneeBase"}),", et non la fonction red\xe9finie dans\n",(0,r.jsx)(s.code,{children:"DonneeDetaille"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["Il fallait d\xe9clarer la fonction ",(0,r.jsx)(s.code,{children:"Entre"})," comme une fonction virtuelle. Il n'est\nn\xe9cessaire de le faire que dans la classe de base. Celle-ci doit donc \xeatre\nd\xe9clar\xe9e comme suit"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"class DonneeBase\n{\nprotected:\n    int Numero;\n    int Valeur;\n\npublic:\n    virtual void Entre(void);   // Fonction virtuelle.\n    void MiseAJour(void);\n};\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Cette fois, la fonction ",(0,r.jsx)(s.code,{children:"Entre"})," appel\xe9e dans ",(0,r.jsx)(s.code,{children:"MiseAJour"})," est soit la fonction de\nla classe ",(0,r.jsx)(s.code,{children:"DonneeBase"}),", si ",(0,r.jsx)(s.code,{children:"MiseAJour"})," est appel\xe9e pour un objet de classe\n",(0,r.jsx)(s.code,{children:"DonneeBase"}),", soit celle de la classe ",(0,r.jsx)(s.code,{children:"DonneeDetaille"})," si ",(0,r.jsx)(s.code,{children:"MiseAJour"})," est\nappel\xe9e pour un objet de la classe ",(0,r.jsx)(s.code,{children:"DonneeDetaillee"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["En r\xe9sum\xe9, les m\xe9thodes virtuelles sont des m\xe9thodes qui sont appel\xe9es selon la\nvraie classe de l'objet qui l'appelle. Les objets qui contiennent des m\xe9thodes\nvirtuelles peuvent \xeatre manipul\xe9s en tant qu'objets des classes de base, tout en\neffectuant les bonnes op\xe9rations en fonction de leur type. Ils apparaissent donc\ncomme \xe9tant des objets de la classe de base et des objets de leur classe\ncompl\xe8te indiff\xe9remment, et on peut les consid\xe9rer soit comme les uns, soit\ncomme les autres. Un tel comportement est appel\xe9 ",(0,r.jsx)(s.strong,{children:"polymorphisme"})," (c'est \xe0 dire\nqui peut avoir plusieurs aspects diff\xe9rents). Nous verrons une application du\npolymorphisme dans le cas des pointeurs sur les objets."]}),"\n",(0,r.jsx)(s.h2,{id:"d\xe9rivation",children:"D\xe9rivation"}),"\n",(0,r.jsx)(s.p,{children:"Nous allons voir ici les r\xe8gles de d\xe9rivation. Ces r\xe8gles permettent de savoir\nce qui est autoris\xe9 et ce qui ne l'est pas lorsqu'on travaille avec des classes\nde base et leurs classes filles (ou classes d\xe9riv\xe9es)."}),"\n",(0,r.jsx)(s.p,{children:"La premi\xe8re r\xe8gle, qui est aussi la plus simple, indique qu'il est possible\nd'utiliser un objet d'une classe d\xe9riv\xe9e partout o\xf9 l'on peut utiliser un objet\nde ses classes m\xe8res. Les m\xe9thodes et donn\xe9es des classes m\xe8res appartiennent en\neffet par h\xe9ritage aux classes filles. Bien entendu, on doit avoir les droit\nd'acc\xe8s sur les membres de la classe de base que l'on utilise."}),"\n",(0,r.jsx)(s.p,{children:"La deuxi\xe8me r\xe8gle indique qu'il est possible de faire une affectation d'une\nclasse d\xe9riv\xe9e vers une classes m\xe8re. Les donn\xe9es qui ne servent pas \xe0\nl'initialisation sont perdues, puisque la classe m\xe8re ne poss\xe8de pas les champs\ncorrespondants. En revanche, l'inverse est strictement interdit. En effet, les\ndonn\xe9es de la classe fille qui n'existent pas dans la classe m\xe8re ne pourraient\npas recevoir de valeur, et l'initialisation ne se ferait pas correctement."}),"\n",(0,r.jsxs)(s.p,{children:["Enfin la troisi\xe8me r\xe8gle dit que les pointeurs des classes d\xe9riv\xe9es sont\ncompatibles avec les pointeurs des classes m\xe8res. Cela signifie qu'il est\npossible d'affecter un pointeur de classe d\xe9riv\xe9e \xe0 un pointeur d'une de ses\nclasses de base. Il faut bien entendu que l'on ait en outre le droit d'acc\xe9der \xe0\nla classe de base, c'est \xe0 dire qu'au moins un de ses membres puisse \xeatre\nutilis\xe9. Cette condition n'est pas toujours v\xe9rifi\xe9e, en particulier pour les\nclasses de base dont l'h\xe9ritage est ",(0,r.jsx)(s.code,{children:"private"}),"."]}),"\n",(0,r.jsx)(s.p,{children:"Un objet d\xe9riv\xe9 point\xe9 par un pointeur d'une des classes m\xe8res de sa classe est\nconsid\xe9r\xe9 comme un objet de la classe du pointeur qui le pointe. Les donn\xe9es\nsp\xe9cifiques \xe0 sa classe ne sont pas supprim\xe9es, elles sont seulement\nmomentan\xe9ment inaccessibles. Cependant, le m\xe9canisme des m\xe9thodes virtuelles\ncontinue de fonctionner correctement. En particulier, le destructeur de la\nclasse de base doit \xeatre d\xe9clar\xe9 en tant que m\xe9thode virtuelle. Cela permet\nd'appeler le bon destructeur en cas de destruction de l'objet."}),"\n",(0,r.jsx)(s.p,{children:"Il est possible de convertir un pointeur de classe de base en un pointeur de\nclasse d\xe9riv\xe9e si la classe de base n'est pas virtuelle. Cependant, m\xeame lorsque\nla classe de base n'est pas virtuelle, cela est dangereux, car la classe d\xe9riv\xe9e\npeut avoir des membres qui ne sont pas pr\xe9sents dans la classe de base, et\nl'utilisation de ce pointeur peut conduire \xe0 des erreurs tr\xe8s graves. C'est pour\ncette raison qu'un transtypage est n\xe9cessaire pour ce type de conversion."}),"\n",(0,r.jsx)(s.p,{children:"Soient par exemple les deux classes d\xe9finies comme suit"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:'#include <iostream>\n\nusing namespace std;\n\nclass Mere\n{\npublic:\n    Mere(void);\n    ~Mere(void);\n};\n\nMere::Mere(void)\n{\n    cout << "Constructeur de la classe m\xe8re." << endl;\n    return;\n}\n\nMere::~Mere(void)\n{\n    cout << "Destructeur de la classe m\xe8re." << endl;\n    return;\n}\n\nclass Fille : public Mere\n{\npublic:\n    Fille(void);\n    ~Fille(void);\n};\n\nFille::Fille(void) : Mere()\n{\n    cout << "Constructeur de la classe fille." << endl;\n    return;\n}\n\nFille::~Fille(void)\n{\n    cout << "Destructeur de la classe fille." << endl;\n    return;\n}\n'})}),"\n",(0,r.jsx)(s.p,{children:"Avec ces d\xe9finitions, seule la premi\xe8re des deux affectations suivantes est\nautoris\xe9e"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"Mere m;   // Instanciation de deux objets.\nFille f;\n\nm=f;      // Cela est autoris\xe9, mais l'inverse ne le serait pas :\nf=m;      // ERREUR !! (ne compile pas)\n"})}),"\n",(0,r.jsx)(s.p,{children:"Les m\xeames r\xe8gles sont applicables pour les pointeurs d'objets"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"Mere *pm, m;\nFille *pf, f;\npf=&f;    // Autoris\xe9.\npm=pf;    // Autoris\xe9. Les donn\xe9es et les m\xe9thodes\n          // de la classe fille ne sont plus accessibles\n          // avec ce pointeur : *pm est un objet\n          // de la classe m\xe8re.\npf=&m;    // ILL\xc9GAL : il faut faire un transtypage :\npf=(Fille *) &m;  // Cette fois, c'est l\xe9gal, mais DANGEREUX !\n          // En effet, les m\xe9thodes de la classe filles\n          // ne sont pas d\xe9finies, puisque m est une classe m\xe8re.\n"})}),"\n",(0,r.jsx)(s.p,{children:"L'utilisation d'un pointeur sur la classe de base pour acc\xe9der \xe0 une classe\nd\xe9riv\xe9e n\xe9cessite d'utiliser des m\xe9thodes virtuelles. En particulier, il est\nn\xe9cessaire de rendre virtuels les destructeurs. Par exemple, avec la d\xe9finition\ndonn\xe9e ci-dessus pour les deux classes, le code suivant est faux :"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"Mere *pm;\nFille *pf = new Fille;\npm = pf;\ndelete pm; // Appel du destructeur de la classe m\xe8re !\n"})}),"\n",(0,r.jsx)(s.p,{children:"Pour r\xe9soudre le probl\xe8me, il faut que le destructeur de la classe m\xe8re soit\nvirtuel (il est inutile de d\xe9clarer virtuel le destructeur des classes filles)"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"class Mere\n{\npublic:\n    Mere(void);\n    virtual ~Mere(void);\n};\n"})}),"\n",(0,r.jsxs)(s.p,{children:["On notera que bien que l'op\xe9rateur ",(0,r.jsx)(s.code,{children:"delete"})," soit une fonction statique, le bon\ndestructeur est appel\xe9, car le destructeur est d\xe9clar\xe9 ",(0,r.jsx)(s.code,{children:"virtual"}),". En effet\nl'op\xe9rateur ",(0,r.jsx)(s.code,{children:"delete"})," recherche le destructeur \xe0 appeler dans la classe de\nl'objet le plus d\xe9riv\xe9. De plus, l'op\xe9rateur ",(0,r.jsx)(s.code,{children:"delete"})," restitue la m\xe9moire de\nl'objet complet, et pas seulement celle du sous-objet r\xe9f\xe9renc\xe9 par le pointeur\nutilis\xe9 dans l'expression ",(0,r.jsx)(s.code,{children:"delete"}),". Lorsqu'on utilise la d\xe9rivation, il est donc\ntr\xe8s important de d\xe9clarer les destructeurs virtuels pour que l'op\xe9rateur\n",(0,r.jsx)(s.code,{children:"delete"})," utilise le vrai type de l'objet \xe0 d\xe9truire."]}),"\n",(0,r.jsx)(s.h2,{id:"m\xe9thodes-virtuelles-pures---classes-abstraites",children:"M\xe9thodes virtuelles pures - Classes abstraites"}),"\n",(0,r.jsx)(s.p,{children:"Une m\xe9thode virtuelle pure est une m\xe9thode qui est d\xe9clar\xe9e mais non d\xe9finie\ndans une classe. Elle est d\xe9finie dans une des classes d\xe9riv\xe9es de cette classe."}),"\n",(0,r.jsx)(s.p,{children:"Une classe abstraite est une classe comportant au moins une m\xe9thode virtuelle\npure."}),"\n",(0,r.jsx)(s.p,{children:"\xc9tant donn\xe9 que les classes abstraites ont des m\xe9thodes non d\xe9finies, il est\nimpossible d'instancier des objets pour ces classes. En revanche, on pourra les\nr\xe9f\xe9rencer avec des pointeurs."}),"\n",(0,r.jsx)(s.p,{children:"Le m\xe9canisme des m\xe9thodes virtuelles pures et des classes abstraites permet de\ncr\xe9er des classes de base contenant toutes les caract\xe9ristiques d'un ensemble de\nclasses d\xe9riv\xe9es, pour pouvoir les manipuler avec un unique type de pointeur. En\neffet, les pointeurs des classes d\xe9riv\xe9es sont compatibles avec les pointeurs\ndes classes de base, on pourra donc r\xe9f\xe9rencer les classes d\xe9riv\xe9es avec des\npointeurs sur les classes de base, donc avec un unique type sous-jacent : celui\nde la classe de base. Cependant, les m\xe9thodes des classes d\xe9riv\xe9es doivent\nexister dans la classe de base pour pouvoir \xeatre accessibles \xe0 travers le\npointeur sur la classe de base. C'est ici que les m\xe9thodes virtuelles pures\napparaissent. Elles forment un moule pour les m\xe9thodes des classes d\xe9riv\xe9es, qui\nles d\xe9finissent. Bien entendu, il faut que ces m\xe9thodes soient d\xe9clar\xe9es\nvirtuelles, puisque l'acc\xe8s se fait avec un pointeur de classe de base et qu'il\nfaut que ce soit la m\xe9thode de la classe r\xe9elle de l'objet (c'est \xe0 dire la\nclasse d\xe9riv\xe9e) qui soit appel\xe9e."}),"\n",(0,r.jsxs)(s.p,{children:["Pour d\xe9clarer une m\xe9thode virtuelle pure dans une classe, il suffit de faire\nsuivre sa d\xe9claration de ",(0,r.jsx)(s.code,{children:"=0"}),". Le fonction doit \xe9galement \xeatre d\xe9clar\xe9e\nvirtuelle."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"virtual type nom(param\xe8tres) =0;\n"})}),"\n",(0,r.jsx)(s.p,{children:"Par exemple nous voulons cr\xe9er une structure de donn\xe9es pouvant contenir\nd'autres structures de donn\xe9es, quels que soient leurs types. Cette structure de\ndonn\xe9es est appel\xe9e un conteneur, parce qu'elle contient d'autres structures de\ndonn\xe9es. Il est possible de d\xe9finir diff\xe9rents types de conteneurs. Dans cet\nexemple, on ne s'int\xe9ressera qu'au conteneur de type sac."}),"\n",(0,r.jsx)(s.p,{children:"Un sac est un conteneur pouvant contenir z\xe9ro ou plusieurs objets, chaque objet\nn'\xe9tant pas forc\xe9ment unique. Un objet peut donc \xeatre plac\xe9 plusieurs fois dans\nle sac. Un sac dispose de deux fonctions permettant d'y mettre et d'en retirer\nun objet. Il a aussi une fonction permettant de dire si un objet se trouve dans\nle sac."}),"\n",(0,r.jsxs)(s.p,{children:["Nous allons d\xe9clarer une classe abstraite qui servira de classe de base pour\ntous les objets utilisables. Le sac ne manipulera que des pointeurs sur la\nclasse abstraite, ce qui permettra son utilisation pour toute classe d\xe9rivant de\ncette classe. Afin de diff\xe9rencier deux objets \xe9gaux, un num\xe9ro unique devra\n\xeatre distribu\xe9 \xe0 chaque objet manipul\xe9. Le choix de ce num\xe9ro est \xe0 la charge\ndes objets, la classe abstraite dont ils d\xe9rivent devra donc avoir une m\xe9thode\nrenvoyant ce num\xe9ro. Les objets devront tous pouvoir \xeatre affich\xe9s dans un\nformat qui leur est propre. La fonction \xe0 utiliser pour cela sera ",(0,r.jsx)(s.code,{children:"print"}),". Cette\nfonction sera une m\xe9thode virtuelle pure de la classe abstraite, puisqu'elle\ndevra \xeatre d\xe9finie pour chaque objet."]}),"\n",(0,r.jsx)(s.h2,{id:"pointeurs-sur-les-membres-dune-classe",children:"Pointeurs sur les membres d'une classe"}),"\n",(0,r.jsx)(s.p,{children:"Nous avons d\xe9j\xe0 vu les pointeurs sur les objets. Il nous reste \xe0 voir les\npointeurs sur les membres des classes."}),"\n",(0,r.jsx)(s.p,{children:"Les classes regroupent les caract\xe9ristiques des donn\xe9es et des fonctions des\nobjets. Les membres des classes ne peuvent donc pas \xeatre manipul\xe9s sans passer\npar la classe \xe0 laquelle ils appartiennent. Par cons\xe9quent, il faut, lorsqu'on\nveut faire un pointeur sur un membre, indiquer le nom de sa classe pour cela on\nutilise l'op\xe9rateur de port\xe9e."}),"\n",(0,r.jsx)(s.p,{children:"Une fois le pointeur d\xe9clar\xe9, on pourra l'initialiser en prenant l'adresse du\nmembre de la classe du type correspondant. Pour cela, il faudra encore sp\xe9cifier\nle nom de la classe avec l'op\xe9rateur de r\xe9solution de port\xe9e."})]})}function u(e={}){const{wrapper:s}={...(0,l.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);