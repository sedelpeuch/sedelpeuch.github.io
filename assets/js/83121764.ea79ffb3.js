"use strict";(self.webpackChunksedelpeuch_net=self.webpackChunksedelpeuch_net||[]).push([[7023],{64384:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"enseirb/s7/cpp/3","title":"La couche Objet - Partie 3 : op\xe9rateurs","description":"Ce cours pr\xe9sente les diff\xe9rents types d\'op\xe9rateurs en C++.","source":"@site/docs/enseirb/s7/cpp/3.md","sourceDirName":"enseirb/s7/cpp","slug":"/enseirb/s7/cpp/3","permalink":"/docs/enseirb/s7/cpp/3","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"La couche Objet - Partie 3 : op\xe9rateurs"},"sidebar":"tutorialSidebar","previous":{"title":"La couche objet - Partie 2 : Constructeur, Destructeurs, Pointeur this, Statique, Surcharge","permalink":"/docs/enseirb/s7/cpp/2"},"next":{"title":"La couche objet - Partie 4 : Les entr\xe9es/sorties, M\xe9thodes virtuelles, D\xe9rivation, Classe abstraites","permalink":"/docs/enseirb/s7/cpp/4"}}');var s=t(74848),a=t(28453);const i={title:"La couche Objet - Partie 3 : op\xe9rateurs"},l=void 0,o={},u=[{value:"Op\xe9rateurs d&#39;affectation",id:"op\xe9rateurs-daffectation",level:3},{value:"Op\xe9rateurs de transtypage",id:"op\xe9rateurs-de-transtypage",level:3},{value:"Op\xe9rateurs de comparaison",id:"op\xe9rateurs-de-comparaison",level:3},{value:"Op\xe9rateurs d&#39;incr\xe9mentation et de d\xe9cr\xe9mentation",id:"op\xe9rateurs-dincr\xe9mentation-et-de-d\xe9cr\xe9mentation",level:3},{value:"Op\xe9rateur fonctionnel",id:"op\xe9rateur-fonctionnel",level:3},{value:"Op\xe9rateurs d&#39;indirection et de d\xe9r\xe9f\xe9rencement",id:"op\xe9rateurs-dindirection-et-de-d\xe9r\xe9f\xe9rencement",level:3},{value:"Op\xe9rateurs d&#39;allocation dynamique de m\xe9moire",id:"op\xe9rateurs-dallocation-dynamique-de-m\xe9moire",level:3}];function d(e){const n={code:"code",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Ce cours pr\xe9sente les diff\xe9rents types d'op\xe9rateurs en C++."}),"\n",(0,s.jsx)(n.h3,{id:"op\xe9rateurs-daffectation",children:"Op\xe9rateurs d'affectation"}),"\n",(0,s.jsx)(n.p,{children:"Nous avons d\xe9j\xe0 vu un exemple d'op\xe9rateur d'affectation avec la classe complexe\nci-dessus. Cet op\xe9rateur \xe9tait tr\xe8s simple, mais ce n'est g\xe9n\xe9ralement pas\ntoujours le cas, et l'impl\xe9mentation des op\xe9rateurs d'affectation peut parfois\nsoulever quelques probl\xe8mes."}),"\n",(0,s.jsxs)(n.p,{children:["Premi\xe8rement, comme nous l'avons dit plus t\xf4t, le fait de d\xe9finir un op\xe9ration\nd'affectation signale souvent que la classe n'a pas une structure simple et que,\npar cons\xe9quent, le constructeur de copie et le destructeur fournis par d\xe9faut\npar le compilateur ne suffisent pas. Il faut donc veiller \xe0 respecter la r\xe8gle\ndes trois, qui stipule que si l'une de ces m\xe9thodes est red\xe9finie, il faut que\nles trois le soient. Par exemple, si vous ne red\xe9finissez pas le constructeur de\ncopie, les \xe9critures telles que ",(0,s.jsx)(n.code,{children:"classe object = source;"})," ne fonctionnement pas\ncorrectement. En effet, c'est le constructeur de copie qui est appel\xe9 ici, et\nnon l'op\xe9rateur d'affectation comme on pourrait le penser \xe0 premi\xe8re vue. De\nm\xeame, les traitements particuliers effectu\xe9s lors de la copie ou de\nl'initialisation d'un objet devront \xeatre effectu\xe9s en ordre inverse dans le\ndestructeur de l'objet. Les traitements de destruction consistent g\xe9n\xe9ralement \xe0\nlib\xe9rer la m\xe9moire et toutes les ressources allou\xe9es dynamiquement."]}),"\n",(0,s.jsx)(n.p,{children:"Lorsque l'on \xe9crit un op\xe9rateur d'affectation, on a g\xe9n\xe9ralement \xe0 reproduire, \xe0\npeu de choses pr\xe8s, le m\xeame code que celui qui se trouve dans le constructeur de\ncopie. Il arrive m\xeame parfois que l'on doive lib\xe9rer les ressources existantes\navant de faire l'affectation, et donc le code de l'op\xe9rateur d'affectation\nressemble souvent \xe0 la concat\xe9nation du code du destructeur et du code du\nconstructeur de copie. Bien entendu, cette duplication de code est g\xeanante et\npeu \xe9l\xe9gante. Une solution simple est d'impl\xe9menter une fonction de duplication\net une fonction de lib\xe9ration des donn\xe9es. Ces deux fonctions, par exemple reset\net clone, pourront \xeatre utilis\xe9es dans le destructeur, le constructeur de copie\net l'op\xe9rateur d'affectation. Le programme devient ainsi beaucoup plus simple.\nIl ne faut g\xe9n\xe9ralement pas utiliser l'op\xe9rateur d'affectation dans le\nconstructeur de copie, car cela peut poser des probl\xe8mes complexes \xe0 r\xe9soudre.\nPar exemple, il faut s'assurer que l'op\xe9rateur de copie ne cherche pas \xe0\nutiliser des donn\xe9es membres non initialis\xe9es lors de son appel."}),"\n",(0,s.jsx)(n.p,{children:"Un autre probl\xe8me important est celui de l'autoaffectation. Non seulement\naffecter un objet \xe0 lui-m\xeame est inutile et consommateur de ressources, mais en\nplus cela peut \xeatre dangereux. En effet, l'affectation risque de d\xe9truire les\ndonn\xe9es membres de l'objet avant m\xeame qu'elles ne soient copi\xe9es, ce qui\nprovoquerait en fin de compte simplement la destruction de l'objet ! Une\nsolution simple consiste ici \xe0 ajouter un test sur l'objet source en d\xe9but\nd'op\xe9rateur, comme dans l'exemple suivant"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"classe &classe::operator=(const classe &source)\n{\n    if (&source != this)\n    {\n        // Traitement de copie des donn\xe9es :\n        ...\n    }\n    return *this;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Enfin, la copie des donn\xe9es peut lancer une exception et laisser l'objet sur\nlequel l'affectation se fait dans un \xe9tat ind\xe9termin\xe9. La solution la plus\nsimple dans ce cas est encore de construire une copie de l'objet source en\nlocal, puis d'\xe9changer le contenu des donn\xe9es de l'objet avec cette copie.\nAinsi, si la copie \xe9choue pour une raison ou une autre, l'objet source n'est pas\nmodifi\xe9 et reste dans un \xe9tat stable. Le pseudo-code permettant de r\xe9aliser ceci\nest le suivant :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"classe &classe::operator=(const classe &source)\n{\n    // Construit une copie temporaire de la source :\n    class Temp(source);\n    // \xc9change le contenu de cette copie avec l'objet courant :\n    swap(Temp, *this);\n    // Renvoie l'objet courant (modifi\xe9) et d\xe9truit les donn\xe9es\n    // de la variable temporaire (contenant les anciennes donn\xe9es) :\n    return *this;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"op\xe9rateurs-de-transtypage",children:"Op\xe9rateurs de transtypage"}),"\n",(0,s.jsxs)(n.p,{children:["Nous avons vu pr\xe9c\xe9demment que les constructeurs peuvent \xeatre utilis\xe9s pour\nconvertir des objets du type de leur param\xe8tre vers le type de leur classe. Ces\nconversions peuvent avoir lieu de mani\xe8re implicite ou non, selon que le mot cl\xe9\n",(0,s.jsx)(n.code,{children:"explicit"})," est appliqu\xe9 au constructeur en question."]}),"\n",(0,s.jsx)(n.p,{children:"Cependant, il n'est pas toujours faisable d'\xe9crire un tel constructeur. Par\nexemple, la classe cible peut parfaitement \xeatre une des classes de la\nbiblioth\xe8que standard, dont on ne doit \xe9videmment pas modifier les fichiers\nsource, ou m\xeame un des types de base du langage, pour lequel il n'y a pas de\nd\xe9finition. Heureusement, les conversions peuvent malgr\xe9 tout \xeatre r\xe9alis\xe9es\ndans ce cas, simplement en surchargeant les op\xe9rateurs de transtypage."}),"\n",(0,s.jsxs)(n.p,{children:["Prenons l'exemple de la classe chaine, qui permet de faire des cha\xeenes de\ncaract\xe8res dynamiques (de longueur variable). Il est possible de les convertir\nen cha\xeene C classiques (c'est \xe0 dire en tableau de caract\xe8res) si l'op\xe9rateur\n(",(0,s.jsx)(n.code,{children:"char const *"}),") a \xe9t\xe9 surcharg\xe9"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"chaine::operator char const *(void) const;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["On constate que cet op\xe9rateur n'attend aucun param\xe8tre, puisqu'il s'applique \xe0\ntout l'objet qui l'appelle, mais surtout il n'a pas de type. En effet, puisque\nc'est un op\xe9rateur de transtypage, son type est n\xe9cessairement celui qui lui\ncorrespond (dans le cas pr\xe9sent, ",(0,s.jsx)(n.code,{children:"char const *"}),")."]}),"\n",(0,s.jsx)(n.h3,{id:"op\xe9rateurs-de-comparaison",children:"Op\xe9rateurs de comparaison"}),"\n",(0,s.jsx)(n.p,{children:"Les op\xe9rateurs de comparaison sont tr\xe8s simples \xe0 surcharger. La seule chose\nessentielle \xe0 retenir est qu'ils renvoient une valeur bool\xe9enne. Ainsi, pour la\nclasse chaine, on peut d\xe9clarer les op\xe9rateurs d'\xe9galit\xe9 et d'inf\xe9riorit\xe9 (dans\nl'ordre lexicographique par exemple) de deux cha\xeenes de caract\xe8res comme suit"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"bool chaine::operator==(const chaine &) const;\nbool chaine::operator<(const chaine &) const;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"op\xe9rateurs-dincr\xe9mentation-et-de-d\xe9cr\xe9mentation",children:"Op\xe9rateurs d'incr\xe9mentation et de d\xe9cr\xe9mentation"}),"\n",(0,s.jsxs)(n.p,{children:["Les op\xe9rateurs d'incr\xe9mentation et de d\xe9cr\xe9mentation sont tous les deux doubles,\nc'est \xe0 dire que la m\xeame notation repr\xe9sente deux op\xe9rateurs en r\xe9alit\xe9. En\neffet, ils n'ont pas la m\xeame signification, selon qu'ils sont plac\xe9s avant ou\napr\xe8s leur op\xe9rande. Le probl\xe8me est que comme ces op\xe9rateurs ne prennent pas de\nparam\xe8tres (ils ne travaillent que sur l'objet), il est impossible de les\ndiff\xe9rencier par surcharge. La solution qui a \xe9t\xe9 adopt\xe9e est de les\ndiff\xe9rencier en donnant un param\xe8tre fictif de type ",(0,s.jsx)(n.code,{children:"int"})," \xe0 l'un d'entre eux.\nAinsi les op\xe9rateurs ",(0,s.jsx)(n.code,{children:"++"})," et ",(0,s.jsx)(n.code,{children:"--"})," ne prennent pas de param\xe8tre lorsqu'il s'agit\ndes op\xe9rateurs pr\xe9fix\xe9s, et ont un argument fictif (que l'on ne doit pas\nutiliser) lorsqu'ils sont suffix\xe9s. Les versions pr\xe9fix\xe9es des op\xe9rateurs\ndoivent renvoyer une r\xe9f\xe9rence sur l'objet lui-m\xeame, les versions suffix\xe9es en\nrevanche peuvent se contenter de renvoyer la valeur de l'objet."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class Entier\n{\n    int i;\n\npublic:\n    Entier(int j)\n    {\n        i=j;\n        return;\n    }\n\n    Entier operator++(int)   // Op\xe9rateur suffixe :\n    {                        // retourne la valeur et incr\xe9mente\n        Entier tmp(i);       // la variable.\n        ++i;\n        return tmp;\n    }\n\n    Entier &operator++(void) // Op\xe9rateur pr\xe9fixe : incr\xe9mente\n    {                        // la variable et la retourne.\n        ++i;\n        return *this;\n    }\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"op\xe9rateur-fonctionnel",children:"Op\xe9rateur fonctionnel"}),"\n",(0,s.jsx)(n.p,{children:"L'op\xe9rateur d'appel de fonctions peut \xe9galement \xeatre surcharg\xe9. Cet op\xe9rateur\npermet de r\xe9aliser des objets qui se comportent comme des fonctions (ce que l'on\nappelle foncteurs). La biblioth\xe8que standard C++ en fait un usage intensif,\ncomme nous pourrons le constater dans la deuxi\xe8me partie de ce document."}),"\n",(0,s.jsx)(n.p,{children:"L'op\xe9rateur fonctionnel est \xe9galement tr\xe8s utilie en raison de son n-arit\xe9. Il\nest donc utilis\xe9 couramment pour les classes de gestion de matrices de nombres,\nafin d'autoriser l'\xe9criture matrice(i,j,k)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class matrice\n{\n    typedef double *ligne;\n    ligne *lignes;\n    unsigned short int n;   // Nombre de lignes (1er param\xe8tre).\n    unsigned short int m;   // Nombre de colonnes (2\xe8me param\xe8tre).\n\npublic:\n    matrice(unsigned short int nl, unsigned short int nc);\n    matrice(const matrice &source);\n    ~matrice(void);\n    matrice &operator=(const matrice &m1);\n    double &operator()(unsigned short int i, unsigned short int j);\n    double operator()(unsigned short int i, unsigned short int j) const;\n};\n\n// Le constructeur :\nmatrice::matrice(unsigned short int nl, unsigned short int nc)\n{\n    n = nl;\n    m = nc;\n    lignes = new ligne[n];\n    for (unsigned short int i=0; i<n; ++i)\n        lignes[i] = new double[m];\n    return;\n}\n\n// Le constructeur de copie :\nmatrice::matrice(const matrice &source)\n{\n    m = source.m;\n    n = source.n;\n    lignes = new ligne[n];   // Alloue.\n    for (unsigned short int i=0; i<n; ++i)\n    {\n        lignes[i] = new double[m];\n        for (unsigned short int j=0; j<m; ++j)  // Copie.\n            lignes[i][j] = source.lignes[i][j];\n    }\n    return;\n}\n\n// Le destructeur :\nmatrice::~matrice(void)\n{\n    for (unsigned short int i=0; i<n; ++i)\n        delete[] lignes[i];\n    delete[] lignes;\n    return;\n}\n\n// L'op\xe9rateur d'affectation :\nmatrice &matrice::operator=(const matrice &source)\n{\n    if (&source != this)\n    {\n        if (source.n!=n || source.m!=m)   // V\xe9rifie les dimensions.\n        {\n            for (unsigned short int i=0; i<n; ++i)\n                delete[] lignes[i];\n            delete[] lignes;              // D\xe9truit...\n            m = source.m;\n            n = source.n;\n            lignes = new ligne[n];        // et r\xe9alloue.\n            for (i=0; i<n; ++i) lignes[i] = new double[m];\n        }\n        for (unsigned short int i=0; i<n; ++i) // Copie.\n            for (unsigned short int j=0; j<m; ++j)\n                lignes[i][j] = source.lignes[i][j];\n    }\n    return *this;\n}\n\n// Op\xe9rateurs d'acc\xe8s :\ndouble &matrice::operator()(unsigned short int i,\n    unsigned short int j)\n{\n    return lignes[i][j];\n}\n\ndouble matrice::operator()(unsigned short int i,\n    unsigned short int j) const\n{\n    return lignes[i][j];\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Ainsi, on pourra effectuer la d\xe9claration d'une matrice avec ",(0,s.jsx)(n.code,{children:"matrice m(2,3);"}),"\net acc\xe9der \xe0 ses \xe9l\xe9ments simplement avec ",(0,s.jsx)(n.code,{children:"m(i,j)=6;"}),". On remarquera que l'on a\nd\xe9fini deux op\xe9rateurs fonctionnels dans l'exemple donn\xe9 ci-dessus. Le premier\nrenvoie une r\xe9f\xe9rence et permet de modifier la valeur d'un des \xe9l\xe9ments de la\nmatrice. Cet op\xe9rateur ne peut bien entendu pas s'appliquer \xe0 une matrice\nconstante, m\xeame simplement pour lire un \xe9l\xe9ment. C'est donc le deuxi\xe8me\nop\xe9rateur qui sera utilis\xe9 pour lire les \xe9l\xe9ments des matrices constantes, car\nil renvoie une valeur et non plus une r\xe9f\xe9rence. Le choix de l'op\xe9rateur \xe0\nutiliser est d\xe9termin\xe9 par la pr\xe9sence du mot cl\xe9 ",(0,s.jsx)(n.code,{children:"const"}),", qui indique que seul\ncet op\xe9rateur peut \xeatre utilis\xe9 pour une matrice constante."]}),"\n",(0,s.jsx)(n.h3,{id:"op\xe9rateurs-dindirection-et-de-d\xe9r\xe9f\xe9rencement",children:"Op\xe9rateurs d'indirection et de d\xe9r\xe9f\xe9rencement"}),"\n",(0,s.jsx)(n.p,{children:"L'op\xe9rateur de d\xe9r\xe9f\xe9rencement * permet l'\xe9criture de classes dont les objets peuvent \xeatre utilis\xe9s dans des expressions manipulant des pointeurs. L'op\xe9rateur d'indirection & quant \xe0 lui, permet de renvoyer une adresse autre que celle de l'objet sur lequel il s'applique. Enfin, l'op\xe9rateur de d\xe9r\xe9f\xe9rencement et de s\xe9lection de membres de structures -> permet de r\xe9aliser des classes qui encapsulent d'autres classes."}),"\n",(0,s.jsx)(n.p,{children:"Si les op\xe9rateurs de d\xe9r\xe9f\xe9rencement et d'indirection & et * peuvent renvoyer\nune valeur de type quelconque, ce n'est pas le cas de l'op\xe9rateur de\nd\xe9r\xe9f\xe9rencement et de s\xe9lection de membre ->. Cet op\xe9rateur doit n\xe9cessairement\nrenvoyer un type pour lequel il doit encore \xeatre applicable. Ce type doit donc\nsoit surcharger l'op\xe9rateur ->, soit \xeatre un pointeur sur une structure, union\nou classe."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Cette classe est encapsul\xe9e par une autre classe :\nstruct Encapsulee\n{\n    int i;       // Donn\xe9e \xe0 acc\xe9der.\n};\n\nEncapsulee o;    // Objet \xe0 manipuler.\n\n// Cette classe est la classe encapsulante :\nstruct Encapsulante\n{\n    Encapsulee *operator->(void) const\n    {\n        return &o;\n    }\n\n    Encapsulee *operator&(void) const\n    {\n        return &o;\n    }\n\n    Encapsulee &operator*(void) const\n    {\n        return o;\n    }\n};\n\n// Exemple d'utilisation :\nvoid f(int i)\n{\n    Encapsulante e;\n    e->i=2;         // Enregistre 2 dans o.i.\n    (*e).i = 3;     // Enregistre 3 dans o.i.\n    Encapsulee *p = &e;\n    p->i = 4;       // Enregistre 4 dans o.i.\n    return ;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"op\xe9rateurs-dallocation-dynamique-de-m\xe9moire",children:"Op\xe9rateurs d'allocation dynamique de m\xe9moire"}),"\n",(0,s.jsx)(n.p,{children:"Les op\xe9rateurs les plus difficiles \xe0 \xe9crire sont sans doute les op\xe9rateurs d'allocation dynamique de m\xe9moire. Ces op\xe9rateurs prennent un nombre variable de param\xe8tres, parce qu'ils sont compl\xe8tement surchargeables (c'est \xe0 dire qu'il est possible de d\xe9finir plusieurs surcharges de ces op\xe9rateurs m\xeame au sein d'une m\xeame classe, s'ils sont d\xe9finis de mani\xe8re interne). Il est donc possible de d\xe9finir plusieurs op\xe9rateurs new ou new[], et plusieurs op\xe9rateurs delete ou delete[]. Cependant, les premiers param\xe8tres de ces op\xe9rateurs doivent toujours \xeatre la taille de la zone de la m\xe9moire \xe0 allouer dans le cas des op\xe9rateurs new et new[], et le pointeur sur la zone de la m\xe9moire \xe0 restituer dans le cas des op\xe9rateurs delete et delete[]."}),"\n",(0,s.jsx)(n.p,{children:"La forme la plus simple de new ne prend qu'un param\xe8tre : le nombre d'octets \xe0 allouer, qui vaut toujours la taille de l'objet \xe0 construire. Il doit renvoyer un pointeur du type void. L'op\xe9rateur delete correspondant peut prendre, quant \xe0 lui, soit un, soit deux param\xe8tres. Comme on l'a d\xe9j\xe0 dit, le premier param\xe8tre est toujours un pointeur du type void sur l'objet \xe0 d\xe9truire. Le deuxi\xe8me param\xe8tre, s'il existe, est du type size_t et contient la taille de l'objet \xe0 d\xe9truire. Les m\xeames r\xe8gles s'appliquent pour les op\xe9rateurs new[] et delete[], utilis\xe9s pour les tableaux."}),"\n",(0,s.jsx)(n.p,{children:"Lorsque les op\xe9rateurs delete et delete[] prennent deux param\xe8tres, le deuxi\xe8me param\xe8tre est la taille de la zone de la m\xe9moire \xe0 restituer. Cela signifie que le compilateur se charge de m\xe9moriser cette information. Pour les op\xe9rateurs new et delete, cela ne cause pas de probl\xe8me, puisque la taille de cette zone est fix\xe9e par le type de l'objet. En revanche, pour les tableaux, la taille du tableau doit \xeatre stock\xe9e avec le tableau. En g\xe9n\xe9ral, le compilateur utilise un en-t\xeate devant le tableau d'objets. C'est pour cela que la taille \xe0 allouer pass\xe9e \xe0 new[], qui est la m\xeame que la taille \xe0 d\xe9sallouer pass\xe9e en param\xe8tre \xe0 delete[], n'est pas \xe9gale \xe0 la taille d'un objet multipli\xe9e par le nombre d'objets du tableau. Le compilateur demande un peu plus de m\xe9moire, pour m\xe9moriser la taille du tableau. On ne peut donc pas, dans ce cas, faire d'hypoth\xe8ses quant \xe0 la structure que le compilateur donnera \xe0 la m\xe9moire allou\xe9e pour stocker le tableau."}),"\n",(0,s.jsx)(n.p,{children:"En revanche, si delete[] ne prend en param\xe8tre que le pointeur sur le tableau,\nla m\xe9morisation de la taille du tableau est \xe0 la charge du programmeur. Dans ce\ncas, le compilateur donne \xe0 new[] la valeur exacte de la taille du tableau, \xe0\nsavoir la taille d'un objet multipli\xe9e par le nombre d'objets dans le tableau."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <stdio.h>\n\nint buffer[256];     // Buffer servant \xe0 stocker le tableau.\n\nclass Temp\n{\n    char i[13];      // sizeof(Temp) doit \xeatre premier.\n\npublic:\n    static void *operator new[](size_t taille)\n    {\n       return buffer;\n    }\n\n    static void operator delete[](void *p, size_t taille)\n    {\n       printf("Taille de l\'en-t\xeate : %d\\n",\n           taille-(taille/sizeof(Temp))*sizeof(Temp));\n       return ;\n    }\n};\n\nint main(void)\n{\n    delete[] new Temp[1];\n    return 0;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Il est \xe0 noter qu'aucun des op\xe9rateurs new, delete, new[] et delete[] ne re\xe7oit le pointeur this en param\xe8tre : ce sont des op\xe9rateurs statiques. Cela est normal puisque, lorsqu'ils s'ex\xe9cutent, soit l'objet n'est pas encore cr\xe9\xe9, soit il est d\xe9j\xe0 d\xe9truit. Le pointeur this n'existe donc pas encore (ou n'est plus valide) lors de l'appel de ces op\xe9rateurs."}),"\n",(0,s.jsx)(n.p,{children:"Les op\xe9rateurs new et new[] peuvent avoir une forme encore un peu plus compliqu\xe9e, qui permet de leur passer des param\xe8tres lors de l'allocation de la m\xe9moire. Les param\xe8tres suppl\xe9mentaires doivent imp\xe9rativement \xeatre les param\xe8tres deux et suivants, puisque le premier param\xe8tre indique toujours la taille de la zone de m\xe9moire \xe0 allouer."}),"\n",(0,s.jsx)(n.p,{children:"Comme le premier param\xe8tre est calcul\xe9 par le compilateur, il n'y a pas de syntaxe permettant de le passer aux op\xe9rateurs new et new[]. En revanche, une syntaxe sp\xe9ciale est n\xe9cessaire pour passer les param\xe8tres suppl\xe9mentaires. Cette syntaxe est d\xe9taill\xe9e ci-dessous."}),"\n",(0,s.jsx)(n.p,{children:"Si l'op\xe9rateur new est d\xe9clar\xe9 de la mani\xe8re suivante dans la classe classe :"}),"\n",(0,s.jsx)(n.p,{children:"static void *operator new(size_t taille, param\xe8tres);"}),"\n",(0,s.jsxs)(n.p,{children:["o\xf9 taille est la taille de la zone de m\xe9moire \xe0 allouer et param\xe8tres la liste\ndes param\xe8tres additionnels, alors on doit l'appeler avec la syntaxe\n",(0,s.jsx)(n.code,{children:"new(param\xe8tres classes);"})]}),"\n",(0,s.jsx)(n.p,{children:"Les param\xe8tres sont donc pass\xe9s entre parenth\xe8ses comme pour une fonction normale. Le nom de la fonction est new, et le nom de la classe suit l'expression new comme dans la syntaxe sans param\xe8tres. Cette utilisation de new est appel\xe9e new avec placement."}),"\n",(0,s.jsx)(n.p,{children:"Le placement est souvent utilis\xe9 afin de r\xe9aliser des r\xe9allocations de m\xe9moire d'un objet \xe0 un autre. Par exemple, si l'on doit d\xe9truire un objet allou\xe9 dynamiquement et en reconstruire imm\xe9diatement un autre du m\xeame type, les op\xe9rations suivantes se d\xe9roulent :"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"appel du destructeur de l'objet (r\xe9alis\xe9 par l'expression delete) ;"}),"\n",(0,s.jsx)(n.li,{children:"appel de l'op\xe9rateur delete ;"}),"\n",(0,s.jsx)(n.li,{children:"appel de l'op\xe9rateur new ;"}),"\n",(0,s.jsx)(n.li,{children:"appel du constructeur du nouvel objet (r\xe9alis\xe9 par l'expression new)."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Cela n'est pas tr\xe8s efficace, puisque la m\xe9moire est restitu\xe9e pour \xeatre allou\xe9e de nouveau imm\xe9diatement apr\xe8s. Il est beaucoup plus logique de r\xe9utiliser la m\xe9moire de l'objet \xe0 d\xe9truire pour le nouvel objet, et de reconstruire ce dernier dans cette m\xe9moire. Cela peut se faire comme suit :"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"appel explicite du destructeur de l'objet \xe0 d\xe9truire ;"}),"\n",(0,s.jsx)(n.li,{children:"appel de new avec comme param\xe8tre suppl\xe9mentaire le pointeur sur l'objet d\xe9truit ;"}),"\n",(0,s.jsx)(n.li,{children:"appel du constructeur du deuxi\xe8me objet (r\xe9alis\xe9 par l'expression new)."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"L'appel de new ne fait alors aucune allocation : on gagne ainsi beaucoup de\ntemps."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"#include <stdlib.h>\n\nclass A\n{\npublic:\n    A(void)           // Constructeur.\n    {\n        return ;\n    }\n\n    ~A(void)          // Destructeur.\n    {\n        return ;\n    }\n\n    // L'op\xe9rateur new suivant utilise le placement.\n    // Il re\xe7oit en param\xe8tre le pointeur sur le bloc\n    // \xe0 utiliser pour la requ\xeate d'allocation dynamique\n    // de m\xe9moire.\n    static void *operator new (size_t taille, A *bloc)\n    {\n        return (void *) bloc;\n    }\n\n    // Op\xe9rateur new normal :\n    static void *operator new(size_t taille)\n    {\n        // Impl\xe9mentation :\n        return malloc(taille);\n    }\n\n    // Op\xe9rateur delete normal :\n    static void operator delete(void *pBlock)\n    {\n        free(pBlock);\n        return ;\n    }\n};\n\nint main(void)\n{\n    A *pA=new A;      // Cr\xe9ation d'un objet de classe A.\n                      // L'op\xe9rateur new global du C++ est utilis\xe9.\n    pA->~A();         // Appel explicite du destructeur de A.\n    A *pB=new(pA) A;  // R\xe9utilisation de la m\xe9moire de A.\n    delete pB;        // Destruction de l'objet.\n    return 0;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Dans cet exemple, la gestion de la m\xe9moire est r\xe9alis\xe9e par les op\xe9rateurs new\net delete normaux. Cependant, la r\xe9utilisation de la m\xe9moire allou\xe9e se fait\ngr\xe2ce \xe0 un op\xe9rateur new avec placement, d\xe9fini pour l'occasion. Ce dernier ne\nfait strictement rien d'autre que de renvoyer le pointeur qu'on lui a pass\xe9 en\nparam\xe8tre. On notera qu'il est n\xe9cessaire d'appeler explicitement le destructeur\nde la classe A avant de r\xe9utiliser la m\xe9moire de l'objet, car aucune expression\ndelete ne s'en charge avant la r\xe9utilisation de la m\xe9moire."}),"\n",(0,s.jsx)(n.p,{children:"Il est impossible de passer des param\xe8tres \xe0 l'op\xe9rateur delete dans une\nexpression delete. Cela est d\xfb au fait qu'en g\xe9n\xe9ral on ne conna\xeet pas le\ncontexte de la destruction d'un objet (alors qu'\xe0 l'allocation, on conna\xeet le\ncontexte de cr\xe9ation de l'objet). Normalement, il ne peut donc y avoir qu'un\nseul op\xe9rateur delete. Cependant, il existe un cas o\xf9 l'on conna\xeet le contexte\nde l'appel de l'op\xe9rateur delete : c'est le cas o\xf9 le constructeur de la classe\nlance une exception (voir le Chapitre 9 pour plus de d\xe9tails \xe0 ce sujet). Dans\nce cas, la m\xe9moire allou\xe9e par l'op\xe9rateur new doit \xeatre restitu\xe9e et\nl'op\xe9rateur delete est automatiquement appel\xe9, puisque l'objet n'a pas pu \xeatre\nconstruit. Afin d'obtenir un comportement sym\xe9trique, il est permis de donner\ndes param\xe8tres additionnels \xe0 l'op\xe9rateur delete. Lorsqu'une exception est\nlanc\xe9e dans le constructeur de l'objet allou\xe9, l'op\xe9rateur delete appel\xe9 est\nl'op\xe9rateur dont la liste des param\xe8tres correspond \xe0 celle de l'op\xe9rateur new\nqui a \xe9t\xe9 utilis\xe9 pour cr\xe9er l'objet. Les param\xe8tres pass\xe9s \xe0 l'op\xe9rateur delete\nprennent alors exactement les m\xeames valeurs que celles qui ont \xe9t\xe9 donn\xe9es aux\nparam\xe8tres de l'op\xe9rateur new lors de l'allocation de la m\xe9moire de l'objet.\nAinsi, si l'op\xe9rateur new a \xe9t\xe9 utilis\xe9 sans placement, l'op\xe9rateur delete sans\nplacement sera appel\xe9. En revanche, si l'op\xe9rateur new a \xe9t\xe9 appel\xe9 avec des\nparam\xe8tres, l'op\xe9rateur delete qui a les m\xeames param\xe8tres sera appel\xe9. Si aucun\nop\xe9rateur delete ne correspond, aucun op\xe9rateur delete n'est appel\xe9 (si\nl'op\xe9rateur new n'a pas allou\xe9 de m\xe9moire, cela n'est pas grave, en revanche, si\nde la m\xe9moire a \xe9t\xe9 allou\xe9e, elle ne sera pas restitu\xe9e). Il est donc important\nde d\xe9finir un op\xe9rateur delete avec placement pour chaque op\xe9rateur new avec\nplacement d\xe9fini. L'exemple pr\xe9c\xe9dent doit donc \xeatre r\xe9\xe9crit de la mani\xe8re\nsuivante :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"#include <stdlib.h>\n\nstatic bool bThrow = false;\n\nclass A\n{\npublic:\n    A(void)           // Constructeur.\n    {\n        // Le constructeur est susceptible\n        // de lancer une exception :\n if (bThrow) throw 2;\n        return ;\n    }\n\n    ~A(void)          // Destructeur.\n    {\n        return ;\n    }\n\n    // L'op\xe9rateur new suivant utilise le placement.\n    // Il re\xe7oit en param\xe8tre le pointeur sur le bloc\n    // \xe0 utiliser pour la requ\xeate d'allocation dynamique\n    // de m\xe9moire.\n    static void *operator new (size_t taille, A *bloc)\n    {\n        return (void *) bloc;\n    }\n\n    // L'op\xe9rateur delete suivant est utilis\xe9 dans les expressions\n    // qui utilisent l'op\xe9rateur new avec placement ci-dessus,\n    // si une exception se produit dans le constructeur.\n    static void operator delete(void *p, A *bloc)\n    {\n        // On ne fait rien, parce que l'op\xe9rateur new correspondant\n        // n'a pas allou\xe9 de m\xe9moire.\n        return ;\n    }\n\n    // Op\xe9rateur new et delete normaux :\n    static void *operator new(size_t taille)\n    {\n        return malloc(taille);\n    }\n\n    static void operator delete(void *pBlock)\n    {\n        free(pBlock);\n        return ;\n    }\n};\n\nint main(void)\n{\n    A *pA=new A;      // Cr\xe9ation d'un objet de classe A.\n    pA->~A();         // Appel explicite du destructeur de A.\n    bThrow = true;    // Maintenant, le constructeur de A lance\n                      // une exception.\n    try\n    {\n        A *pB=new(pA) A;  // R\xe9utilisation de la m\xe9moire de A.\n                          // Si une exception a lieu, l'op\xe9rateur\n                          // delete(void *, A *) avec placement\n                          // est utilis\xe9.\n        delete pB;        // Destruction de l'objet.\n    }\n    catch (...)\n    {\n        // L'op\xe9rateur delete(void *, A *) ne lib\xe8re pas la m\xe9moire\n        // allou\xe9e lors du premier new. Il faut donc quand m\xeame\n        // le faire, mais sans delete, car l'objet point\xe9 par pA\n        // est d\xe9j\xe0 d\xe9truit, et celui point\xe9 par pB l'a \xe9t\xe9 par\n        // l'op\xe9rateur delete(void *, A *) :\n        free(pA);\n    }\n    return 0;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Quelle que soit la syntaxe que vous d\xe9sirez utiliser, les op\xe9rateurs new, new[], delete et delete[] doivent avoir un comportement bien d\xe9termin\xe9. En particulier, les op\xe9rateurs delete et delete[] doivent pouvoir accepter un pointeur nul en param\xe8tre. Lorsqu'un tel pointeur est utilis\xe9 dans une expression delete, aucun traitement ne doit \xeatre fait."})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var r=t(96540);const s={},a=r.createContext(s);function i(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);