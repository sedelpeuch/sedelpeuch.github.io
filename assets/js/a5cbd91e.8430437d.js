"use strict";(self.webpackChunksedelpeuch_net=self.webpackChunksedelpeuch_net||[]).push([[6097],{3844(e,s,n){n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>c,default:()=>a,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"enseirb/s7/prog_sys/4","title":"La biblioth\xe8que standard","description":"Les descripteurs de fichiers","source":"@site/docs/enseirb/s7/prog_sys/4.md","sourceDirName":"enseirb/s7/prog_sys","slug":"/enseirb/s7/prog_sys/4","permalink":"/docs/enseirb/s7/prog_sys/4","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"La biblioth\xe8que standard"},"sidebar":"tutorialSidebar","previous":{"title":"Le Buffer Cache","permalink":"/docs/enseirb/s7/prog_sys/3"},"next":{"title":"Appels syst\xe8me du Syst\xe8me de Gestion de Fichier","permalink":"/docs/enseirb/s7/prog_sys/5"}}');var t=n(74848),i=n(28453);const o={title:"La biblioth\xe8que standard"},c=void 0,d={},l=[{value:"Les descripteurs de fichiers",id:"les-descripteurs-de-fichiers",level:2}];function u(e){const s={code:"code",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h2,{id:"les-descripteurs-de-fichiers",children:"Les descripteurs de fichiers"}),"\n",(0,t.jsxs)(s.p,{children:["Le fichier d'inclusion ",(0,t.jsx)(s.code,{children:"<stdio.h>"})," contient la d\xe9finition du type ",(0,t.jsx)(s.code,{children:"FILE"}),". Ce\ntype est une structure contenant les informations n\xe9cessaires au syst\xe8me pour la\nmanipulation d'un fichier ouvert. Le contenu exact de cette structure peut\nvarier d'un syst\xe8me \xe0 l'autre. Toutes les fonctions d'entr\xe9es sorties utilisent\nen premier argument un pointeur sur une telle structure ",(0,t.jsx)(s.code,{children:"FILE *"}),". Le r\xf4le de cet\nargument est d'indiquer le flux sur lequel on doit effectuer l'op\xe9ration\nd'\xe9criture ou de lecture. Pour pouvoir utiliser une fonction d'entr\xe9e sortie il\nfaut donc avoir une valeur pour ce premier argument, c'est le r\xf4le de la\nfonction ",(0,t.jsx)(s.code,{children:"fopen"})," de nous fournir ce pointeur en ouvrant le fichier. Les deux\nfonctions ",(0,t.jsx)(s.code,{children:"printf"})," et ",(0,t.jsx)(s.code,{children:"scanf"})," sont des synonymes de ",(0,t.jsx)(s.code,{children:"fprintf(stdout, format, ...)"})," et ",(0,t.jsx)(s.code,{children:"fscanf(stdin,format, ...)"}),". O\xf9 ",(0,t.jsx)(s.code,{children:"stdout"})," et ",(0,t.jsx)(s.code,{children:"stdin"})," sont des\nexpressions de type ",(0,t.jsx)(s.code,{children:"FILE *"})," d\xe9finies sous forme de macro-d\xe9finitions dans le\nfichier ",(0,t.jsx)(s.code,{children:"<stdio.h>"}),". Avec POSIX ce sont effectivement des fonctions. sur les\nsyst\xe8mes de la famille UNIX les fichiers ouverts par un processus le restent\ndans ses fils. Par exemple le shell a en g\xe9n\xe9ral trois flux standards :"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"stdin"})," le terminal ouvert en lecture"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"stdout"})," le terminal ouvert en \xe9criture"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"stderr"})," le terminal ouvert en \xe9criture, et en mode non bufferis\xe9"]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Ainsi si l'ex\xe9cution d'un programme C est r\xe9alis\xe9e \xe0 partir du shell le\nprogramme C a d\xe9j\xe0 ces trois descripteurs de fichiers utilisables."})]})}function a(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},28453(e,s,n){n.d(s,{R:()=>o,x:()=>c});var r=n(96540);const t={},i=r.createContext(t);function o(e){const s=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(i.Provider,{value:s},e.children)}}}]);