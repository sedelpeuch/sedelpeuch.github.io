"use strict";(self.webpackChunksedelpeuch_net=self.webpackChunksedelpeuch_net||[]).push([[54],{75848:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>o});var t=s(17624),i=s(4552);const r={title:"Les threads POSIX"},a=void 0,l={id:"enseirb/s7/prog_sys/14",title:"Les threads POSIX",description:"La programmation par thread (activit\xe9) est naturelle pour g\xe9rer des ph\xe9nom\xe8nes",source:"@site/docs/enseirb/s7/prog_sys/14.md",sourceDirName:"enseirb/s7/prog_sys",slug:"/enseirb/s7/prog_sys/14",permalink:"/docs/enseirb/s7/prog_sys/14",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Les threads POSIX"},sidebar:"tutorialSidebar",previous:{title:"Multiplexer des entr\xe9es-sorties",permalink:"/docs/enseirb/s7/prog_sys/13"},next:{title:"Syst\xe8me de Gestion de Fichiers",permalink:"/docs/enseirb/s7/prog_sys/2"}},d={},o=[{value:"Description",id:"description",level:3},{value:"<code>fork</code> et <code>exec</code>",id:"fork-et-exec",level:3},{value:"<code>clone</code>",id:"clone",level:3},{value:"Les noms de fonctions",id:"les-noms-de-fonctions",level:3},{value:"Les noms de types",id:"les-noms-de-types",level:3},{value:"Attributs d&#39;une activit\xe9",id:"attributs-dune-activit\xe9",level:3},{value:"Cr\xe9ation et terminaison des activit\xe9s",id:"cr\xe9ation-et-terminaison-des-activit\xe9s",level:3},{value:"Cr\xe9ation",id:"cr\xe9ation",level:4},{value:"Terminaison",id:"terminaison",level:4},{value:"Synchronisation",id:"synchronisation",level:2},{value:"Le mod\xe8le fork/join (Paterson)",id:"le-mod\xe8le-forkjoin-paterson",level:3},{value:"Le probl\xe8me de l&#39;exclusion mutuelle sur les variables g\xe9r\xe9es par le noyau",id:"le-probl\xe8me-de-lexclusion-mutuelle-sur-les-variables-g\xe9r\xe9es-par-le-noyau",level:3},{value:"Les s\xe9maphores d&#39;exclusion mutuelle",id:"les-s\xe9maphores-dexclusion-mutuelle",level:3},{value:"Utilisation des s\xe9maphores",id:"utilisation-des-s\xe9maphores",level:3},{value:"Les conditions (\xe9v\xe8nements)",id:"les-conditions-\xe9v\xe8nements",level:3},{value:"Ordonnancement des activit\xe9s",id:"ordonnancement-des-activit\xe9s",level:2},{value:"L&#39;ordonnancement POSIX des activit\xe9s",id:"lordonnancement-posix-des-activit\xe9s",level:3},{value:"Les variables sp\xe9cifiques \xe0 une thread",id:"les-variables-sp\xe9cifiques-\xe0-une-thread",level:3},{value:"Principe g\xe9n\xe9ral des donn\xe9es sp\xe9cifiques, POSIX",id:"principe-g\xe9n\xe9ral-des-donn\xe9es-sp\xe9cifiques-posix",level:3},{value:"Cr\xe9ation de cl\xe9s",id:"cr\xe9ation-de-cl\xe9s",level:3},{value:"Lecture / \xe9criture d&#39;une variable sp\xe9cifique",id:"lecture--\xe9criture-dune-variable-sp\xe9cifique",level:3},{value:"Les fonctions standardes utilisant des zones statiques",id:"les-fonctions-standardes-utilisant-des-zones-statiques",level:2}];function c(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.M)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"La programmation par thread (activit\xe9) est naturelle pour g\xe9rer des ph\xe9nom\xe8nes\nasynchrones. Les entr\xe9es utilisateur dans les interfaces graphiques (souris,\nclavier) sont plus facile \xe0 g\xe9rer si l'on peut s\xe9parer l'activit\xe9 principale du\nlogiciel de la gestion des commandes utilisateurs. Les entr\xe9es sorites multiples\nsont g\xe9r\xe9es plus simplement en utilisant des threads."}),"\n",(0,t.jsx)(n.p,{children:"Les activit\xe9s sont une nouvelle fa\xe7on de voire les processus dans un syst\xe8me.\nL'id\xe9e est de s\xe9parer en deux le concept de processus. La premi\xe8re partie est\nl'environnement d'ex\xe9cution, on y retrouve une tr\xe8s grande partie des \xe9l\xe9ments\nconstitutifs d'un processus en particulier les informations sur le propri\xe9taire,\nla position dans l'arborescence le masque de cr\xe9ation de fichier etc. La\ndeuxi\xe8me partie est l'activit\xe9, c'est la partie dynamique, elle contient une\npile, un context processeur (pointeur d'instruction etc), et des donn\xe9es\nd'ordonancement."}),"\n",(0,t.jsx)(n.p,{children:"L'id\xe9e de ce d\xe9coupage est de pouvoir associer plusieurs activit\xe9 au m\xeame\nenvironnement d'ex\xe9cution. L'organisation en m\xe9moire pour un processus UNIX avec\nplusieurs threads est disponible dans la figure ci dessous"}),"\n",(0,t.jsx)("center",{children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:s(73440).c+"",width:"646",height:"874"})})}),"\n",(0,t.jsx)(n.p,{children:"On peut gr\xe2ce au thread g\xe9rer plusieurs ph\xe9nom\xe8nes asynchrone dans le m\xeame\ncontexte, c'est \xe0 dire, un espace d'adressage commun, ce qui est plus confortable\nque de la m\xe9moire partag\xe9e et moins co\xfbteux en ressource que plusieurs processus\navec un segment de m\xe9moire partag\xe9. Un processus correspond \xe0 une instance d'un\nprogramme en cours d'ex\xe9cution. Un thread correspond \xe0 l'activit\xe9 d'un\nprocesseur dans le cadre d'un processus. Un thead ne peut pas exister sans\nprocessus (la t\xe2che englobante), mais il peut y avoir plusieurs thread par\nprocessus dans le cas de linux il ne peut y avoir de t\xe2che sans au moins une\nactivit\xe9."}),"\n",(0,t.jsx)(n.h3,{id:"description",children:"Description"}),"\n",(0,t.jsx)(n.p,{children:"Un processus est compos\xe9 des parties suivantes : du code, des donn\xe9es, une pile,\ndes descripteurs de fichiers, des tables de signaux. Du point de vue du noyau,\ntransf\xe9rer l'ex\xe9cution \xe0 un autre processus revient \xe0 rediriger les bons\npointeurs et recharger les registres du processeur de la pile. Les divers\nthreads d'un m\xeame processus peuvent partager certaines parties : le code, les\ndonn\xe9es, les descripteurs de fichiers, les tables de signaux. En fait, ils ont\nau minimum leur propre pile, et partagent le reste."}),"\n",(0,t.jsxs)(n.h3,{id:"fork-et-exec",children:[(0,t.jsx)(n.code,{children:"fork"})," et ",(0,t.jsx)(n.code,{children:"exec"})]}),"\n",(0,t.jsxs)(n.p,{children:["Apr\xe8s un fork, le fils ne contient qu'une seule activit\xe9 (celle qui a ex\xe9cut\xe9 le\nfork). Attention aux variables d'exclusion mutuelle (qui font parti de l'espace\nd'adressage partag\xe9) qui sont conserv\xe9es apr\xe8s le ",(0,t.jsx)(n.code,{children:"fork()"})," et donc le contenu ne\nvarie pas. Ainsi si une activit\xe9 a pris le s\xe9maphore avant le ",(0,t.jsx)(n.code,{children:"fork()"}),", si\nl'activit\xe9 principale cherche \xe0 prendre ce s\xe9maphore apr\xe8s le ",(0,t.jsx)(n.code,{children:"fork()"})," elle sera\nind\xe9finiment bloqu\xe9e."]}),"\n",(0,t.jsxs)(n.p,{children:["Apr\xe8s un ",(0,t.jsx)(n.code,{children:"exec"}),", le processus ne contient plus que la thread qui a execut\xe9 l'une\ndes six commandes ",(0,t.jsx)(n.code,{children:"exec"}),". Pas de probl\xe8me avec les s\xe9maphores comme l'espace\nd'adressage a chang\xe9."]}),"\n",(0,t.jsx)(n.h3,{id:"clone",children:(0,t.jsx)(n.code,{children:"clone"})}),"\n",(0,t.jsxs)(n.p,{children:["Sous linux (et rarement sous les syt\xe8mes Unix) il existe un appel syst\xe8me un peu\nsp\xe9cial. Cet appel syst\xe8me r\xe9alise un d\xe9doublement de processus comme ",(0,t.jsx)(n.code,{children:"fork"}),"\nd'o\xf9 son nom de ",(0,t.jsx)(n.code,{children:"clone"}),". Cet appel syst\xe8me permet de pr\xe9ciser exactement ce que\nl'on entend partager entre le processus p\xe8re et le processus fils. \xc9l\xe9ments\npartageables :"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ppid"})," Cr\xe9ation d'un fr\xe8re au lieux d'un fils"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"FS"})," Partage de la structure d'information li\xe9e au syst\xe8me de fichier"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"FILES"})," Partage de la table des descripteurs"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SIGHAND"})," Partage de la table des gestionnaires de Signaux, mais pas des\nmasques de signaux"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"PTRACE"})," Partage du crochet (hook) de debug voir l'appel ptrace"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"VFORK"})," Partage du processeur ! le processus p\xe8re est bloqu\xe9 tant que le\nfils n'a pas ex\xe9cut\xe9 soit ",(0,t.jsx)(n.code,{children:"_exit"})," soit ",(0,t.jsx)(n.code,{children:"execve"}),", c'est \xe0 dire qu'il s'est\nd\xe9tach\xe9 de tout les \xe9l\xe9ments partageable du processus p\xe8re (sauf les ",(0,t.jsx)(n.code,{children:"FILEs"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"VM"})," Partage de la m\xe9moire virtuelle, en particulier les allocations et\nd\xe9sallocations par ",(0,t.jsx)(n.code,{children:"mmap"})," et ",(0,t.jsx)(n.code,{children:"munmap"})," sont visibles par les deux processus."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"pid"})," Les deux processus ont le m\xeame num\xe9ro"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"THREAD"})," Partage du groupe de thread, les deux processus sont ou ne sont pas\ndans le m\xeame groupe de threads."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"les-noms-de-fonctions",children:"Les noms de fonctions"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"pthread[_objet]_operation[_np]"})," o\xf9"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"objet"})," d\xe9signe si il est pr\xe9sent le type de l'objet auquel la fonction\ns'applique. Les valeurs possibles de objet peuvent \xeatre ",(0,t.jsx)(n.code,{children:"cond"})," pour une\nvariable de condition et ",(0,t.jsx)(n.code,{children:"mutex"})," pour un s\xe9maphore d'exclusion mutuelle"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"op\xe9ration"})," d\xe9signe l'op\xe9ration a r\xe9aliser, par exemple ",(0,t.jsx)(n.code,{children:"create"}),", ",(0,t.jsx)(n.code,{children:"exit"})," ou\n",(0,t.jsx)(n.code,{children:"init"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Le suffixe ",(0,t.jsx)(n.code,{children:"np"})," indique, si il est pr\xe9sent, qu'il s'agit d'une fonction non\nportable, c'est \xe0 dire Hors Norme."]}),"\n",(0,t.jsx)(n.h3,{id:"les-noms-de-types",children:"Les noms de types"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"pthread[_objet]_t"})}),"\n",(0,t.jsx)(n.p,{children:"avec objet prenant comme valeur cond, mutex ou rien pour une thread"}),"\n",(0,t.jsx)(n.h3,{id:"attributs-dune-activit\xe9",children:"Attributs d'une activit\xe9"}),"\n",(0,t.jsxs)(n.p,{children:["Identification d'une ",(0,t.jsx)(n.code,{children:"pthread"})," : le TIP de type ",(0,t.jsx)(n.code,{children:"pthread_t"})," obtenu par un appel\n\xe0 la primitive : ",(0,t.jsx)(n.code,{children:"pthread_t pthread_self(void);"})," pour le processus propri\xe9taire\n",(0,t.jsx)(n.code,{children:"pid_t getpid(void);"}),". En POSIX, le fait de tuer la thread de num\xe9ro 1 a pour\neffet de tuer les processus ainsi que toutes les autres threads \xe9ventuelles du\nprocessus. Pour tester l'\xe9galit\xe9 de deux pthreads on utilise ",(0,t.jsx)(n.code,{children:"int pthread_equal(pthread_t tid1, pthread_t tid2);"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"cr\xe9ation-et-terminaison-des-activit\xe9s",children:"Cr\xe9ation et terminaison des activit\xe9s"}),"\n",(0,t.jsx)(n.h4,{id:"cr\xe9ation",children:"Cr\xe9ation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"int pthread_create(pthread_t      *p_tid,\n                   pthread_attr_t attr,\n                   void           *(*fonction)(void *arg),\n                   void           *arg\n                  );\n"})}),"\n",(0,t.jsx)(n.p,{children:"La cr\xe9ation et l'activation d'une activit\xe9 retourne -1 en cas d'\xe9chec, 0 sinon."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"le tid de la nouvelle thread est plac\xe9 \xe0 l'adresse p_tid"}),"\n",(0,t.jsx)(n.li,{children:"attr attribut de l'activit\xe9 (ordonnancement), utiliser pthread_attr_default"}),"\n",(0,t.jsx)(n.li,{children:"le param\xe8tre fonction correspond \xe0 la fonction ex\xe9cut\xe9e par l'activit\xe9 apr\xe8s\nsa cr\xe9ation : il s'agit donc de son point d'entr\xe9e (comme la fonction main\npour les processus). Un retour de cette fonction correspondra \xe0 la terminaison\nde cette activit\xe9"}),"\n",(0,t.jsx)(n.li,{children:"le param\xe8tre arg est transmis \xe0 la fonction au lancement de l'activit\xe9"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"terminaison",children:"Terminaison"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["les appels UNIX ",(0,t.jsx)(n.code,{children:"_exit"})," et donc ",(0,t.jsx)(n.code,{children:"exit"})," terminent toutes les threads du\nprocessus"]}),"\n",(0,t.jsx)(n.li,{children:"terminaison d'une thread"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"int pthread_exit(int *p_status);\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"p_status"})," code retour de la thread, comme dans les processus UNIX la thread est\nzombifi\xe9e pour attendre la lecture du code de retour par une autre thread. \xc0\nl'inverse des processus, comme il peut y avoir plusieurs threads qui attendent,\nla thread zombie n'est pas lib\xe9r\xe9e par la lecture du ",(0,t.jsx)(n.code,{children:"p_status"}),", il faut pour\ncela utiliser une commande sp\xe9ciale qui permettra de lib\xe9rer effectivement\nl'espace m\xe9moire utilis\xe9 par la thread. Cette destruction est explicitement\ndemand\xe9e par la commande"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"int pthread_detack(pthread_t *p_tid);\n"})}),"\n",(0,t.jsx)(n.p,{children:"Si un tel appel a lieu alors que l'activit\xe9 est en cours d'ex\xe9cution, cela\nindique seulement qu'\xe0 l'ex\xe9cution de pthread_exit les ressources seront\nrestitu\xe9es."}),"\n",(0,t.jsx)(n.h2,{id:"synchronisation",children:"Synchronisation"}),"\n",(0,t.jsx)(n.p,{children:"Trois m\xe9canismes de synchronisation inter-activit\xe9s :"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["la primitive ",(0,t.jsx)(n.code,{children:"join"})]}),"\n",(0,t.jsx)(n.li,{children:"les s\xe9maphores d'exclusion mutuelle"}),"\n",(0,t.jsx)(n.li,{children:"les conditions (\xe9v\xe8nements)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"le-mod\xe8le-forkjoin-paterson",children:"Le mod\xe8le fork/join (Paterson)"}),"\n",(0,t.jsx)(n.p,{children:"Les rendez-vous : join"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"int pthread_join(pthread_t tid, int **status);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Cette primitive permet de suspendre l'ex\xe9cution de l'activit\xe9 courante jusqu'\xe0\nce que l'activit\xe9 ",(0,t.jsx)(n.code,{children:"tid"})," ex\xe9cute un appel (implicite ou explicite) \xe0\n",(0,t.jsx)(n.code,{children:"pthread_exit"}),". Si l'activit\xe9 ",(0,t.jsx)(n.code,{children:"tid"})," est d\xe9j\xe0 termin\xe9e, le retour est imm\xe9diat,\net le code de retour de l'activit\xe9 vis\xe9e est \xe9gal \xe0 ",(0,t.jsx)(n.code,{children:"**status"})," (double\nindirection). La primitive retourne 0 en cas de succ\xe8s et -1 en cas d'erreur."]}),"\n",(0,t.jsx)(n.h3,{id:"le-probl\xe8me-de-lexclusion-mutuelle-sur-les-variables-g\xe9r\xe9es-par-le-noyau",children:"Le probl\xe8me de l'exclusion mutuelle sur les variables g\xe9r\xe9es par le noyau"}),"\n",(0,t.jsxs)(n.p,{children:["Il est n\xe9cessaire d'avoir plusieurs variables ",(0,t.jsx)(n.code,{children:"errno"}),", une par activit\xe9. En\neffet cette variable globale pourrait \xeatre chang\xe9e par une autre activit\xe9. Voir\nplus loin comment d\xe9finir des variables globales locales \xe0 chaque activit\xe9."]}),"\n",(0,t.jsx)(n.h3,{id:"les-s\xe9maphores-dexclusion-mutuelle",children:"Les s\xe9maphores d'exclusion mutuelle"}),"\n",(0,t.jsx)(n.p,{children:"Ces s\xe9maphores binaires permettent d'assurer l'exclusion mutuelle."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Il faut d\xe9finir un objet de type ",(0,t.jsx)(n.code,{children:"pthread_mutex_t"})," qui correspond \xe0 un\nensemble d'attributs de type ",(0,t.jsx)(n.code,{children:"pthread_mutexattr_t"})]}),"\n",(0,t.jsx)(n.li,{children:"Initialiser la variable par un appel \xe0 la fonction"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"int pthread_mutex_init(pthread_mutex_t *p_mutex,\n                       pthread_mutexattr_t attr);\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["On pourra d\xe9truire le s\xe9maphore par un appel \xe0 la fonction ",(0,t.jsx)(n.code,{children:"int pthread_mutex_destroy(pthread_mutex_t *p_mutex);"})]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"utilisation-des-s\xe9maphores",children:"Utilisation des s\xe9maphores"}),"\n",(0,t.jsxs)(n.p,{children:["Op\xe9ration P : Un appel \xe0 la fonction ",(0,t.jsx)(n.code,{children:"pthread_mutex_lock(pthread_mutex_t *pmutex);"})," permet \xe0 une activit\xe9 de r\xe9aliser une op\xe9ration P sur le s\xe9maphore.\nSi le s\xe9maphore est d\xe9j\xe0 utilis\xe9, l'activit\xe9 est bloqu\xe9e jusqu'\xe0 la r\xe9alisation\nde l'op\xe9ration V (par une autre activit\xe9) qui lib\xe8rera le s\xe9maphore."]}),"\n",(0,t.jsxs)(n.p,{children:["Op\xe9ration P non bloquante : ",(0,t.jsx)(n.code,{children:"pthread_mutex_trylock(pthread_mutex_t *pmutex);"}),"\nrenvoie 1 si le s\xe9maphore est libre, 0 si le s\xe9maphore est occup\xe9 par une autre\nactivit\xe9 et -1 en cas d'erreur."]}),"\n",(0,t.jsxs)(n.p,{children:["Op\xe9ration v : un appel \xe0 la fonction ",(0,t.jsx)(n.code,{children:"pthread_mutex_unlock(pthread_mutex_t *pmutex);"})," r\xe9alise la lib\xe9ration du s\xe9maphore d\xe9sign\xe9."]}),"\n",(0,t.jsx)(n.h3,{id:"les-conditions-\xe9v\xe8nements",children:"Les conditions (\xe9v\xe8nements)"}),"\n",(0,t.jsxs)(n.p,{children:["Les conditions permettent de bloquer une activit\xe9 sur une attente d'\xe9v\xe8nement.\nPour cela l'activit\xe9 doit poss\xe9der un s\xe9maphore, l'activit\xe9 peut alors lib\xe9rer\nle s\xe9maphore sur l'\xe9v\xe8nement, c'est \xe0 dire : elle lib\xe8re le s\xe9maphore, se bloque\nen attente de l'\xe9v\xe8nement, \xe0 la r\xe9ception de l'\xe9v\xe8nement elle reprend le\ns\xe9maphore. Initialisation d'une variable de type ",(0,t.jsx)(n.code,{children:"pthread_cond_t"})," se fait avec\nla fonction"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"int pthread_cond_init(pthread_cond_t *p_cond, pthread_condattr_t attr);\n"})}),"\n",(0,t.jsx)(n.p,{children:"L'attente sur une condition se fait via la fonction suivante"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"int pthread_cond_wait(pthread_cond_t *p_cond, pthread_mutex_t *p_mutex);\n"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["lib\xe9ration du s\xe9maphore ",(0,t.jsx)(n.code,{children:"*p_mutex"})]}),"\n",(0,t.jsx)(n.li,{children:"activit\xe9 mise en sommeil sur l'\xe9v\xe8nement"}),"\n",(0,t.jsx)(n.li,{children:"r\xe9ception de l'\xe9v\xe8nement, r\xe9cup\xe9ration du s\xe9maphore"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"La condition est ind\xe9pendante de l'\xe9v\xe8nement et n'est pas n\xe9cessairement valide\n\xe0 la reception."}),"\n",(0,t.jsx)(n.h2,{id:"ordonnancement-des-activit\xe9s",children:"Ordonnancement des activit\xe9s"}),"\n",(0,t.jsx)(n.h3,{id:"lordonnancement-posix-des-activit\xe9s",children:"L'ordonnancement POSIX des activit\xe9s"}),"\n",(0,t.jsxs)(n.p,{children:["L'ordonnancement des activit\xe9s DCE bas\xe9 sur POSIX est tr\xe8s similaire \xe0\nl'ordonnancement des activit\xe9s sous MACH. Deux valeurs permettent de d\xe9finir le\nmode d'ordonnancement d'une activit\xe9 : la politique et la priorit\xe9. Pour\nmanipuler ces deux valeurs, il vous faut cr\xe9er un objet attribut d'activit\xe9\n(pthread_attr) en appelant ",(0,t.jsx)(n.code,{children:"pthread_attr_create()"}),", puis changer les valeurs par\nd\xe9faut avec les fonctions d\xe9crites plus loin et cr\xe9er la pthread avec cet objet\n",(0,t.jsx)(n.code,{children:"pthread_attr"}),". Ou bien la pthread peut elle-m\xeame changer ses deux valeurs,\npriorit\xe9 et politique. Les fonctions sont :"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"#include <pthread.h>\npthread_attr_setsched(pthread_attr_t *attr, int politique);\npthread_attr_setprio(pthread_attr_t *attr, int prio);\n"})}),"\n",(0,t.jsx)(n.p,{children:"Les diff\xe9rentes politiques possibles sont :"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SCHED_FIFO"})," la thread la plus prioritaire s'ex\xe9cute jusqu'\xe0 ce qu'elle\nbloque. Si il y a plus d'une pthread de priorit\xe9 maximum, la premi\xe8re qui\nobtient le cpu s'ex\xe9cute jusqu'\xe0 ce qu'elle bloque"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SCHED_RR"})," Round Robin. La thread la plus prioritaire s'ex\xe9cute jusqu'\xe0 ce\nqu'elle bloque. Les threads de m\xeame priorit\xe9s maximum sont organis\xe9es avec le\nprincipe du tourniquet, c'est \xe0 dire qu'il existe un quantum de temps au bout\nduquel le cpu est pr\xe9empt\xe9 pour une autre thread."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SCHED_OTHER"})," Comportement par d\xe9faut. Tous les threads sont dans le m\xeame\ntourniquet, il n'y a pas de niveau de priorit\xe9, ceci permet l'absence de\nfamine. Mais les threads avec une politique ",(0,t.jsx)(n.code,{children:"SCHED_FIFO"})," ou ",(0,t.jsx)(n.code,{children:"SCHED_RR"})," peuvent\nplacer les threads ",(0,t.jsx)(n.code,{children:"SCHED_OTHER"})," en situation de famine."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"les-variables-sp\xe9cifiques-\xe0-une-thread",children:"Les variables sp\xe9cifiques \xe0 une thread"}),"\n",(0,t.jsxs)(n.p,{children:["Avec un processus multi-thread, nous sommes dans une situation de partage de\ndonn\xe9es. Toutes les donn\xe9es du processus sont \xe0 priori manipulables par toutes\nles threads. Or certainns donn\xe9es sont critiques et difficilement partageables.\nPremi\xe8rement ce sont les donn\xe9es de la biblioth\xe8que standard. Pour les fonctions\nde la biblioth\xe8que standard, on peut r\xe9soudre le probl\xe8me en utilisant un\ns\xe9maphore d'exclusion mutuelle ",(0,t.jsx)(n.code,{children:"pthread_mutex_t"})," pour POSIX."]}),"\n",(0,t.jsxs)(n.p,{children:["Mais certaines variables ne peuvent \xeatre prot\xe9g\xe9es. C'est le cas de la variable\n",(0,t.jsx)(n.code,{children:"errno"}),", comme nous l'avons vu pr\xe9c\xe9demment. Pour cette variable, la solution\nest d'avoir une variable par thread. Ainsi le fichier ",(0,t.jsx)(n.code,{children:"<errno.h>"})," contient"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"extern int *_errno();\n#define errno (*_errno())\n"})}),"\n",(0,t.jsxs)(n.p,{children:["La valeur ",(0,t.jsx)(n.code,{children:"errno"})," est obtenue par une fonction qui retourne la valeur de ",(0,t.jsx)(n.code,{children:"errno"}),"\nassoci\xe9e \xe0 la thread qui fait l'appel \xe0 ",(0,t.jsx)(n.code,{children:"_errno"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"principe-g\xe9n\xe9ral-des-donn\xe9es-sp\xe9cifiques-posix",children:"Principe g\xe9n\xe9ral des donn\xe9es sp\xe9cifiques, POSIX"}),"\n",(0,t.jsxs)(n.p,{children:["L'id\xe9e des donn\xe9es sp\xe9cifique est de cr\xe9er un vecteur pour chaque donn\xe9e\nsp\xe9cifique. Ainsi pour des donn\xe9es sp\xe9cifique statiques, chaque thread poss\xe8de\nson propre exemplaire. Les donn\xe9es sp\xe9cifiques sont identifi\xe9es par des cl\xe9s de\ntype ",(0,t.jsx)(n.code,{children:"pthread_key_t"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"cr\xe9ation-de-cl\xe9s",children:"Cr\xe9ation de cl\xe9s"}),"\n",(0,t.jsx)(n.p,{children:"La cr\xe9ation d'une cl\xe9 est li\xe9e \xe0 la cr\xe9ation d'un tableau statique (variable\nglobale), initialis\xe9 \xe0 NULL \xe0 la cr\xe9ation. La fonction"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"#include <pthread.h>\nint pthread_keycreate(pthread_key_t *p_cle, \n                      void (*destructeur)(void *valeur));\n"})}),"\n",(0,t.jsxs)(n.p,{children:["permet la cr\xe9ation du tableau, 0 succ\xe8s et -1 \xe9chec. La structure point\xe9e par\n",(0,t.jsx)(n.code,{children:"p_cle"})," nous permettra d'acc\xe9der aux valeurs stock\xe9es, la cl\xe9 est \xe9videmment la\nm\xeame pour toutes les threads. Le param\xe8tre ",(0,t.jsx)(n.code,{children:"destructeur"})," de type pointeur sur\nfonction prenant un pointeur sur void en param\xe8tre et renvoyant void, donne\nl'adresse d'une fonction qui est ex\xe9cut\xe9e \xe0 la terminaison de la thread (ce qui\npermet de faire le m\xe9nage). Si ce pointeur est nul, l'information n'est pas\nd\xe9truite \xe0 la terminaison de l'activit\xe9."]}),"\n",(0,t.jsx)(n.h3,{id:"lecture--\xe9criture-dune-variable-sp\xe9cifique",children:"Lecture / \xe9criture d'une variable sp\xe9cifique"}),"\n",(0,t.jsx)(n.p,{children:"La fonction"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"#include <pthread.h>\nint pthread_getspecific(pthread_key_t *p_cl\xe9, void **pvaleur);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["permet la lecture de la valeur qui est copi\xe9e \xe0 l'adresse ",(0,t.jsx)(n.code,{children:"pvaleur"})," retourne 0\nou -1 selon que l'appel a r\xe9ussi ou non. La fonction"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"#include <pthread.h>\nint pthread_setspecific(pthread_key_t *p_cl\xe9, void *valeur);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["permet la cr\xe9ation du tableau, 0 succ\xe8s et -1 \xe9chec. La structure point\xe9e par\n",(0,t.jsx)(n.code,{children:"p_cle"})," nous permettra d'acc\xe9der aux valeurs stock\xe9es, la cl\xe9 est \xe9videmment la\nm\xeame pour toutes les threads. Le param\xe8tre ",(0,t.jsx)(n.code,{children:"destructeur"})," de type pointeur sur\nfonction prenant un pointeur sur void en param\xe8tre et renvoyant void, donne\nl'adresse d'une fonction qui est ex\xe9cut\xe9e \xe0 la terminaison de la thread (ce qui\npermet de faire le m\xe9nage). Si ce pointeur est nul, l'information n'est pas\nd\xe9truite \xe0 la terminaison de l'activit\xe9."]}),"\n",(0,t.jsx)(n.h2,{id:"les-fonctions-standardes-utilisant-des-zones-statiques",children:"Les fonctions standardes utilisant des zones statiques"}),"\n",(0,t.jsxs)(n.p,{children:["Certaines fonctions standardes comme ",(0,t.jsx)(n.code,{children:"ttyname()"})," ou ",(0,t.jsx)(n.code,{children:"readdir()"})," retourne\nl'adresse d'une zone statique. Plusieurs threads en concurrence peuvent donc\nnous amener \xe0 des situations incoh\xe9rentes. La solution des s\xe9maphores\nd'exclusion \xe9tant co\xfbteuse, ces fonctions sont r\xe9\xe9crites pour la biblioth\xe8que de\nthread de fa\xe7on \xe0 \xeatre r\xe9entrantes."]}),"\n",(0,t.jsx)(n.p,{children:"Attention les probl\xe8mes de r\xe9entrance peuvent avoir lieu en utilisant des appels\nsyst\xe8mes non r\xe9entrant dans les handlers des signaux ! Ceci sans utiliser de\nthreads !"})]})}function u(e={}){const{wrapper:n}={...(0,i.M)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},73440:(e,n,s)=>{s.d(n,{c:()=>t});const t=s.p+"assets/images/SYS7-5bb2691f9b7335b999d3723de7daacdf.png"},4552:(e,n,s)=>{s.d(n,{I:()=>l,M:()=>a});var t=s(11504);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);