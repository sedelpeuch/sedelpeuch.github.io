<!DOCTYPE html>
<html lang="en-Us"><head>
  <meta charset="utf-8">
  <title>La mémoire virtuelle</title>

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Semestre 9 de l&#39;ENSEIRB-MATEMECA">
  <meta name="author" content="Sébastien">
  <meta name="generator" content="Hugo 0.74.3" />

  <!-- plugins -->
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/plugins/bootstrap/bootstrap.min.css">
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/plugins/Ionicons/css/ionicons.min.css">
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/plugins/magnific-popup/magnific-popup.css">
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/plugins/slick/slick.css">
  

  <!-- Main Stylesheet -->
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/scss/style.min.css" media="screen">

  <!--Favicon-->
  <link rel="shortcut icon" href="https://Sdelpeuch.github.io/images/favicon.png" type="image/x-icon">
  <link rel="icon" href="https://Sdelpeuch.github.io/images/favicon.png" type="image/x-icon">

</head><body>
<!-- preloader start -->
<div class="preloader">
  
</div>
<!-- preloader end -->

<header class="navigation">
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        
        <nav class="navbar">
          
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navigation">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">
              <img src="https://Sdelpeuch.github.io/images/telechargement.png" alt="Semestre 9" width="65px" class="img-responsive">
            </a>
          </div>
          
          <div class="collapse navbar-collapse" id="navigation">
            <ul class="nav navbar-nav navbar-right">
              
              
              <li><a href="/">Accueil</a></li>
              
              
              
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true"
                  aria-expanded="false">Semestre 9 <span class="ion-ios-arrow-down"></span></a>
                <ul class="dropdown-menu">
                  
                  <li><a href="/semestre9/controle">Contrôle commande</a></li>
                  
                  <li><a href="/semestre9/interaction">Interactions</a></li>
                  
                  <li><a href="/semestre9/maths">Mathématiques</a></li>
                  
                  <li><a href="/semestre9/modelisation">Modélisation</a></li>
                  
                  <li><a href="/semestre9/mecatronique">Mécatronique</a></li>
                  
                  <li><a href="/semestre9/imagerie">Outils d&#39;imagerie</a></li>
                  
                  <li><a href="/semestre9/energie">Énergétique</a></li>
                  
                </ul>
              </li>
              
              
              
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true"
                  aria-expanded="false">Semestre 8 <span class="ion-ios-arrow-down"></span></a>
                <ul class="dropdown-menu">
                  
                  <li><a href="/semestre8/apptcp-ip">Applications TCP/IP</a></li>
                  
                  <li><a href="/semestre8/complex">Calculabilité</a></li>
                  
                  <li><a href="/semestre8/crypto">Cryptologie</a></li>
                  
                  <li><a href="/semestre8/ia">Intelligence artificielle</a></li>
                  
                  <li><a href="/semestre8/maker">Maker</a></li>
                  
                  <li><a href="/semestre8/qualite">Qualité</a></li>
                  
                  <li><a href="/semestre8/robotique">Robotique</a></li>
                  
                  <li><a href="/semestre8/se">Sys Exploitation</a></li>
                  
                  <li><a href="/semestre8/jeux">Théorie des jeux</a></li>
                  
                  <li><a href="/semestre8/projet">Évaluation des projets</a></li>
                  
                </ul>
              </li>
              
              
              
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true"
                  aria-expanded="false">Semestre 7 <span class="ion-ios-arrow-down"></span></a>
                <ul class="dropdown-menu">
                  
                  <li><a href="/semestre7/compilation/">Compilation</a></li>
                  
                  <li><a href="/semestre7/gl">Génie Logiciel</a></li>
                  
                  <li><a href="/semestre7/poo">POO</a></li>
                  
                  <li><a href="/semestre7/cpp">Programmation C&#43;&#43;</a></li>
                  
                  <li><a href="/semestre7/quantique">Quantique</a></li>
                  
                  <li><a href="/semestre7/bdd">SGBD</a></li>
                  
                  <li><a href="/semestre7/prog_sys/">Système</a></li>
                  
                  <li><a href="/semestre7/tcp">TCP/IP</a></li>
                  
                </ul>
              </li>
              
              
              
              <li><a href="/semestre6/semestre_6">Semestre 6</a></li>
              
              
              
              <li><a href="/contact">Contact</a></li>
              
              
              
              <li><a href="/semestre5/semestre_5">Semestre 5</a></li>
              
              
              
              <li><a href="/cpbx">CPBx</a></li>
              
              

              
            </ul>
          </div>
        </nav>
      </div>
    </div>
  </div>
</header>

<section class="page-title bg-2" style="background-image: url('https://Sdelpeuch.github.io/images/banner/info.jpg');">
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        <div class="block">
          <h1>La mémoire virtuelle</h1>
          <p></p>
        </div>
      </div>
    </div>
  </div>
</section>


<section class="page-wrapper">
	<div class="container">
		<div class="row">
			<div class="col-md-8">
				<div class="post post-single">
					<h2 class="post-title">La mémoire virtuelle</h2>
					<div class="post-meta">
						<ul>
              <li><i class="ion-calendar"></i> November 20, 2020</li>
              
              
              
              
              
              
              <li><i class="ion-pricetags"></i> 
                
                <a href="/tags/programmation%20syst%c3%a8me">Programmation système</a>
								
              </li>
            </ul>
					</div>
					
					
					
					<div class="post-content post-excerpt">
						<p>Les méthodes de gestion mémoire que nous venons de voir ont toutes un défaut
majeur qui est de garder l&rsquo;ensemble du processus en mémoire, ce qui donne :</p>
<ul>
<li>un coût en swap important</li>
<li>impossibilité de créer de très gros processus</li>
</ul>
<p>Les méthodes de mémoire virtuelle permettent d&rsquo;exécuter un programme qui ne
tient pas entièrement en mémoire centrale ! Nous avons commencé par présenter
des algorithmes de gestion de la mémoire qui utilisent le concept de base
suivante : l&rsquo;ensemble de l&rsquo;espace logique adressable d&rsquo;un processus doit être en
mémoire pour pouvoir exécuter le processus.</p>
<p>Cette restriction semble à la fois raisonnable et nécessaire, mais aussi très
dommageable car cela limite la taille des processus à la taille de la mémoire
physique.</p>
<p>Or si l&rsquo;on regarde des programmes très standards, on voit que :</p>
<ul>
<li>il y a des portions de code qui gèrent des cas très inhabituels qui ont lieu
très rarement (si ils ont lieu)</li>
<li>les tableaux, les listes et autre tables sont en général initialisés à des
tailles beaucoup plus grandes que ce qui est réellement utile</li>
<li>Certaines options d&rsquo;application sont très rarement utilisées</li>
</ul>
<p>Même dans le cas où le programme en entier doit résider en mémoire, tout n&rsquo;est
peut-être pas absolument nécessaire en même temps. Avec la mémoire virtuelle, la
mémoire logique devient beaucoup plus grande que la mémoire physique.</p>
<p>Cela implique de nombreux avantages : comme les utilisateurs consomment
individuellement moins de mémoire, plus d&rsquo;utilisateurs peuvent travailler en
même temps. Avec l&rsquo;augmentation de l&rsquo;utilisation du CPU et de débit que cela
implique (mais pas d&rsquo;augmentation de la vitesse). Moins d&rsquo;entrées-sorties sont
effectuées pour l&rsquo;exécution d&rsquo;un processus, ce qui fait que le processus
s&rsquo;exécute (temps réel) plus rapidement.</p>
<h3 id="les-overlays">Les overlays</h3>
<p>Une des premières versions d&rsquo;exécutable partiellement en mémoire est celle des
&ldquo;overlay&rdquo; qui est l&rsquo;idée de charger successivement des portions disjointes et
différentes de code en mémoire, exécutées l&rsquo;une après l&rsquo;autre. Les différentes
passes d&rsquo;un compilateur sont souvent réalisées en utilisant un overlay. Les
overlay nécessitent quelques adaptations de l&rsquo;éditeur de liens et des mécanismes
de relocation.</p>
<h3 id="le-chargement-dynamique">Le chargement dynamique</h3>
<p>Un autre système couramment utilisé dans les logiciels du marché des micros est
le chargement dynamique. Avec le chargement dynamique, une fonction n&rsquo;est chargé
en mémoire qu&rsquo;au moment de son appel. Le chargement dynamique demande que toutes
les fonctions soient repositionnables en mémoire de façon indépendante. A chaque
appel de fonction on regarde si la fonction est en mémoire sinon un éditeur de
liens dynamique est appelé pour la charger. Dans les deux cas (overlay et
chargement dynamique), le système joue un rôle très restreint, il suffit en
effet d&rsquo;avoir un bon système de gestion de fichiers. Malheureusement, le travail
que doit réaliser le programmeur pour choisir les overlays et/ou installer un
mécanisme de chargement dynamique efficace est non trivial et requiert que le
programmeur ait une parfaite connaissance du programme. Ceci nous amène aux
techniques automatiques.</p>
<h2 id="demande-paging">Demande Paging</h2>
<p>La méthode de Demand Paging est la plus répandue des implémentations de mémoire
virtuelle, elle demande de nombreuse capcités matérielles.</p>
<p>Nous partons d&rsquo;un système de swap où la mémoire est découpée en pages. Comme
pour le swap, quand un programme doit être exécuté nous le chargeons en mémoire
(swap in) mais au lieu de faire un swap complet, on utilise un &ldquo;swappeur paresseur&rdquo;
(lazy swapper). Un swappeur paresseux charge une page uniquement si elle est nécessaire.</p>
<p>Que ce passe-t-il quand le programme essaie d&rsquo;accéder à une page qui est hors
mémoire ?</p>
<ul>
<li>le matériel va traduire l&rsquo;adresse logique en une adresse physique grâce à la
table des pages</li>
<li>tant que les pages demandées sont en mémoire, le programme tourne normalement,
sinon la page est contenue dans l&rsquo;espace des adresses logiques mais n&rsquo;est pas
chargée, il y a une <strong>page fault</strong>.</li>
</ul>
<p>En général, une erreur d&rsquo;adresse est dûe à une tentative d&rsquo;accès à une adresse
extérieure (invalide). Dans ce cas, le programme doit être interrompu, c&rsquo;est le
comportement normal d&rsquo;un système de swap. Mais il est possible avec un swappeur
paresseux que la page existe mais ne soit pas en mémoire centrale, d&rsquo;où les
étapes suivantes dans ce cas : On peut faire démarrer un processus sans aucune
page en mémoire. La première <strong>Page fault</strong> aurait lieu à la lecture de la
première instruction (l&rsquo;instruction n&rsquo;étant pas en mémoire). Il faut réaliser
une forme spéciale de sauvegarde de contexte, il faut garder une image de l&rsquo;état
du processus qui vient d&rsquo;effectuer une <strong>Page Fault</strong> mais de plus il faudra
redémarrer (réexécuter) l&rsquo;instruction qui a placé le processus dans cet état, en
effet il est possible que l&rsquo;instruction ne soit pas terminé par manque de
données. Le système d&rsquo;exploitation a ici un rôle important, c&rsquo;est lui qui va
réaliser le chargement de la page manquante puis relancer le processus et
l&rsquo;instruction. Les circuits nécessaires à la méthode de Demande Paging sont les
mêmes que ceux que l&rsquo;on utilise pour un système de swap paginé, c&rsquo;est à dire une
mémoire secondaire et un gestionnaire de pages (table des pages). Par contre, la
partie logicielle est beaucoup plus importante. Enfin il faut que les
<strong>instructions soient interruptibles</strong>, ce qui n&rsquo;est pas toujours le cas sur
tous les processeurs et ce qui est fondamental.</p>
<h3 id="efficacité">Efficacité</h3>
<p>Efficacité des performances de Demande Paging : Soit ma = 500 nanosecondes, le
temps moyen d&rsquo;accès a une mémoire. Le temps effectif d&rsquo;accès avec le Demand
Paging est : temps effectif = (1-p)*ma + p* &ldquo;temps de gestion de l&rsquo;erreur de
page&rdquo; où p est la probabilité d&rsquo;occurrence d&rsquo;une erreur de page (page fault).
Une erreur de page nécessite de réaliser les opérations suivantes</p>
<ol>
<li>lever une interruption pour le système</li>
<li>sauvegarder le contexte du processus</li>
<li>déterminer que l&rsquo;interruption est une erreur de page</li>
<li>vérifier que la page en question est une page légale de l&rsquo;espace logique,
déterminer où se trouve la page dans la mémoire secondaire</li>
<li>exécuter une lecture de la page sur une mémoire libre (libérer éventuellement
une page cf. algorithme de remplacement de page)
<ul>
<li>attendre que le périphérique soit libre</li>
<li>temps de latence du périphérique</li>
<li>commencer le transfert</li>
</ul>
</li>
<li>allouer pendant ce temps là le cpu à un autre utilisateur</li>
<li>interruption du périphérique</li>
<li>sauvegarde du contexte du processus courant</li>
<li>déterminer que l&rsquo;interruption était la bonne interruption (venant du
périphérique)</li>
<li>mise à jour de la table des pages et d&rsquo;autres pages pour indiquer que la
page demandée est en mémoire maintenant.</li>
<li>attendre que le processus soit sélectionné de nouveau pour utiliser l&rsquo;unité
centrale (cpu)</li>
<li>charger le contexte du processus</li>
</ol>
<p>Toutes ces instructions ne sont pas toujours réalisées (on peut en particulier
supposer que l&rsquo;on ne peut pas préempter l&rsquo;unité centrale, mais alors quelle
perte de temps pour l&rsquo;ensemble du système). Dans tous les cas, nous devons au
moins réaliser les 3 actions suivantes :</p>
<ul>
<li>gérer l&rsquo;interruption</li>
<li>swapper la page demandée</li>
<li>relance le processus</li>
</ul>
<p>Ce qui coûte le plus cher est la recherche de la page sur le disque et son
transfert en mémoire, ce qui prend de l&rsquo;ordre de 1 à 10 millisecondes.</p>
<p>Ce qui nous donne en prenant une vitesse d&rsquo;accès mémoire de 1 microseconde et un
temps de gestion de page de 5 millisecondes un</p>
<p>temps effectif = (1-p)+p * 5000 microsecondes</p>
<p>Une erreur de page toutes les mille pages nous donne un temps effectif onze fois
plus long que l&rsquo;accès standard.</p>
<p>Il faut réduire à moins d&rsquo;une erreur de page tout les 100 000 accès pour obtenir
une dégradation inférieur à 10. On comprend bien que les choix  à faire sur des
pages qu&rsquo;il faut placer en mémoire sont donc très importants.</p>
<p>Ces choix deviennent encore plus importants quand l&rsquo;on a de nombreux
utilisateurs et qu&rsquo;il y a sur-allocation de la mémoire, exécution concurrente de
6 processus de la taille supérieure ou égale à la mémoire physique !</p>
<p>Si l&rsquo;on suppose de plus que nos 6 programmes utilisent dans une petite séquence
d&rsquo;instructions toutes les pages de leur mémoire logique, nous nous trouvons
alors dans une situation de pénurie de pages libres. Le système d&rsquo;exploitation
peut avoir recours à plusieurs solution dans ce cas-là</p>
<ol>
<li>tuer le processus fautif</li>
<li>utiliser un algorithme de remplacement de page</li>
</ol>
<p>Cet algorithme de remplacement est introduit dans notre séquence de gestion
d&rsquo;erreur de page là où l&rsquo;on s&rsquo;attribuait une page libre de la mémoire centrale.</p>
<p>Maintenant il nous faut sélectionne une victime, c&rsquo;est à dire, une des pages
occupées de la mémoire centrale qui sera swappée sur disque et remplacée par la
page demandée. Remarquons que dans ce cas-là notre temps de transfert est
doublé, comme i faut à la fois lire une page et sauvegarder une page sur disque
(le temps de transfert disque est ce qui est le plus coûteux dans la gestion
d&rsquo;une erreur de page). Il est possible de réaliser des systèmes de <strong>demande
segments</strong>, mais le lecteur avisé remarquera rapidement les problèmes posés par
la taille variable des segments.</p>
<h2 id="allocation-de-pages-aux-processus">Allocation de pages aux processus</h2>
<p>Comment répartir les pages sur les différents processus et le système ?</p>
<ul>
<li>
<p><strong>remplacement local</strong> le processus se voit affecté un certain nombre de pages
qu&rsquo;il va utiliser de façon autonome, son temps d&rsquo;exécution ne dépend que de
son propre comportement</p>
</li>
<li>
<p><strong>remplacement global</strong> le comportement d&rsquo;allocation de pages aux processus
dépend de la charge du système et du comportement des différents processus.</p>
<p>Le remplacement local demande que l&rsquo;on réalise un partage entre les différents
processus.</p>
</li>
</ul>
<p>Le partage &ldquo;équitable&rdquo; : <code>m</code> pages de mémoire physique, <code>n</code> processus, <code>m/n</code>
pages par processus ! O nretrouve ici un problème proche de la fragmentation
interne, un grand nombre de pages est donné à un processus qui en utilise
effectivement peu.</p>
<p>Si la mémoire est libre et assez grande, les deux processus sont grossièrement
aussi rapides, par contre si on lance dix exemplaires du premier, le temps
d&rsquo;attente est juste multiplié par 10. Pour le deuxième, le temps d&rsquo;attente est
au moins multiplié par 100.</p>
<h2 id="lappel-fork-et-la-mémoire-virtuelle">L&rsquo;appel fork et la mémoire virtuelle</h2>
<p>Nous avons vu que la primitive <code>fork()</code> réalise une copie de l&rsquo;image mémoire du
processus père pour créer le processus fils. Cette copie n&rsquo;est pas intégrale car
les deux processus peuvent partager des pages marquées en lecture seule, en
particulier le segment du code est partagé par les deux processus (réentrance
standard des processus unix).</p>
<p>Mais avec le système de demand-paging, on peut introduire une nouvelle notion
qui est la &ldquo;copie sur écriture&rdquo; (copy on write). On ajoute à la structure de
page de la table des pages des indicateurs de &ldquo;copie sur écriture&rdquo;. L&rsquo;idée est
de réaliser la copie de la page uniquement dans le cas où l&rsquo;un des processus qui
peuvent y accéder réaliser une écriture. Dans ce cas-là, la page est recopiée
avant l&rsquo;écriture et le processus écrivain possède alors sa propre page.
L&rsquo;intérêt de ce mécanisme est srutout visible dans le cas très fréquent où le
<code>fork</code> est immédiatement suivi par un <code>exec</code>. En effet ce dernier va réaliser
une libération de toutes les pages, il est donc inutile de les recopier juste
avant cette libération.</p>
<p>Le système BSD a introduit la première version de cette idée en partant de
l&rsquo;appel système <code>vfork()</code> qui lui permet le partage total de toutes les pages
entre le processus père et le processus fils sans aucune copie. L&rsquo;intérêt est de
pouvoir réaliser rapidement un <code>execve</code> sans avoir à recopier l&rsquo;espace
d&rsquo;adressage du processus père.</p>
<h2 id="projection-de-fichiers-en-mémoire">Projection de fichiers en mémoire</h2>
<p>La fonction <code>mmap</code> permet la projection de fichiers en mémoire. LE segment du
fichier indique est placé en mémoire à partir de l&rsquo;adresse indiquée. Le segment
de fichier peut aisni être parcouru par des accès par adresse sans utiliser de
commande de lecture ou d&rsquo;écriture.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/mman.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mmap</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>adr, <span style="color:#66d9ef">int</span> len, <span style="color:#66d9ef">int</span> prot, <span style="color:#66d9ef">int</span> options, <span style="color:#66d9ef">int</span> desc, <span style="color:#66d9ef">int</span> offset);

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">munmap</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>adr, <span style="color:#66d9ef">int</span> len);
</code></pre></div><p>L&rsquo;adresse <code>adr</code> indique où doit être placé le fichier, cette adresse doit être
une adresse de début de page (un multiple de <code>sysconf(_SC_PAGE_SIZE)</code>, si le
paramètre est <code>NULL</code> alors le système sélectionne l&rsquo;adresse de placement qui est
retournée par la fonction. L&rsquo;intervalle de position <code>[offset, offset+len]</code> du
fichier <code>desc</code> est placé en mémoire). <code>prot</code> indique les protections d&rsquo;accès
sous <code>HP-UX</code> les protections suivantes sont disponibles : <code>PROT_NONE, PROT_READ, PROT_READ|PROT_EXECUTE, PROT_READ|PROT_WRITE, PROT_READ|PROT_WRITE|PROT_EXECUTE</code>
<code>options</code> indique si l&rsquo;on veut que les écritures réalisées dans les pages
contenant la projection soient partagées (<code>MAP_SHARED</code>), ou au contraire qu&rsquo;une
copie sur écriture soit réalisée (<code>MAP_PRIVATE</code>). La fonction <code>munmap</code> permet de
libérer la zone mémoire d&rsquo;adresse <code>adr</code> et de longueur <code>len</code>. Pour une autre
forme de mémoire partagée.</p>
<h2 id="les-conseils-et-politiques-de-chargement-des-zonnes-mmapés">Les conseils et politiques de chargement des zonnes mmapés</h2>
<p>Une fois que l&rsquo;on a décidé de faire des projections en mémoire avec <code>mmap</code> il
peut être opportun de faire appel à la fonction <code>madvise</code> qui permet de donner
un conseil au système en le prévenant par avance de la façon dont vous allez
utiliser le segment de mémoire. En particulier allez vous lire le fichier
sequentiellement ou de façon aléaatoire. Avez vous encore besoin du fichier
après lecture etc. Biensur la fonction <code>madvise</code> ne se limite pas aux pages
mappés mais c&rsquo;est sur celle ci q&rsquo;il est le plus facile de prendre des décisions,
les autres pages étant gérées dans la pile, le tas et le code dans des zone plus
délicates et moins bien cartographiées en général (sic).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/mman.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">madvise</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>start, size_t length, <span style="color:#66d9ef">int</span> advise<span style="color:#f92672">*</span>);
</code></pre></div><p>La valeur du conseil <code>advice</code> :</p>
<ul>
<li>MADV_NORMAL : Comportement par défaut</li>
<li>MADV_RANDOM : prévoit des accès aux pages dans un ordre aléatoire</li>
<li>MADV_SEQUENTIAL : prévoit des accès aux pages dans un ordre séquentiel</li>
<li>MADV_WILINEED : prévoit un accès dans un futur proche</li>
<li>MADV_DONTNEED : ne prévoit pas d&rsquo;accès dans un futur proche</li>
</ul>
<p>Biensur ce ne sont que des conseils le système les utilisera si il en a la
possibilité, soit parce qu&rsquo;il a du temps idle soit parce qu&rsquo;il profitera des
lectures groupées sur disque en réalisant des lectures en avance dans le cas
séquentiel. Il peut aussi profiter de l&rsquo;indication <code>DONTNEED</code> pour prendre des
décisions dans le code de remplacement de page.</p>
<h2 id="chargement-dynamique">Chargement dynamique</h2>
<p>Indépendemment de l&rsquo;existence de la mémoire virtuelle il est possible de gérer
&ldquo;à la main&rdquo; le code accessible en utilisant le chargement direct (non
automatique) de librairies.</p>

					</div>
					<div class="post-comments">
						
					</div>
				</div>
			</div>
      <div class="col-md-4">
        <aside class="sidebar">



















































<div class="widget widget-latest-post">
    <h4 class="widget-title">Derniers cours</h4>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/semestre9/imagerie/1/">Introduction</a></h4>
        <h5>[Outils d&#39;imagerie]</h5>
        <p>Commençons par définir les différents termes que …</p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/semestre9/interaction/1/">Architecture</a></h4>
        <h5>[Système embarqués]</h5>
        <p></p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/semestre9/se/1/">Architecture</a></h4>
        <h5>[Système embarqués]</h5>
        <p>Programmer un microcontrolleur Un microcontrolleur …</p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/semestre9/se/2/">Bus de communication</a></h4>
        <h5>[Système embarqués]</h5>
        <p></p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/semestre9/maths/1/">Modélisation</a></h4>
        <h5>[Maths]</h5>
        <p>À partir d&rsquo;une position initiale, le robot …</p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/semestre9/controle/">Contrôle commande Page d&#39;accueil</a></h4>
        <h5>[Contrôle commande]</h5>
        <p>L&rsquo;objet du cours est de présenter …</p>
      </div>
    </div>
    
  </div>
</aside>


      </div>
		</div>
	</div>
</section>

<footer class="footer">
	<div class="container">
		<div class="row">
			<div class="col-md-12">
				<div class="footer-manu">
					<ul>
            
            <li><a href="https://Sdelpeuch.github.io/semestre9">Semestre 9</a></li>
            
            <li><a href="https://Sdelpeuch.github.io/about">Semestre 8</a></li>
            
            <li><a href="https://Sdelpeuch.github.io/about">Semestre 7</a></li>
            
            <li><a href="https://Sdelpeuch.github.io/contact">Semestre 6</a></li>
            
            <li><a href="https://Sdelpeuch.github.io/project">Semestre 5</a></li>
            
            <li><a href="https://Sdelpeuch.github.io/cpbx">CPBx</a></li>
            
					</ul>
				</div>
				<p class="copyright">Copyright © 2020 <a href="https://themefisher.com">Themefisher</a> All Rights Reserved</p>
			</div>
		</div>
	</div>
</footer>



<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCcABaamniA6OL5YvYSpB3pFMNrXwXnLwU&amp;libraries=places"></script>




<script src="https://Sdelpeuch.github.io/plugins/jQuery/jquery.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/bootstrap/bootstrap.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/slick/slick.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/magnific-popup/jquery.magnific-popup.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/shuffle/shuffle.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/google-map/gmap.js"></script>




<script src="https://Sdelpeuch.github.io/js/script.min.js"></script>







<script src="https://cdnjs.cloudflare.com/ajax/libs/js-cookie/2.2.1/js.cookie.min.js"></script>
<div id="js-cookie-box" class="cookie-box cookie-box-hide">
	This site uses cookies. By continuing to use this website, you agree to their use. <span id="js-cookie-button" class="btn btn-main btn-solid-border">I Accept</span>
</div>
<script>
	(function ($) {
		const cookieBox = document.getElementById('js-cookie-box');
		const cookieButton = document.getElementById('js-cookie-button');
		if (!Cookies.get('cookie-box')) {
			cookieBox.classList.remove('cookie-box-hide');
			cookieButton.onclick = function () {
				Cookies.set('cookie-box', true, {
					expires:  2 
				});
				cookieBox.classList.add('cookie-box-hide');
			};
		}
	})(jQuery);
</script>


<style>
.cookie-box {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  text-align: center;
  z-index: 9999;
  padding: 1rem 2rem;
  background: rgb(71, 71, 71);
  transition: all .75s cubic-bezier(.19, 1, .22, 1);
  color: #fdfdfd;
}

.cookie-box-hide {
  display: none;
}
</style>
</body>

</html>