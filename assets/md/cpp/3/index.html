<!DOCTYPE html>
<html lang="en-Us"><head>
  <meta charset="utf-8">
  <title>La couche Objet - Partie 3 : opérateurs</title>

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Semestre 9 de l&#39;ENSEIRB-MATEMECA">
  <meta name="author" content="Sébastien">
  <meta name="generator" content="Hugo 0.74.3" />

  <!-- plugins -->
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/plugins/bootstrap/bootstrap.min.css">
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/plugins/Ionicons/css/ionicons.min.css">
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/plugins/magnific-popup/magnific-popup.css">
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/plugins/slick/slick.css">
  

  <!-- Main Stylesheet -->
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/scss/style.min.css" media="screen">

  <!--Favicon-->
  <link rel="shortcut icon" href="https://Sdelpeuch.github.io/images/favicon.png" type="image/x-icon">
  <link rel="icon" href="https://Sdelpeuch.github.io/images/favicon.png" type="image/x-icon">

</head><body>
<!-- preloader start -->
<div class="preloader">
  
</div>
<!-- preloader end -->

<header class="navigation">
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        
        <nav class="navbar">
          
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navigation">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">
              <img src="https://Sdelpeuch.github.io/images/telechargement.png" alt="Semestre 9" width="65px" class="img-responsive">
            </a>
          </div>
          
          <div class="collapse navbar-collapse" id="navigation">
            <ul class="nav navbar-nav navbar-right">
              
              
              <li><a href="/">Accueil</a></li>
              
              
              
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true"
                  aria-expanded="false">Semestre 9 <span class="ion-ios-arrow-down"></span></a>
                <ul class="dropdown-menu">
                  
                  <li><a href="/semestre9/controle">Contrôle commande</a></li>
                  
                  <li><a href="/semestre9/interaction">IHR</a></li>
                  
                  <li><a href="/semestre9/maths">Mathématiques</a></li>
                  
                  <li><a href="/semestre9/modelisation">Modélisation</a></li>
                  
                  <li><a href="/semestre9/mecatronique">Mécatronique</a></li>
                  
                  <li><a href="/semestre9/imagerie">Outils d&#39;imagerie</a></li>
                  
                  <li><a href="/semestre9/energie">Énergétique</a></li>
                  
                </ul>
              </li>
              
              
              
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true"
                  aria-expanded="false">Semestre 8 <span class="ion-ios-arrow-down"></span></a>
                <ul class="dropdown-menu">
                  
                  <li><a href="/semestre8/apptcp-ip">Applications TCP/IP</a></li>
                  
                  <li><a href="/semestre8/complex">Calculabilité</a></li>
                  
                  <li><a href="/semestre8/crypto">Cryptologie</a></li>
                  
                  <li><a href="/semestre8/ia">Intelligence artificielle</a></li>
                  
                  <li><a href="/semestre8/maker">Maker</a></li>
                  
                  <li><a href="/semestre8/qualite">Qualité</a></li>
                  
                  <li><a href="/semestre8/robotique">Robotique</a></li>
                  
                  <li><a href="/semestre8/se">Sys Exploitation</a></li>
                  
                  <li><a href="/semestre8/jeux">Théorie des jeux</a></li>
                  
                  <li><a href="/semestre8/projet">Évaluation des projets</a></li>
                  
                </ul>
              </li>
              
              
              
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true"
                  aria-expanded="false">Semestre 7 <span class="ion-ios-arrow-down"></span></a>
                <ul class="dropdown-menu">
                  
                  <li><a href="/semestre7/compilation/">Compilation</a></li>
                  
                  <li><a href="/semestre7/gl">Génie Logiciel</a></li>
                  
                  <li><a href="/semestre7/poo">POO</a></li>
                  
                  <li><a href="/semestre7/cpp">Programmation C&#43;&#43;</a></li>
                  
                  <li><a href="/semestre7/quantique">Quantique</a></li>
                  
                  <li><a href="/semestre7/bdd">SGBD</a></li>
                  
                  <li><a href="/semestre7/prog_sys/">Système</a></li>
                  
                  <li><a href="/semestre7/tcp">TCP/IP</a></li>
                  
                </ul>
              </li>
              
              
              
              <li><a href="/semestre6/semestre_6">Semestre 6</a></li>
              
              
              
              <li><a href="/contact">Contact</a></li>
              
              
              
              <li><a href="/semestre5/semestre_5">Semestre 5</a></li>
              
              
              
              <li><a href="/cpbx">CPBx</a></li>
              
              

              
            </ul>
          </div>
        </nav>
      </div>
    </div>
  </div>
</header>

<section class="page-title bg-2" style="background-image: url('https://Sdelpeuch.github.io/images/banner/cpp.jpg');">
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        <div class="block">
          <h1>La couche Objet - Partie 3 : opérateurs</h1>
          <p></p>
        </div>
      </div>
    </div>
  </div>
</section>


<section class="page-wrapper">
	<div class="container">
		<div class="row">
			<div class="col-md-8">
				<div class="post post-single">
					<h2 class="post-title">La couche Objet - Partie 3 : opérateurs</h2>
					<div class="post-meta">
						<ul>
              <li><i class="ion-calendar"></i> November 18, 2020</li>
              
              
              
              
              
              
              <li><i class="ion-pricetags"></i> 
                
                <a href="/tags/c&#43;&#43;">C&#43;&#43;</a>
								
              </li>
            </ul>
					</div>
					
					
					
					<div class="post-content post-excerpt">
						<p>Ce cours présente les différents types d&rsquo;opérateurs en C++.</p>
<h3 id="opérateurs-daffectation">Opérateurs d&rsquo;affectation</h3>
<p>Nous avons déjà vu un exemple d&rsquo;opérateur d&rsquo;affectation avec la classe complexe
ci-dessus. Cet opérateur était très simple, mais ce n&rsquo;est généralement pas
toujours le cas, et l&rsquo;implémentation des opérateurs d&rsquo;affectation peut parfois
soulever quelques problèmes.</p>
<p>Premièrement, comme nous l&rsquo;avons dit plus tôt, le fait de définir un opération
d&rsquo;affectation signale souvent que la classe n&rsquo;a pas une structure simple et que,
par conséquent, le constructeur de copie et le destructeur fournis par défaut
par le compilateur ne suffisent pas. Il faut donc veiller à respecter la règle
des trois, qui stipule que si l&rsquo;une de ces méthodes est redéfinie, il faut que
les trois le soient. Par exemple, si vous ne redéfinissez pas le constructeur de
copie, les écritures telles que <code>classe object = source;</code> ne fonctionnement pas
correctement. En effet, c&rsquo;est le constructeur de copie qui est appelé ici, et
non l&rsquo;opérateur d&rsquo;affectation comme on pourrait le penser à première vue. De
même, les traitements particuliers effectués lors de la copie ou de
l&rsquo;initialisation d&rsquo;un objet devront être effectués en ordre inverse dans le
destructeur de l&rsquo;objet. Les traitements de destruction consistent généralement à
libérer la mémoire et toutes les ressources allouées dynamiquement.</p>
<p>Lorsque l&rsquo;on écrit un opérateur d&rsquo;affectation, on a généralement à reproduire, à
peu de choses près, le même code que celui qui se trouve dans le constructeur de
copie. Il arrive même parfois que l&rsquo;on doive libérer les ressources existantes
avant de faire l&rsquo;affectation, et donc le code de l&rsquo;opérateur d&rsquo;affectation
ressemble souvent à la concaténation du code du destructeur et du code du
constructeur de copie. Bien entendu, cette duplication de code est gênante et
peu élégante. Une solution simple est d&rsquo;implémenter une fonction de duplication
et une fonction de libération des données. Ces deux fonctions, par exemple reset
et clone, pourront être utilisées dans le destructeur, le constructeur de copie
et l&rsquo;opérateur d&rsquo;affectation. Le programme devient ainsi beaucoup plus simple.
Il ne faut généralement pas utiliser l&rsquo;opérateur d&rsquo;affectation dans le
constructeur de copie, car cela peut poser des problèmes complexes à résoudre.
Par exemple, il faut s&rsquo;assurer que l&rsquo;opérateur de copie ne cherche pas à
utiliser des données membres non initialisées lors de son appel.</p>
<p>Un autre problème important est celui de l&rsquo;autoaffectation. Non seulement
affecter un objet à lui-même est inutile et consommateur de ressources, mais en
plus cela peut être dangereux. En effet, l&rsquo;affectation risque de détruire les
données membres de l&rsquo;objet avant même qu&rsquo;elles ne soient copiées, ce qui
provoquerait en fin de compte simplement la destruction de l&rsquo;objet ! Une
solution simple consiste ici à ajouter un test sur l&rsquo;objet source en début
d&rsquo;opérateur, comme dans l&rsquo;exemple suivant</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">classe <span style="color:#f92672">&amp;</span>classe<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> classe <span style="color:#f92672">&amp;</span>source)
{
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">&amp;</span>source <span style="color:#f92672">!=</span> <span style="color:#66d9ef">this</span>)
    {
        <span style="color:#75715e">// Traitement de copie des données :
</span><span style="color:#75715e"></span>        ...
    }
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
}
</code></pre></div><p>Enfin, la copie des données peut lancer une exception et laisser l&rsquo;objet sur
lequel l&rsquo;affectation se fait dans un état indéterminé. La solution la plus
simple dans ce cas est encore de construire une copie de l&rsquo;objet source en
local, puis d&rsquo;échanger le contenu des données de l&rsquo;objet avec cette copie.
Ainsi, si la copie échoue pour une raison ou une autre, l&rsquo;objet source n&rsquo;est pas
modifié et reste dans un état stable. Le pseudo-code permettant de réaliser ceci
est le suivant :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">classe <span style="color:#f92672">&amp;</span>classe<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> classe <span style="color:#f92672">&amp;</span>source)
{
    <span style="color:#75715e">// Construit une copie temporaire de la source :
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Temp</span>(source);
    <span style="color:#75715e">// Échange le contenu de cette copie avec l&#39;objet courant :
</span><span style="color:#75715e"></span>    swap(Temp, <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);
    <span style="color:#75715e">// Renvoie l&#39;objet courant (modifié) et détruit les données
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// de la variable temporaire (contenant les anciennes données) :
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
}
</code></pre></div><h3 id="opérateurs-de-transtypage">Opérateurs de transtypage</h3>
<p>Nous avons vu précédemment que les constructeurs peuvent être utilisés pour
convertir des objets du type de leur paramètre vers le type de leur classe. Ces
conversions peuvent avoir lieu de manière implicite ou non, selon que le mot clé
<code>explicit</code> est appliqué au constructeur en question.</p>
<p>Cependant, il n&rsquo;est pas toujours faisable d&rsquo;écrire un tel constructeur. Par
exemple, la classe cible peut parfaitement être une des classes de la
bibliothèque standard, dont on ne doit évidemment pas modifier les fichiers
source, ou même un des types de base du langage, pour lequel il n&rsquo;y a pas de
définition. Heureusement, les conversions peuvent malgré tout être réalisées
dans ce cas, simplement en surchargeant les opérateurs de transtypage.</p>
<p>Prenons l&rsquo;exemple de la classe chaine, qui permet de faire des chaînes de
caractères dynamiques (de longueur variable). Il est possible de les convertir
en chaîne C classiques (c&rsquo;est à dire en tableau de caractères) si l&rsquo;opérateur
(<code>char const *</code>) a été surchargé</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">chaine<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">void</span>) <span style="color:#66d9ef">const</span>;
</code></pre></div><p>On constate que cet opérateur n&rsquo;attend aucun paramètre, puisqu&rsquo;il s&rsquo;applique à
tout l&rsquo;objet qui l&rsquo;appelle, mais surtout il n&rsquo;a pas de type. En effet, puisque
c&rsquo;est un opérateur de transtypage, son type est nécessairement celui qui lui
correspond (dans le cas présent, <code>char const *</code>).</p>
<h3 id="opérateurs-de-comparaison">Opérateurs de comparaison</h3>
<p>Les opérateurs de comparaison sont très simples à surcharger. La seule chose
essentielle à retenir est qu&rsquo;ils renvoient une valeur booléenne. Ainsi, pour la
classe chaine, on peut déclarer les opérateurs d&rsquo;égalité et d&rsquo;infériorité (dans
l&rsquo;ordre lexicographique par exemple) de deux chaînes de caractères comme suit</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">bool</span> chaine<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">==</span>(<span style="color:#66d9ef">const</span> chaine <span style="color:#f92672">&amp;</span>) <span style="color:#66d9ef">const</span>;
<span style="color:#66d9ef">bool</span> chaine<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">const</span> chaine <span style="color:#f92672">&amp;</span>) <span style="color:#66d9ef">const</span>;
</code></pre></div><h3 id="opérateurs-dincrémentation-et-de-décrémentation">Opérateurs d&rsquo;incrémentation et de décrémentation</h3>
<p>Les opérateurs d&rsquo;incrémentation et de décrémentation sont tous les deux doubles,
c&rsquo;est à dire que la même notation représente deux opérateurs en réalité. En
effet, ils n&rsquo;ont pas la même signification, selon qu&rsquo;ils sont placés avant ou
après leur opérande. Le problème est que comme ces opérateurs ne prennent pas de
paramètres (ils ne travaillent que sur l&rsquo;objet), il est impossible de les
différencier par surcharge. La solution qui a été adoptée est de les
différencier en donnant un paramètre fictif de type <code>int</code> à l&rsquo;un d&rsquo;entre eux.
Ainsi les opérateurs <code>++</code> et <code>--</code> ne prennent pas de paramètre lorsqu&rsquo;il s&rsquo;agit
des opérateurs préfixés, et ont un argument fictif (que l&rsquo;on ne doit pas
utiliser) lorsqu&rsquo;ils sont suffixés. Les versions préfixées des opérateurs
doivent renvoyer une référence sur l&rsquo;objet lui-même, les versions suffixées en
revanche peuvent se contenter de renvoyer la valeur de l&rsquo;objet.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Entier</span>
{
    <span style="color:#66d9ef">int</span> i;
 
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Entier(<span style="color:#66d9ef">int</span> j)
    {
        i<span style="color:#f92672">=</span>j;
        <span style="color:#66d9ef">return</span>;
    }
 
    Entier <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>(<span style="color:#66d9ef">int</span>)   <span style="color:#75715e">// Opérateur suffixe :
</span><span style="color:#75715e"></span>    {                        <span style="color:#75715e">// retourne la valeur et incrémente
</span><span style="color:#75715e"></span>        Entier <span style="color:#a6e22e">tmp</span>(i);       <span style="color:#75715e">// la variable.
</span><span style="color:#75715e"></span>        <span style="color:#f92672">++</span>i;
        <span style="color:#66d9ef">return</span> tmp;
    }
 
    Entier <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>(<span style="color:#66d9ef">void</span>) <span style="color:#75715e">// Opérateur préfixe : incrémente
</span><span style="color:#75715e"></span>    {                        <span style="color:#75715e">// la variable et la retourne.
</span><span style="color:#75715e"></span>        <span style="color:#f92672">++</span>i;
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
    }
};
</code></pre></div><h3 id="opérateur-fonctionnel">Opérateur fonctionnel</h3>
<p>L&rsquo;opérateur d&rsquo;appel de fonctions peut également être surchargé. Cet opérateur
permet de réaliser des objets qui se comportent comme des fonctions (ce que l&rsquo;on
appelle foncteurs). La bibliothèque standard C++ en fait un usage intensif,
comme nous pourrons le constater dans la deuxième partie de ce document.</p>
<p>L&rsquo;opérateur fonctionnel est également très utilie en raison de son n-arité. Il
est donc utilisé couramment pour les classes de gestion de matrices de nombres,
afin d&rsquo;autoriser l&rsquo;écriture matrice(i,j,k)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">matrice</span>
{
    <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>ligne;
    ligne <span style="color:#f92672">*</span>lignes;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> n;   <span style="color:#75715e">// Nombre de lignes (1er paramètre).
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> m;   <span style="color:#75715e">// Nombre de colonnes (2ème paramètre).
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    matrice(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> nl, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> nc);
    matrice(<span style="color:#66d9ef">const</span> matrice <span style="color:#f92672">&amp;</span>source);
    <span style="color:#f92672">~</span>matrice(<span style="color:#66d9ef">void</span>);
    matrice <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> matrice <span style="color:#f92672">&amp;</span>m1);
    <span style="color:#66d9ef">double</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span>()(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> j);
    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">operator</span>()(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> j) <span style="color:#66d9ef">const</span>;
};
 
<span style="color:#75715e">// Le constructeur :
</span><span style="color:#75715e"></span>matrice<span style="color:#f92672">::</span>matrice(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> nl, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> nc)
{
    n <span style="color:#f92672">=</span> nl;
    m <span style="color:#f92672">=</span> nc;
    lignes <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ligne[n];
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n; <span style="color:#f92672">++</span>i)
        lignes[i] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span>[m];
    <span style="color:#66d9ef">return</span>;
}
 
<span style="color:#75715e">// Le constructeur de copie :
</span><span style="color:#75715e"></span>matrice<span style="color:#f92672">::</span>matrice(<span style="color:#66d9ef">const</span> matrice <span style="color:#f92672">&amp;</span>source)
{
    m <span style="color:#f92672">=</span> source.m;
    n <span style="color:#f92672">=</span> source.n;
    lignes <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ligne[n];   <span style="color:#75715e">// Alloue.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n; <span style="color:#f92672">++</span>i)
    {
        lignes[i] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span>[m];
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;</span>m; <span style="color:#f92672">++</span>j)  <span style="color:#75715e">// Copie.
</span><span style="color:#75715e"></span>            lignes[i][j] <span style="color:#f92672">=</span> source.lignes[i][j];
    }
    <span style="color:#66d9ef">return</span>;
}
 
<span style="color:#75715e">// Le destructeur :
</span><span style="color:#75715e"></span>matrice<span style="color:#f92672">::~</span>matrice(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n; <span style="color:#f92672">++</span>i)
        <span style="color:#66d9ef">delete</span>[] lignes[i];
    <span style="color:#66d9ef">delete</span>[] lignes;
    <span style="color:#66d9ef">return</span>;
}
 
<span style="color:#75715e">// L&#39;opérateur d&#39;affectation :
</span><span style="color:#75715e"></span>matrice <span style="color:#f92672">&amp;</span>matrice<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> matrice <span style="color:#f92672">&amp;</span>source)
{
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">&amp;</span>source <span style="color:#f92672">!=</span> <span style="color:#66d9ef">this</span>)
    {
        <span style="color:#66d9ef">if</span> (source.n<span style="color:#f92672">!=</span>n <span style="color:#f92672">||</span> source.m<span style="color:#f92672">!=</span>m)   <span style="color:#75715e">// Vérifie les dimensions.
</span><span style="color:#75715e"></span>        {
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n; <span style="color:#f92672">++</span>i)
                <span style="color:#66d9ef">delete</span>[] lignes[i];
            <span style="color:#66d9ef">delete</span>[] lignes;              <span style="color:#75715e">// Détruit...
</span><span style="color:#75715e"></span>            m <span style="color:#f92672">=</span> source.m;
            n <span style="color:#f92672">=</span> source.n;
            lignes <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ligne[n];        <span style="color:#75715e">// et réalloue.
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n; <span style="color:#f92672">++</span>i) lignes[i] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span>[m];
        }
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n; <span style="color:#f92672">++</span>i) <span style="color:#75715e">// Copie.
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;</span>m; <span style="color:#f92672">++</span>j)
                lignes[i][j] <span style="color:#f92672">=</span> source.lignes[i][j];
    }
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
}
 
<span style="color:#75715e">// Opérateurs d&#39;accès :
</span><span style="color:#75715e"></span><span style="color:#66d9ef">double</span> <span style="color:#f92672">&amp;</span>matrice<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span>()(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> i,
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> j)
{
    <span style="color:#66d9ef">return</span> lignes[i][j];
}
 
<span style="color:#66d9ef">double</span> matrice<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span>()(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> i,
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> j) <span style="color:#66d9ef">const</span>
{
    <span style="color:#66d9ef">return</span> lignes[i][j];
}
</code></pre></div><p>Ainsi, on pourra effectuer la déclaration d&rsquo;une matrice avec <code>matrice m(2,3);</code>
et accéder à ses éléments simplement avec <code>m(i,j)=6;</code>. On remarquera que l&rsquo;on a
défini deux opérateurs fonctionnels dans l&rsquo;exemple donné ci-dessus. Le premier
renvoie une référence et permet de modifier la valeur d&rsquo;un des éléments de la
matrice. Cet opérateur ne peut bien entendu pas s&rsquo;appliquer à une matrice
constante, même simplement pour lire un élément. C&rsquo;est donc le deuxième
opérateur qui sera utilisé pour lire les éléments des matrices constantes, car
il renvoie une valeur et non plus une référence. Le choix de l&rsquo;opérateur à
utiliser est déterminé par la présence du mot clé <code>const</code>, qui indique que seul
cet opérateur peut être utilisé pour une matrice constante.</p>
<h3 id="opérateurs-dindirection-et-de-déréférencement">Opérateurs d&rsquo;indirection et de déréférencement</h3>
<p>L&rsquo;opérateur de déréférencement * permet l&rsquo;écriture de classes dont les objets peuvent être utilisés dans des expressions manipulant des pointeurs. L&rsquo;opérateur d&rsquo;indirection &amp; quant à lui, permet de renvoyer une adresse autre que celle de l&rsquo;objet sur lequel il s&rsquo;applique. Enfin, l&rsquo;opérateur de déréférencement et de sélection de membres de structures -&gt; permet de réaliser des classes qui encapsulent d&rsquo;autres classes.</p>
<p>Si les opérateurs de déréférencement et d&rsquo;indirection &amp; et * peuvent renvoyer
une valeur de type quelconque, ce n&rsquo;est pas le cas de l&rsquo;opérateur de
déréférencement et de sélection de membre -&gt;. Cet opérateur doit nécessairement
renvoyer un type pour lequel il doit encore être applicable. Ce type doit donc
soit surcharger l&rsquo;opérateur -&gt;, soit être un pointeur sur une structure, union
ou classe.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// Cette classe est encapsulée par une autre classe :
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Encapsulee</span>
{
    <span style="color:#66d9ef">int</span> i;       <span style="color:#75715e">// Donnée à accéder.
</span><span style="color:#75715e"></span>};
 
Encapsulee o;    <span style="color:#75715e">// Objet à manipuler.
</span><span style="color:#75715e"></span> 
<span style="color:#75715e">// Cette classe est la classe encapsulante :
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Encapsulante</span>
{
    Encapsulee <span style="color:#f92672">*</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">-&gt;</span>(<span style="color:#66d9ef">void</span>) <span style="color:#66d9ef">const</span>
    {
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>o;
    }
 
    Encapsulee <span style="color:#f92672">*</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">&amp;</span>(<span style="color:#66d9ef">void</span>) <span style="color:#66d9ef">const</span>
    {
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>o;
    }
 
    Encapsulee <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>(<span style="color:#66d9ef">void</span>) <span style="color:#66d9ef">const</span>
    {
        <span style="color:#66d9ef">return</span> o;
    }
};
 
<span style="color:#75715e">// Exemple d&#39;utilisation :
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">int</span> i)
{
    Encapsulante e;
    e<span style="color:#f92672">-&gt;</span>i<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;         <span style="color:#75715e">// Enregistre 2 dans o.i.
</span><span style="color:#75715e"></span>    (<span style="color:#f92672">*</span>e).i <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;     <span style="color:#75715e">// Enregistre 3 dans o.i.
</span><span style="color:#75715e"></span>    Encapsulee <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>e;
    p<span style="color:#f92672">-&gt;</span>i <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;       <span style="color:#75715e">// Enregistre 4 dans o.i.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> ;
}
</code></pre></div><h3 id="opérateurs-dallocation-dynamique-de-mémoire">Opérateurs d&rsquo;allocation dynamique de mémoire</h3>
<p>Les opérateurs les plus difficiles à écrire sont sans doute les opérateurs d&rsquo;allocation dynamique de mémoire. Ces opérateurs prennent un nombre variable de paramètres, parce qu&rsquo;ils sont complètement surchargeables (c&rsquo;est à dire qu&rsquo;il est possible de définir plusieurs surcharges de ces opérateurs même au sein d&rsquo;une même classe, s&rsquo;ils sont définis de manière interne). Il est donc possible de définir plusieurs opérateurs new ou new[], et plusieurs opérateurs delete ou delete[]. Cependant, les premiers paramètres de ces opérateurs doivent toujours être la taille de la zone de la mémoire à allouer dans le cas des opérateurs new et new[], et le pointeur sur la zone de la mémoire à restituer dans le cas des opérateurs delete et delete[].</p>
<p>La forme la plus simple de new ne prend qu&rsquo;un paramètre : le nombre d&rsquo;octets à allouer, qui vaut toujours la taille de l&rsquo;objet à construire. Il doit renvoyer un pointeur du type void. L&rsquo;opérateur delete correspondant peut prendre, quant à lui, soit un, soit deux paramètres. Comme on l&rsquo;a déjà dit, le premier paramètre est toujours un pointeur du type void sur l&rsquo;objet à détruire. Le deuxième paramètre, s&rsquo;il existe, est du type size_t et contient la taille de l&rsquo;objet à détruire. Les mêmes règles s&rsquo;appliquent pour les opérateurs new[] et delete[], utilisés pour les tableaux.</p>
<p>Lorsque les opérateurs delete et delete[] prennent deux paramètres, le deuxième paramètre est la taille de la zone de la mémoire à restituer. Cela signifie que le compilateur se charge de mémoriser cette information. Pour les opérateurs new et delete, cela ne cause pas de problème, puisque la taille de cette zone est fixée par le type de l&rsquo;objet. En revanche, pour les tableaux, la taille du tableau doit être stockée avec le tableau. En général, le compilateur utilise un en-tête devant le tableau d&rsquo;objets. C&rsquo;est pour cela que la taille à allouer passée à new[], qui est la même que la taille à désallouer passée en paramètre à delete[], n&rsquo;est pas égale à la taille d&rsquo;un objet multipliée par le nombre d&rsquo;objets du tableau. Le compilateur demande un peu plus de mémoire, pour mémoriser la taille du tableau. On ne peut donc pas, dans ce cas, faire d&rsquo;hypothèses quant à la structure que le compilateur donnera à la mémoire allouée pour stocker le tableau.</p>
<p>En revanche, si delete[] ne prend en paramètre que le pointeur sur le tableau,
la mémorisation de la taille du tableau est à la charge du programmeur. Dans ce
cas, le compilateur donne à new[] la valeur exacte de la taille du tableau, à
savoir la taille d&rsquo;un objet multipliée par le nombre d&rsquo;objets dans le tableau.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">int</span> buffer[<span style="color:#ae81ff">256</span>];     <span style="color:#75715e">// Buffer servant à stocker le tableau.
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Temp</span>
{
    <span style="color:#66d9ef">char</span> i[<span style="color:#ae81ff">13</span>];      <span style="color:#75715e">// sizeof(Temp) doit être premier.
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>[](size_t taille)
    {
       <span style="color:#66d9ef">return</span> buffer;
    }
 
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">delete</span>[](<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>p, size_t taille)
    {
       printf(<span style="color:#e6db74">&#34;Taille de l&#39;en-tête : %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
           taille<span style="color:#f92672">-</span>(taille<span style="color:#f92672">/</span><span style="color:#66d9ef">sizeof</span>(Temp))<span style="color:#f92672">*</span><span style="color:#66d9ef">sizeof</span>(Temp));
       <span style="color:#66d9ef">return</span> ;
    }
};
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#66d9ef">delete</span>[] <span style="color:#66d9ef">new</span> Temp[<span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Il est à noter qu&rsquo;aucun des opérateurs new, delete, new[] et delete[] ne reçoit le pointeur this en paramètre : ce sont des opérateurs statiques. Cela est normal puisque, lorsqu&rsquo;ils s&rsquo;exécutent, soit l&rsquo;objet n&rsquo;est pas encore créé, soit il est déjà détruit. Le pointeur this n&rsquo;existe donc pas encore (ou n&rsquo;est plus valide) lors de l&rsquo;appel de ces opérateurs.</p>
<p>Les opérateurs new et new[] peuvent avoir une forme encore un peu plus compliquée, qui permet de leur passer des paramètres lors de l&rsquo;allocation de la mémoire. Les paramètres supplémentaires doivent impérativement être les paramètres deux et suivants, puisque le premier paramètre indique toujours la taille de la zone de mémoire à allouer.</p>
<p>Comme le premier paramètre est calculé par le compilateur, il n&rsquo;y a pas de syntaxe permettant de le passer aux opérateurs new et new[]. En revanche, une syntaxe spéciale est nécessaire pour passer les paramètres supplémentaires. Cette syntaxe est détaillée ci-dessous.</p>
<p>Si l&rsquo;opérateur new est déclaré de la manière suivante dans la classe classe :</p>
<p>static void *operator new(size_t taille, paramètres);</p>
<p>où taille est la taille de la zone de mémoire à allouer et paramètres la liste
des paramètres additionnels, alors on doit l&rsquo;appeler avec la syntaxe
<code>new(paramètres classes);</code></p>
<p>Les paramètres sont donc passés entre parenthèses comme pour une fonction normale. Le nom de la fonction est new, et le nom de la classe suit l&rsquo;expression new comme dans la syntaxe sans paramètres. Cette utilisation de new est appelée new avec placement.</p>
<p>Le placement est souvent utilisé afin de réaliser des réallocations de mémoire d&rsquo;un objet à un autre. Par exemple, si l&rsquo;on doit détruire un objet alloué dynamiquement et en reconstruire immédiatement un autre du même type, les opérations suivantes se déroulent :</p>
<ol>
<li>appel du destructeur de l&rsquo;objet (réalisé par l&rsquo;expression delete) ;</li>
<li>appel de l&rsquo;opérateur delete ;</li>
<li>appel de l&rsquo;opérateur new ;</li>
<li>appel du constructeur du nouvel objet (réalisé par l&rsquo;expression new).</li>
</ol>
<p>Cela n&rsquo;est pas très efficace, puisque la mémoire est restituée pour être allouée de nouveau immédiatement après. Il est beaucoup plus logique de réutiliser la mémoire de l&rsquo;objet à détruire pour le nouvel objet, et de reconstruire ce dernier dans cette mémoire. Cela peut se faire comme suit :</p>
<ol>
<li>appel explicite du destructeur de l&rsquo;objet à détruire ;</li>
<li>appel de new avec comme paramètre supplémentaire le pointeur sur l&rsquo;objet détruit ;</li>
<li>appel du constructeur du deuxième objet (réalisé par l&rsquo;expression new).</li>
</ol>
<p>L&rsquo;appel de new ne fait alors aucune allocation : on gagne ainsi beaucoup de
temps.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    A(<span style="color:#66d9ef">void</span>)           <span style="color:#75715e">// Constructeur.
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">return</span> ;
    }
 
    <span style="color:#f92672">~</span>A(<span style="color:#66d9ef">void</span>)          <span style="color:#75715e">// Destructeur.
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">return</span> ;
    }
 
    <span style="color:#75715e">// L&#39;opérateur new suivant utilise le placement.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Il reçoit en paramètre le pointeur sur le bloc
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// à utiliser pour la requête d&#39;allocation dynamique
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// de mémoire.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span> (size_t taille, A <span style="color:#f92672">*</span>bloc)
    {
        <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) bloc;
    }
 
    <span style="color:#75715e">// Opérateur new normal :
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(size_t taille)
    {
        <span style="color:#75715e">// Implémentation :
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> malloc(taille);
    }
 
    <span style="color:#75715e">// Opérateur delete normal :
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>pBlock)
    {
        free(pBlock);
        <span style="color:#66d9ef">return</span> ;
    }
};
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
    A <span style="color:#f92672">*</span>pA<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> A;      <span style="color:#75715e">// Création d&#39;un objet de classe A.
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// L&#39;opérateur new global du C++ est utilisé.
</span><span style="color:#75715e"></span>    pA<span style="color:#f92672">-&gt;~</span>A();         <span style="color:#75715e">// Appel explicite du destructeur de A.
</span><span style="color:#75715e"></span>    A <span style="color:#f92672">*</span>pB<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span>(pA) A;  <span style="color:#75715e">// Réutilisation de la mémoire de A.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">delete</span> pB;        <span style="color:#75715e">// Destruction de l&#39;objet.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Dans cet exemple, la gestion de la mémoire est réalisée par les opérateurs new
et delete normaux. Cependant, la réutilisation de la mémoire allouée se fait
grâce à un opérateur new avec placement, défini pour l&rsquo;occasion. Ce dernier ne
fait strictement rien d&rsquo;autre que de renvoyer le pointeur qu&rsquo;on lui a passé en
paramètre. On notera qu&rsquo;il est nécessaire d&rsquo;appeler explicitement le destructeur
de la classe A avant de réutiliser la mémoire de l&rsquo;objet, car aucune expression
delete ne s&rsquo;en charge avant la réutilisation de la mémoire.</p>
<p>Il est impossible de passer des paramètres à l&rsquo;opérateur delete dans une
expression delete. Cela est dû au fait qu&rsquo;en général on ne connaît pas le
contexte de la destruction d&rsquo;un objet (alors qu&rsquo;à l&rsquo;allocation, on connaît le
contexte de création de l&rsquo;objet). Normalement, il ne peut donc y avoir qu&rsquo;un
seul opérateur delete. Cependant, il existe un cas où l&rsquo;on connaît le contexte
de l&rsquo;appel de l&rsquo;opérateur delete : c&rsquo;est le cas où le constructeur de la classe
lance une exception (voir le Chapitre 9 pour plus de détails à ce sujet). Dans
ce cas, la mémoire allouée par l&rsquo;opérateur new doit être restituée et
l&rsquo;opérateur delete est automatiquement appelé, puisque l&rsquo;objet n&rsquo;a pas pu être
construit. Afin d&rsquo;obtenir un comportement symétrique, il est permis de donner
des paramètres additionnels à l&rsquo;opérateur delete. Lorsqu&rsquo;une exception est
lancée dans le constructeur de l&rsquo;objet alloué, l&rsquo;opérateur delete appelé est
l&rsquo;opérateur dont la liste des paramètres correspond à celle de l&rsquo;opérateur new
qui a été utilisé pour créer l&rsquo;objet. Les paramètres passés à l&rsquo;opérateur delete
prennent alors exactement les mêmes valeurs que celles qui ont été données aux
paramètres de l&rsquo;opérateur new lors de l&rsquo;allocation de la mémoire de l&rsquo;objet.
Ainsi, si l&rsquo;opérateur new a été utilisé sans placement, l&rsquo;opérateur delete sans
placement sera appelé. En revanche, si l&rsquo;opérateur new a été appelé avec des
paramètres, l&rsquo;opérateur delete qui a les mêmes paramètres sera appelé. Si aucun
opérateur delete ne correspond, aucun opérateur delete n&rsquo;est appelé (si
l&rsquo;opérateur new n&rsquo;a pas alloué de mémoire, cela n&rsquo;est pas grave, en revanche, si
de la mémoire a été allouée, elle ne sera pas restituée). Il est donc important
de définir un opérateur delete avec placement pour chaque opérateur new avec
placement défini. L&rsquo;exemple précédent doit donc être réécrit de la manière
suivante :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> bThrow <span style="color:#f92672">=</span> false;
 
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    A(<span style="color:#66d9ef">void</span>)           <span style="color:#75715e">// Constructeur.
</span><span style="color:#75715e"></span>    {
        <span style="color:#75715e">// Le constructeur est susceptible
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// de lancer une exception :
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (bThrow) <span style="color:#66d9ef">throw</span> <span style="color:#ae81ff">2</span>;
        <span style="color:#66d9ef">return</span> ;
    }
 
    <span style="color:#f92672">~</span>A(<span style="color:#66d9ef">void</span>)          <span style="color:#75715e">// Destructeur.
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">return</span> ;
    }
 
    <span style="color:#75715e">// L&#39;opérateur new suivant utilise le placement.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Il reçoit en paramètre le pointeur sur le bloc
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// à utiliser pour la requête d&#39;allocation dynamique
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// de mémoire.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span> (size_t taille, A <span style="color:#f92672">*</span>bloc)
    {
        <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) bloc;
    }
 
    <span style="color:#75715e">// L&#39;opérateur delete suivant est utilisé dans les expressions
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// qui utilisent l&#39;opérateur new avec placement ci-dessus,
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// si une exception se produit dans le constructeur.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>p, A <span style="color:#f92672">*</span>bloc)
    {
        <span style="color:#75715e">// On ne fait rien, parce que l&#39;opérateur new correspondant
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// n&#39;a pas alloué de mémoire.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> ;
    }
 
    <span style="color:#75715e">// Opérateur new et delete normaux :
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(size_t taille)
    {
        <span style="color:#66d9ef">return</span> malloc(taille);
    }
 
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>pBlock)
    {
        free(pBlock);
        <span style="color:#66d9ef">return</span> ;
    }
};
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
    A <span style="color:#f92672">*</span>pA<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> A;      <span style="color:#75715e">// Création d&#39;un objet de classe A.
</span><span style="color:#75715e"></span>    pA<span style="color:#f92672">-&gt;~</span>A();         <span style="color:#75715e">// Appel explicite du destructeur de A.
</span><span style="color:#75715e"></span>    bThrow <span style="color:#f92672">=</span> true;    <span style="color:#75715e">// Maintenant, le constructeur de A lance
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// une exception.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">try</span>
    {
        A <span style="color:#f92672">*</span>pB<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span>(pA) A;  <span style="color:#75715e">// Réutilisation de la mémoire de A.
</span><span style="color:#75715e"></span>                          <span style="color:#75715e">// Si une exception a lieu, l&#39;opérateur
</span><span style="color:#75715e"></span>                          <span style="color:#75715e">// delete(void *, A *) avec placement
</span><span style="color:#75715e"></span>                          <span style="color:#75715e">// est utilisé.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">delete</span> pB;        <span style="color:#75715e">// Destruction de l&#39;objet.
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">catch</span> (...)
    {
        <span style="color:#75715e">// L&#39;opérateur delete(void *, A *) ne libère pas la mémoire
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// allouée lors du premier new. Il faut donc quand même
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// le faire, mais sans delete, car l&#39;objet pointé par pA
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// est déjà détruit, et celui pointé par pB l&#39;a été par
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// l&#39;opérateur delete(void *, A *) :
</span><span style="color:#75715e"></span>        free(pA);
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Quelle que soit la syntaxe que vous désirez utiliser, les opérateurs new, new[], delete et delete[] doivent avoir un comportement bien déterminé. En particulier, les opérateurs delete et delete[] doivent pouvoir accepter un pointeur nul en paramètre. Lorsqu&rsquo;un tel pointeur est utilisé dans une expression delete, aucun traitement ne doit être fait.</p>

					</div>
					<div class="post-comments">
						
					</div>
				</div>
			</div>
      <div class="col-md-4">
        <aside class="sidebar">



















































<div class="widget widget-latest-post">
    <h4 class="widget-title">Derniers cours</h4>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/semestre9/modelisation/1/">Mouvements, changements de coordonnées</a></h4>
        <h5>[Modélisation]</h5>
        <p>Repère affine $[O_i, R_i = {x_i, y_i z_i}]$ Une …</p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/semestre9/interaction/1/">Introduction à la cobotique</a></h4>
        <h5>[Interactions homme robot]</h5>
        <p>Introduction Pourquoi fait on de la robotique ? …</p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/semestre9/imagerie/1/">Introduction</a></h4>
        <h5>[Outils d&#39;imagerie]</h5>
        <p>Commençons par définir les différents termes que …</p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/semestre9/se/1/">Architecture</a></h4>
        <h5>[Système embarqués]</h5>
        <p>Programmer un microcontrolleur Un microcontrolleur …</p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/semestre9/se/2/">Bus de communication</a></h4>
        <h5>[Système embarqués]</h5>
        <p></p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/semestre9/maths/1/">Modélisation</a></h4>
        <h5>[Maths]</h5>
        <p>À partir d&rsquo;une position initiale, le robot …</p>
      </div>
    </div>
    
  </div>
</aside>


      </div>
		</div>
	</div>
</section>

<footer class="footer">
	<div class="container">
		<div class="row">
			<div class="col-md-12">
				<div class="footer-manu">
					<ul>
            
            <li><a href="https://Sdelpeuch.github.io/semestre9">Semestre 9</a></li>
            
            <li><a href="https://Sdelpeuch.github.io/about">Semestre 8</a></li>
            
            <li><a href="https://Sdelpeuch.github.io/about">Semestre 7</a></li>
            
            <li><a href="https://Sdelpeuch.github.io/contact">Semestre 6</a></li>
            
            <li><a href="https://Sdelpeuch.github.io/project">Semestre 5</a></li>
            
            <li><a href="https://Sdelpeuch.github.io/cpbx">CPBx</a></li>
            
					</ul>
				</div>
				<p class="copyright">Copyright © 2020 <a href="https://themefisher.com">Themefisher</a> All Rights Reserved</p>
			</div>
		</div>
	</div>
</footer>



<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCcABaamniA6OL5YvYSpB3pFMNrXwXnLwU&amp;libraries=places"></script>




<script src="https://Sdelpeuch.github.io/plugins/jQuery/jquery.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/bootstrap/bootstrap.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/slick/slick.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/magnific-popup/jquery.magnific-popup.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/shuffle/shuffle.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/google-map/gmap.js"></script>




<script src="https://Sdelpeuch.github.io/js/script.min.js"></script>







<script src="https://cdnjs.cloudflare.com/ajax/libs/js-cookie/2.2.1/js.cookie.min.js"></script>
<div id="js-cookie-box" class="cookie-box cookie-box-hide">
	This site uses cookies. By continuing to use this website, you agree to their use. <span id="js-cookie-button" class="btn btn-main btn-solid-border">I Accept</span>
</div>
<script>
	(function ($) {
		const cookieBox = document.getElementById('js-cookie-box');
		const cookieButton = document.getElementById('js-cookie-button');
		if (!Cookies.get('cookie-box')) {
			cookieBox.classList.remove('cookie-box-hide');
			cookieButton.onclick = function () {
				Cookies.set('cookie-box', true, {
					expires:  2 
				});
				cookieBox.classList.add('cookie-box-hide');
			};
		}
	})(jQuery);
</script>


<style>
.cookie-box {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  text-align: center;
  z-index: 9999;
  padding: 1rem 2rem;
  background: rgb(71, 71, 71);
  transition: all .75s cubic-bezier(.19, 1, .22, 1);
  color: #fdfdfd;
}

.cookie-box-hide {
  display: none;
}
</style>
</body>

</html>