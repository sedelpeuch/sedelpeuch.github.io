<!DOCTYPE html>
<html lang="en-Us"><head>
  <meta charset="utf-8">
  <title>Les templates</title>

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Semestre 7 de l&#39;ENSEIRB-MATEMECA">
  <meta name="author" content="Sébastien">
  <meta name="generator" content="Hugo 0.74.3" />

  <!-- plugins -->
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/plugins/bootstrap/bootstrap.min.css">
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/plugins/Ionicons/css/ionicons.min.css">
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/plugins/magnific-popup/magnific-popup.css">
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/plugins/slick/slick.css">
  

  <!-- Main Stylesheet -->
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/scss/style.min.css" media="screen">

  <!--Favicon-->
  <link rel="shortcut icon" href="https://Sdelpeuch.github.io/images/favicon.png" type="image/x-icon">
  <link rel="icon" href="https://Sdelpeuch.github.io/images/favicon.png" type="image/x-icon">

</head><body>
<!-- preloader start -->
<div class="preloader">
  
</div>
<!-- preloader end -->

<header class="navigation">
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        
        <nav class="navbar">
          
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navigation">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">
              <img src="https://Sdelpeuch.github.io/images/telechargement.png" alt="Semestre 8" width="65px" class="img-responsive">
            </a>
          </div>
          
          <div class="collapse navbar-collapse" id="navigation">
            <ul class="nav navbar-nav navbar-right">
              
              
              <li><a href="/">Accueil</a></li>
              
              
              
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true"
                  aria-expanded="false">Semestre 8 <span class="ion-ios-arrow-down"></span></a>
                <ul class="dropdown-menu">
                  
                  <li><a href="/semestre8/apptcp-ip">Applications TCP/IP</a></li>
                  
                  <li><a href="/semestre8/complex">Calculabilité</a></li>
                  
                  <li><a href="/semestre8/crypto">Cryptologie</a></li>
                  
                  <li><a href="/semestre8/ia">Intelligence artificielle</a></li>
                  
                  <li><a href="/semestre8/maker">Maker</a></li>
                  
                  <li><a href="/semestre8/robotique">Robotique</a></li>
                  
                  <li><a href="/semestre8/se">Sys Exploitation</a></li>
                  
                  <li><a href="/semestre8/jeux">Théorie des jeux</a></li>
                  
                </ul>
              </li>
              
              
              
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true"
                  aria-expanded="false">Semestre 7 <span class="ion-ios-arrow-down"></span></a>
                <ul class="dropdown-menu">
                  
                  <li><a href="/semestre7/compilation/">Compilation</a></li>
                  
                  <li><a href="/semestre7/gl">Génie Logiciel</a></li>
                  
                  <li><a href="/semestre7/poo">POO</a></li>
                  
                  <li><a href="/semestre7/cpp">Programmation C&#43;&#43;</a></li>
                  
                  <li><a href="/semestre7/quantique">Quantique</a></li>
                  
                  <li><a href="/semestre7/bdd">SGBD</a></li>
                  
                  <li><a href="/semestre7/prog_sys/">Système</a></li>
                  
                  <li><a href="/semestre7/tcp">TCP/IP</a></li>
                  
                </ul>
              </li>
              
              
              
              <li><a href="/semestre6/semestre_6">Semestre 6</a></li>
              
              
              
              <li><a href="/semestre5/semestre_5">Semestre 5</a></li>
              
              
              
              <li><a href="/contact">Contact</a></li>
              
              
              
              <li><a href="/cpbx">CPBx</a></li>
              
              

              
            </ul>
          </div>
        </nav>
      </div>
    </div>
  </div>
</header>

<section class="page-title bg-2" style="background-image: url('https://Sdelpeuch.github.io/images/banner/cpp.jpg');">
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        <div class="block">
          <h1>Les templates</h1>
          <p></p>
        </div>
      </div>
    </div>
  </div>
</section>


<section class="page-wrapper">
	<div class="container">
		<div class="row">
			<div class="col-md-8">
				<div class="post post-single">
					<h2 class="post-title">Les templates</h2>
					<div class="post-meta">
						<ul>
              <li><i class="ion-calendar"></i> December 7, 2020</li>
              
              
              
              
              
              
              <li><i class="ion-pricetags"></i> 
                
                <a href="/tags/c&#43;&#43;">C&#43;&#43;</a>
								
              </li>
            </ul>
					</div>
					
					
					
					<div class="post-content post-excerpt">
						<h2 id="généralités">Généralités</h2>
<p>Nous avons vu précédemment comment réaliser des structures de données
relativement indépendantes de la classe de leurs données (c&rsquo;est à dire leur
type) avec les classes abstraites. Par ailleurs, il est faisable de faire des
fonctions travaillant sur de nombreux types grâce à la surcharge. Rappelons
qu&rsquo;en C++, tous les types sont en fait des classes.</p>
<p>Cependant, l&rsquo;emploi des classes abstraites est assez fastidieux et a
l&rsquo;inconvénient d&rsquo;affaiblir le contrôle des types réalisé par le compilateur. De
plus, la surcharge n&rsquo;est pas généralisable pour tous les types de données. Il
serait possible d&rsquo;utiliser des macros pour faire des fonctions atypiques mais
cela serait au détriment de la taille du code.</p>
<p>Le C++ permet de résoudre ces problèmes grâce aux paramètres génériques, que
l&rsquo;on appelle encore paramètre template. Un paramètre template est soit un type
générique, soit une constante dont le type est assimilable à un type intégral.
Comme leur nom l&rsquo;indique, les paramètres template permettent de paramétrer la
définition des fonctions et des classes. Les fonctions et les classes ainsi
paramétrées sont appelées respectivement fonctions template et classes template.</p>
<p>LEs fonctions template sont donc des fonctions qui peuvent travailler sur des
objets dont le type est un type générique (c&rsquo;est à dire un type quelconque), ou
qui peuvent êtres paramétrés par une constante de type intégral. Les classes
template sont des classes qui contiennent des membres dont le type est générique
ou qui dépendent d&rsquo;un paramètre intégral.</p>
<p>En général, la génération du code a lieu lors d&rsquo;une opération au cours de
laquelle les types génériques sont remplacés par des vrais types et les
paramètres de type intégral prennent leur valeur. Cette opération s&rsquo;appelle
l&rsquo;instanciation des template. Elle a lieu lorsqu&rsquo;on utilise une fonction ou la
classe template pour la première fois. Les types réels à utiliser à la place des
types génériques sont déterminés lors de cette première utilisation par le
compilateur, soit implicitement à partir du contexte d&rsquo;utilisation du template,
soit par les paramètres donnés explicitement par le programmeur.</p>
<h2 id="déclaration-des-paramètres-template">Déclaration des paramètres template</h2>
<p>Les paramètres template sont, comme on l&rsquo;a vu, soit des types génériques, soit
des constantes dont le type peut être assimilé à un type intégral.</p>
<h3 id="déclaration-des-types-template">Déclaration des types template</h3>
<p>Les template qui sont des types génériques sont déclarés par la syntaxe
suivante</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">|</span><span style="color:#a6e22e">typename</span> nom[<span style="color:#f92672">=</span>type]
         [, <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">|</span><span style="color:#a6e22e">typename</span> nom[<span style="color:#f92672">=</span>type]
         [...]<span style="color:#f92672">&gt;</span>
</code></pre></div><p>où nom est le nom que l&rsquo;on donne au type générique dans cette déclaration. Le
mot clé class a ici exactement la signification de &ldquo;type&rdquo;. Il peut d&rsquo;ailleurs
être remplacé indifféremment dans cette syntaxe par le mot clé typename. La même
déclaration peut être utilisée pour déclarer un nombre arbitraire de types
génériques, en les séparant par des virgules. Les paramètres template qui sont
des types peuvent prendre des valeurs par défaut, en faisant suivre le nom du
paramètre d&rsquo;un signe égale et de la valeur. Ici, la valeur par défaut doit
évidemment être un type déjà déclaré.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>, <span style="color:#66d9ef">typename</span> U, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">V</span><span style="color:#f92672">=</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>
</code></pre></div><p>Dans cet exemple, T, U et V sont des types génériques. Ils peuvent remplacer
n&rsquo;importe quel type de langage déjà déclaré au moment où la déclaration template
est faite. De plus, le type générique V a pour valeur par défaut le type entier
<code>int</code>. On voit bien dans cet exemple que les mots clés <code>typename</code> et <code>class</code>
peuvent être utilisés indifféremment.</p>
<p>Lorsqu&rsquo;on donne des valeurs par défaut à un type générique, on doit donner des
valeurs par défaut à tous les types génériques qui le suivent dans la
déclaration <code>template</code>. La ligne suivante provoquera donc une erreur de
compilation <code>template &lt;class T=int, class V&gt;</code>.</p>
<p>Ils est possible d&rsquo;utiliser une classe template en tant que type générique. Dans
ce cas, la classe doit être déclarée comme étant template à l&rsquo;intérieur même de
la déclaration <code>template</code>. La syntaxe est donc la suivante</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Type</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Classe</span> [,...]<span style="color:#f92672">&gt;</span>
</code></pre></div><p>où <code>Type</code> est le type générique utilisé dans la déclaration de la classe
<code>template</code> Classe. On appelle les paramètres <code>template</code> qui sont des classes
<code>template</code> des paramètres <code>template template</code>. Rien n&rsquo;interdit de donner une
valeur par défaut à un paramètre <code>template template</code> : le type utilisé doit
alors être une classe <code>template</code> déclarée avec la déclaration <code>template</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Tableau</span>
{
    <span style="color:#75715e">// Définition de la classe template Tableau.
</span><span style="color:#75715e"></span>};
 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">U</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">V</span>, <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span><span style="color:#f92672">=</span>Tableau<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dictionnaire</span>
{
    C<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> Clef;
    C<span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> Valeur;
    <span style="color:#75715e">// Reste de la définition de la classe Dictionnaire.
</span><span style="color:#75715e"></span>};
</code></pre></div><p>Dans cet exemple, la classe <code>template</code> Dictionnaire permet de relier des clés à
leurs éléments. Ces clés et ces valeurs peuvent prendre n&rsquo;importe quel type. Les
clés et les valeurs stockées parallèlement dans les membres Clef et Valeur. Ces
membres sont en fait des conteneurs <code>template</code>, dont la classe est générique et
désignée par le paramètre <code>template template</code> C. Le paramètre <code>template</code> de C
est utilisé pour donner le type des données stockées, à savoir les types
génériques U et V dans le cas de la classe Dictionnaire. Enfin, la classe
Dictionnaire peut utiliser un conteneur par défaut, qui est la classe <code>template</code>
Tableau.</p>
<h3 id="déclaration-des-constantes-template">Déclaration des constantes template</h3>
<p>La déclaration des paramètres de <code>type</code> constante se fait de la manière suivante</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>type paramètre[<span style="color:#f92672">=</span>valeur][,...]<span style="color:#f92672">&gt;</span>
</code></pre></div><p>où type est le type du paramètre constant, paramètre est le nom du paramètre et
valeur est sa valeur par défaut. Il est possible de donner des paramètres
template qui sont des types génériques et des paramètres template qui sont des
constantes dans la même déclaration.</p>
<p>Le type des constantes template doit obligatoirement être l&rsquo;un des types
suivants</p>
<ul>
<li>type intégral ou énuméré</li>
<li>pointeur ou référence d&rsquo;objet</li>
<li>pointeur ou référence de fonction</li>
<li>pointeur sur membre</li>
</ul>
<p>Ce sont donc tous les types qui peuvent être assimilés à des valeurs entière
(entier, énumérés ou adresses).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>, <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>f)(<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&gt;</span>
</code></pre></div><p>Cette déclaration template comprend un type générique T, une constante template
<code>i</code> de type int, et une constante template <code>f</code> de type pointeur sur fonction
prenant un entier en paramètre et ne renvoyant rien.</p>
<h2 id="fonctions-et-classes-template">Fonctions et classes template</h2>
<p>Après la déclaration d&rsquo;un ou de plusieurs paramètres template suit en général la
déclaration ou la définition d&rsquo;une fonction ou d&rsquo;une classe template. Dans cette
définition, les types génériques peuvent être utilisés exactement comme s&rsquo;il
s&rsquo;agissait de types normaux. Les constantes template peuvent être utilisées pour
la fonction ou la classe template comme des constantes locales.</p>
<h3 id="fonctions-template">Fonctions template</h3>
<p>La déclaration et la définition des fonctions template se fait exactement comme
s&rsquo;il s&rsquo;agissait de types normaux, à ceci près qu&rsquo;elle doit être précédée de la
déclaration des paramètres template. La syntaxe d&rsquo;une déclaration de fonction
template est donc la suivante</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>paramètres_template<span style="color:#f92672">&gt;</span>
type fonction(paramètres_fonction);
</code></pre></div><p>où paramètres_template est la liste des paramètres template et
paramètres_fonction est la liste des paramètres de la fonction. type est le
type de la valeur de retour de la fonction, ce peut être un des types génériques
de la liste des paramètres template.</p>
<p>Tous les paramètres template qui sont des types doivent être utilisés dans la
liste des paramètres de la fonction, à moins qu&rsquo;une instanciation explicite de
la fonction ne soit utilisée. Cela permet au compilateur de réaliser
l&rsquo;identification des types génériques avec les types à utiliser lors de
l&rsquo;instanciation de la fonction.</p>
<p>La définition d&rsquo;une fonction template se fait comme une déclaration avec le
corps de la fonction. Il est alors possible d&rsquo;y utiliser les paramètres template
comme s&rsquo;ils étaient des types normaux : des variables peuvent être déclarées
avec un type générique, et les constantes template peuvent être utilisées comme
des variables définies localement avec la classe de stockage const. Les
fonctions template s&rsquo;écrivent donc exactement comme des fonctions classiques.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
T Min(T x, T y){
    <span style="color:#66d9ef">return</span> x<span style="color:#f92672">&lt;</span>y <span style="color:#f92672">?</span> x:y;
}
</code></pre></div><p>La fonction Min ainsi définie fonctionnera parfaitement pour toute classe pour
laquelle l&rsquo;opérateur <code>&lt;</code> est défini. Le compilateur déterminera automatiquement
quel est l&rsquo;opérateur à employer pour chaque fonction Min qu&rsquo;il rencontrera.</p>
<p>Les fonctions template peuvent être surchargées, aussi bien par des fonctions
classiques que par d&rsquo;autres fonctions template. Lorsqu&rsquo;il y a ambiguïté entre
une fonction template et une fonction normale qui la surcharge, toutes les
références sur le nom commun à ces fonctions se rapporteront à la fonction
classique.</p>
<p>Une fonction template peut être déclarée amie d&rsquo;une classe, template ou non,
pourvu que cette classe ne soit pas locale. Toutes les instances générées à
partir d&rsquo;une fonction amie template sont amies de la classe donnant l&rsquo;amitié, et
ont donc libre accès sur toutes les données de cette classe.</p>
<h3 id="les-classes-template">Les classes template</h3>
<p>La déclaration et la définition d&rsquo;une classe template se font comme celles d&rsquo;une
fonction template : elles doivent être précédées de la déclaration template des
types génériques. La déclaration suit donc la syntaxe suivante</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>paramètres_template<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">|</span><span style="color:#a6e22e">struct</span><span style="color:#f92672">|</span><span style="color:#66d9ef">union</span> <span style="color:#a6e22e">nom</span>;
</code></pre></div><p>La seule particularité dans la définition des classes template est que si les
méthodes de la classe ne sont pas définies dans la déclaration de la classe,
elles devront elles aussi être déclarées template</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>paramètres_template<span style="color:#f92672">&gt;</span>
type classe<span style="color:#f92672">&lt;</span>paramètres<span style="color:#f92672">&gt;::</span>nom(paramètres_méthode){
...
}
</code></pre></div><p>Il est absolument nécessaire dans ce cas de spécifier tous les paramètres
template de la lise paramètres_template dans paramètres, séparés par des
virgules, afin de caractériser le fait que c&rsquo;est la classe qui est template et
qu&rsquo;il ne s&rsquo;agit pas d&rsquo;une méthode template d&rsquo;une classe normale. D&rsquo;une manière
générale, il faudra toujours spécifier les types génériques de la classe entre
les signes d&rsquo;infériorité et de supériorité, juste après son nom, à chaque fois
qu&rsquo;on voudra référencer. Cette règle est cependant facultative lorsque la classe
est référencée à l&rsquo;intérieur d&rsquo;une fonction membre.</p>
<p>Contrairement aux fonctions template non membres, les méthodes des classes
template peuvent utiliser des types génériques de leur classe  sans pour autant
qu&rsquo;ils soient utilisés dans la liste de leurs paramètres. En effet, le
compilateur détermine quels sont les types à identifier aux types génériques
lors de l&rsquo;instanciation de la classe template, et n&rsquo;a donc pas besoin
d&rsquo;effectuer cette identification avec les types des paramètres utilisés.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Stack</span>
{
    <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">stackitem</span>
    {
        T Item;                 <span style="color:#75715e">// On utilise le type T comme
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">stackitem</span> <span style="color:#f92672">*</span>Next; <span style="color:#75715e">// si c&#39;était un type normal.
</span><span style="color:#75715e"></span>    } StackItem;
 
    StackItem <span style="color:#f92672">*</span>Tete;
 
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>         <span style="color:#75715e">// Les fonctions de la pile :
</span><span style="color:#75715e"></span>    Stack(<span style="color:#66d9ef">void</span>);
    Stack(<span style="color:#66d9ef">const</span> Stack<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>);
                 <span style="color:#75715e">// La classe est référencée en indiquant
</span><span style="color:#75715e"></span>                 <span style="color:#75715e">// son type entre &lt; et &gt; (&#34;Stack&lt;T&gt;&#34;).
</span><span style="color:#75715e"></span>                 <span style="color:#75715e">// Ici, ce n&#39;est pas une nécessité
</span><span style="color:#75715e"></span>                 <span style="color:#75715e">// cependant.
</span><span style="color:#75715e"></span>    <span style="color:#f92672">~</span>Stack(<span style="color:#66d9ef">void</span>);
    Stack<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> Stack<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>);
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push</span>(T);
    T <span style="color:#a6e22e">pop</span>(<span style="color:#66d9ef">void</span>);
    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">is_empty</span>(<span style="color:#66d9ef">void</span>) <span style="color:#66d9ef">const</span>;
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">flush</span>(<span style="color:#66d9ef">void</span>);
};
 
<span style="color:#75715e">// Pour les fonctions membres définies en dehors de la déclaration
</span><span style="color:#75715e">// de la classe, il faut une déclaration de type générique :
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
Stack<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>Stack(<span style="color:#66d9ef">void</span>) <span style="color:#75715e">// La classe est référencée en indiquant
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// son type entre &lt; et &gt; (&#34;Stack&lt;T&gt;&#34;).
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// C&#39;est impératif en dehors de la
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// déclaration de la classe.
</span><span style="color:#75715e"></span>{
    Tete <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">return</span>;
}
 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
Stack<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>Stack(<span style="color:#66d9ef">const</span> Stack<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>Init)
{
    Tete <span style="color:#f92672">=</span> NULL;
    StackItem <span style="color:#f92672">*</span>tmp1 <span style="color:#f92672">=</span> Init.Tete, <span style="color:#f92672">*</span>tmp2 <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">while</span> (tmp1<span style="color:#f92672">!=</span>NULL)
    {
        <span style="color:#66d9ef">if</span> (tmp2<span style="color:#f92672">==</span>NULL)
        {
            Tete<span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StackItem;
            tmp2 <span style="color:#f92672">=</span> Tete;
        }
        <span style="color:#66d9ef">else</span>
        {
            tmp2<span style="color:#f92672">-&gt;</span>Next <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StackItem;
            tmp2 <span style="color:#f92672">=</span> tmp2<span style="color:#f92672">-&gt;</span>Next;
        }
        tmp2<span style="color:#f92672">-&gt;</span>Item <span style="color:#f92672">=</span> tmp1<span style="color:#f92672">-&gt;</span>Item;
        tmp1 <span style="color:#f92672">=</span> tmp1<span style="color:#f92672">-&gt;</span>Next;
    }
    <span style="color:#66d9ef">if</span> (tmp2<span style="color:#f92672">!=</span>NULL) tmp2<span style="color:#f92672">-&gt;</span>Next <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">return</span>;
}
 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
Stack<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::~</span>Stack(<span style="color:#66d9ef">void</span>)
{
    flush();
    <span style="color:#66d9ef">return</span>;
}
 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
Stack<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>Stack<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> Stack<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>Init)
{
    flush();
    StackItem <span style="color:#f92672">*</span>tmp1 <span style="color:#f92672">=</span> Init.Tete, <span style="color:#f92672">*</span>tmp2 <span style="color:#f92672">=</span> NULL;
 
    <span style="color:#66d9ef">while</span> (tmp1<span style="color:#f92672">!=</span>NULL)
    {
        <span style="color:#66d9ef">if</span> (tmp2<span style="color:#f92672">==</span>NULL)
        {
            Tete <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StackItem;
            tmp2 <span style="color:#f92672">=</span> Tete;
        }
        <span style="color:#66d9ef">else</span>
        {
            tmp2<span style="color:#f92672">-&gt;</span>Next <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StackItem;
            tmp2 <span style="color:#f92672">=</span> tmp2<span style="color:#f92672">-&gt;</span>Next;
        }
        tmp2<span style="color:#f92672">-&gt;</span>Item <span style="color:#f92672">=</span> tmp1<span style="color:#f92672">-&gt;</span>Item;
        tmp1 <span style="color:#f92672">=</span> tmp1<span style="color:#f92672">-&gt;</span>Next;
    }
    <span style="color:#66d9ef">if</span> (tmp2<span style="color:#f92672">!=</span>NULL) tmp2<span style="color:#f92672">-&gt;</span>Next <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
}
 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> Stack<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>push(T Item)
{
    StackItem <span style="color:#f92672">*</span>tmp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StackItem;
    tmp<span style="color:#f92672">-&gt;</span>Item <span style="color:#f92672">=</span> Item;
    tmp<span style="color:#f92672">-&gt;</span>Next <span style="color:#f92672">=</span> Tete;
    Tete <span style="color:#f92672">=</span> tmp;
    <span style="color:#66d9ef">return</span>;
}
 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
T Stack<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>pop(<span style="color:#66d9ef">void</span>)
{
    T tmp;
    StackItem <span style="color:#f92672">*</span>ptmp <span style="color:#f92672">=</span> Tete;
 
    <span style="color:#66d9ef">if</span> (Tete<span style="color:#f92672">!=</span>NULL)
    {
        tmp <span style="color:#f92672">=</span> Tete<span style="color:#f92672">-&gt;</span>Item;
        Tete <span style="color:#f92672">=</span> Tete<span style="color:#f92672">-&gt;</span>Next;
        <span style="color:#66d9ef">delete</span> ptmp;
    }
    <span style="color:#66d9ef">return</span> tmp;
}
 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">bool</span> Stack<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>is_empty(<span style="color:#66d9ef">void</span>) <span style="color:#66d9ef">const</span>
{
    <span style="color:#66d9ef">return</span> (Tete<span style="color:#f92672">==</span>NULL);
}
 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> Stack<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>flush(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#66d9ef">while</span> (Tete<span style="color:#f92672">!=</span>NULL) pop();
    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><p>Les classes template peuvent parfaitement avoir des fonctions amies, que ces
fonctions soient elles-même template ou non.</p>
<h3 id="fonctions-membres-template">Fonctions membres template</h3>
<p>Les destructeurs mis à part, les méthodes d&rsquo;une classe peuvent être template,
que la classe elle-même soit template ou non, pourvu que la classe ne soit pas
une classe locale.</p>
<p>Les fonctions membres template peuvent appartenir à une classe template ou à une
classe normale.</p>
<p>Lorsque la classe à laquelle elles appartiennent n&rsquo;est pas template, leur
syntaxe est exactement la même que pour les fonctions template non membre.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
{
    <span style="color:#66d9ef">int</span> i;   <span style="color:#75715e">// Valeur de la classe.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
    <span style="color:#66d9ef">void</span> add(T valeur);
};
 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> A<span style="color:#f92672">::</span>add(T valeur)
{
    i<span style="color:#f92672">=</span>i<span style="color:#f92672">+</span>((<span style="color:#66d9ef">int</span>) valeur);   <span style="color:#75715e">// Ajoute valeur à A::i.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> ;
}
</code></pre></div><p>Si, en revanche, la classe dont la fonction membre fait partie est elle aussi
template, il faut spécifier deux fois la syntaxe template : une fois pour la
classe, et une fois pour la fonction. Si la fonction membre template est définie
à l&rsquo;intérieur de la classe, il n&rsquo;est pas nécessaire de donner les paramètres
template de la classe, et la fonction membre template se fait donc exactement
comme celle d&rsquo;une fonction template classique.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Chaine</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#75715e">// Fonction membre template définie
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// à l&#39;extérieur de la classe template :
</span><span style="color:#75715e"></span> 
    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T2</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">int</span> compare(<span style="color:#66d9ef">const</span> T2 <span style="color:#f92672">&amp;</span>);
 
    <span style="color:#75715e">// Fonction membre template définie
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// à l&#39;intérieur de la classe template :
</span><span style="color:#75715e"></span> 
    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T2</span><span style="color:#f92672">&gt;</span>
    Chaine(<span style="color:#66d9ef">const</span> Chaine<span style="color:#f92672">&lt;</span>T2<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>s)
    {
        <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>    }
};
 
<span style="color:#75715e">// À l&#39;extérieur de la classe template, on doit donner
</span><span style="color:#75715e">// les déclarations template pour la classe
</span><span style="color:#75715e">// et pour la fonction membre template :
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T2</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">int</span> Chaine<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>compare(<span style="color:#66d9ef">const</span> T2 <span style="color:#f92672">&amp;</span>s)
{
    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}
</code></pre></div><p>Les fonctions membres virtuelles ne peuvent pas être template. Si une fonction
membre template a le même nom qu&rsquo;une fonction membre virtuelle d&rsquo;une classe de
base, elle ne constitue pas une redéfinition de cette fonction. Par conséquent,
les mécanismes de virtualité sont inutilisables avec les fonctions membres
template. On peut contourner ce problème de la manière suivante : on définira
une fonction membre virtuelle non template qui appellera la fonction membre template.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span>
{
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">int</span>);
};
 
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> B
{
    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
    <span style="color:#66d9ef">void</span> f(T);     <span style="color:#75715e">// Cette fonction ne redéfinit pas B::f(int).
</span><span style="color:#75715e"></span> 
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">int</span> i)  <span style="color:#75715e">// Cette fonction surcharge B::f(int).
</span><span style="color:#75715e"></span>    {
        f<span style="color:#f92672">&lt;&gt;</span>(i);    <span style="color:#75715e">// Elle appelle de la fonction template.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> ;
    }
};
</code></pre></div><p>Dans l&rsquo;exemple précédent, on est obligé de préciser que la fonction à appeler
dans la fonction virtuelle est template, et qu&rsquo;il ne s&rsquo;agit donc pas d&rsquo;un appel
récursif de la fonction virtuelle. Pour cela, on fait suivre le nom de la
fonction template d&rsquo;une paire de signes inférieur et supérieur.</p>
<p>Plus généralement, si une fonction membre template d&rsquo;une classe peut être
spécialisée en une fonction qui a la même signature qu&rsquo;une autre fonction membre
de la même classe, et que ces deux fonctions ont le même nom, toute référence à
ce nom utilisera la fonction non-template. Il est possible de passer outre cette
règle, à condition de donner explicitement la liste des paramètres template
entre les signes inférieur et supérieur lors de l&rsquo;appel de la fonction.</p>
<h2 id="instanciation-des-template">Instanciation des template</h2>
<p>La définition des fonctions et des classes template ne génère aucun code tant
que tous les paramètres template n&rsquo;ont pas pris chacun une valeur spécifique. Il
faut donc, lors de l&rsquo;utilisation d&rsquo;une fonction ou d&rsquo;une classe template,
fournir les valeurs pour tous les paramètres qui n&rsquo;ont pas de valeur de défaut.
Lorsque suffisamment de valeurs sont données, le code est généré pour ce jeu de
valeurs. On appelle cette opération l&rsquo;instanciation des template.</p>
<p>Plusieurs possibilités sont offertes pour parvenir à ce résultat :
l&rsquo;instanciation implicite et l&rsquo;instanciation explicite.</p>
<h3 id="instanciation-implicite">Instanciation implicite</h3>
<p>L&rsquo;instanciation implicite est utilisée par le compilateur lorsqu&rsquo;il rencontre
une expression qu&rsquo;il utilise pour la première fois une fonction ou une classe
template, et qu&rsquo;il doit instancier pour continuer son travail. Le compilateur se
base alors sur le contexte courant pour déterminer les types des paramètres
template à utiliser. Si aucune ambiguïté n&rsquo;a lieu, il génère le code pour ce jeu
de paramètres.</p>
<p>La détermination des types des paramètres template peut se faire simplement ou
être déduite de l&rsquo;expression à compiler. Par exemple, les fonctions membres
template sont instanciées en fonction du type de leurs paramètres. Si l&rsquo;on
reprend l&rsquo;exemple de la fonction template Min, c&rsquo;est son utilisation directe qui
provoque l&rsquo;instanciation implicite.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> Min(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>);
</code></pre></div><p>dans cet exemple, le paramètre template est forcé à <code>int</code>, et 3.0 est converti
en entier.</p>
<p>On prendra garde au fait que le compilateur utiliser une politique minimaliste
pour l&rsquo;instanciation des template. Cela signifie qu&rsquo;il ne créera que le code
nécessaire pour compiler l&rsquo;expression qui exige une instanciation implicite. Par
exemple, la définition d&rsquo;un objet d&rsquo;une classe template dont tous les types
définis provoque l&rsquo;instanciation de cette classe, mais la définition d&rsquo;un
pointeur sur cette classe ne le fait pas. L&rsquo;instanciation aura lieu lorsqu&rsquo;un
déréférencement sera fait par l&rsquo;intermédiaire de ce pointeur. De même, seules
les fonctionnalités utilisées de la classe template seront effectivement
définies dans le programme final.</p>
<h3 id="instanciation-explicite">Instanciation explicite</h3>
<p>L&rsquo;instanciation explicite des template est une technique permettant au
programmeur de forcer l&rsquo;instanciation des template dans son programme. Pour
réaliser une instanciation explicite, il faut spécifier explicitement tous les
paramètres template à utiliser. Cela se fait simplement en donnant la
déclaration du template, précédée par le mot clé template.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> nom<span style="color:#f92672">&lt;</span>valeur[, valeur[...]]<span style="color:#f92672">&gt;</span>;
</code></pre></div>
					</div>
					<div class="post-comments">
						
					</div>
				</div>
			</div>
      <div class="col-md-4">
        <aside class="sidebar">



























<div class="widget widget-latest-post">
    <h4 class="widget-title">Derniers cours</h4>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/complex/3/">Robustesse du modèle de calcul par Machines de Turing</a></h4>
        <h5>[Calculabilité et complexité]</h5>
        <p>Definition des MTs : des choix arbitraires  Nombre …</p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/complex/2/">Machines de Turing</a></h4>
        <h5>[Calculabilité et complexité]</h5>
        <p>Ruban, tête de lecture, registre  Ruban : infini, …</p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/semestre8/apptcp-ip/">Applications TCP-IP Page d&#39;accueil</a></h4>
        <h5></h5>
        <p></p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/semestre8/complex/">Calculabilité et complexité Page d&#39;accueil</a></h4>
        <h5></h5>
        <p>Ressources pédagoqiues Présentation du cours …</p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/semestre8/crypto/">Cryptologie Page d&#39;accueil</a></h4>
        <h5></h5>
        <p></p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/semestre8/robotique/">Initiation à la robotique Page d&#39;accueil</a></h4>
        <h5></h5>
        <p></p>
      </div>
    </div>
    
  </div>
</aside>


      </div>
		</div>
	</div>
</section>

<footer class="footer">
	<div class="container">
		<div class="row">
			<div class="col-md-12">
				<div class="footer-manu">
					<ul>
            
            <li><a href="https://Sdelpeuch.github.io/about">Semestre 7</a></li>
            
            <li><a href="https://Sdelpeuch.github.io/contact">Semestre 6</a></li>
            
            <li><a href="https://Sdelpeuch.github.io/project">Semestre 5</a></li>
            
            <li><a href="https://Sdelpeuch.github.io/cpbx">CPBx</a></li>
            
					</ul>
				</div>
				<p class="copyright">Copyright © 2020 <a href="https://themefisher.com">Themefisher</a> All Rights Reserved</p>
			</div>
		</div>
	</div>
</footer>



<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCcABaamniA6OL5YvYSpB3pFMNrXwXnLwU&amp;libraries=places"></script>




<script src="https://Sdelpeuch.github.io/plugins/jQuery/jquery.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/bootstrap/bootstrap.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/slick/slick.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/magnific-popup/jquery.magnific-popup.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/shuffle/shuffle.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/google-map/gmap.js"></script>




<script src="https://Sdelpeuch.github.io/js/script.min.js"></script>







<script src="https://cdnjs.cloudflare.com/ajax/libs/js-cookie/2.2.1/js.cookie.min.js"></script>
<div id="js-cookie-box" class="cookie-box cookie-box-hide">
	This site uses cookies. By continuing to use this website, you agree to their use. <span id="js-cookie-button" class="btn btn-main btn-solid-border">I Accept</span>
</div>
<script>
	(function ($) {
		const cookieBox = document.getElementById('js-cookie-box');
		const cookieButton = document.getElementById('js-cookie-button');
		if (!Cookies.get('cookie-box')) {
			cookieBox.classList.remove('cookie-box-hide');
			cookieButton.onclick = function () {
				Cookies.set('cookie-box', true, {
					expires:  2 
				});
				cookieBox.classList.add('cookie-box-hide');
			};
		}
	})(jQuery);
</script>


<style>
.cookie-box {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  text-align: center;
  z-index: 9999;
  padding: 1rem 2rem;
  background: rgb(71, 71, 71);
  transition: all .75s cubic-bezier(.19, 1, .22, 1);
  color: #fdfdfd;
}

.cookie-box-hide {
  display: none;
}
</style>
</body>

</html>