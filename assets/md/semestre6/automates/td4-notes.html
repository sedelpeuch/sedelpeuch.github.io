<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>td4-notes.html</title>
<meta http-equiv="Content-Type" content="application/xhtml+xml;charset=utf-8"/>
<link rel="stylesheet" type="text/css" media="all" href="https://cdn.jsdelivr.net/npm/github-markdown-css/github-markdown.min.css"  />
<link rel="stylesheet" type="text/css" media="all" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/github.min.css"  /><meta name='viewport' content='width=device-width, initial-scale=1, shrink-to-fit=no'><style> body { box-sizing: border-box; max-width: 740px; width: 100%; margin: 40px auto; padding: 0 10px; } </style><script src='https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js'></script><script>document.addEventListener('DOMContentLoaded', () => { document.body.classList.add('markdown-body'); document.querySelectorAll('pre[lang] > code').forEach((code) => { code.classList.add(code.parentElement.lang); }); document.querySelectorAll('pre > code').forEach((code) => { hljs.highlightBlock(code); }); });</script>
</head>

<body>

<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<h2 id="exercice-1">Exercice 1</h2>
<p>Lemme d’Arden : <span class="math display">\[A^\ast.B\]</span> est une solution de <span class="math display">\[X = A.X U B\]</span> (et si A ne contient pas eps, cette solution est unique)</p>
<ul>
<li>En pratique, il faut choisir la variable qui sera éliminée en premier. Ici, on va remplacer <span class="math display">\[X_2\]</span> par sa valeur dans <span class="math display">\[X_1\]</span> (on se permet de confondre les singletons avec l’élement par concision) : <span class="math display">\[X1 = b.X_1 U (b.A.X_0 U
  \{a, b\}.X_1) U \epsilon\]</span> <span class="math display">\[X1 = \{b, ba, bb\}.X_1 U ba.X_0 U \epsilon\]</span></li>
</ul>
<p>D’après le Lemme d’Arden, on a : <span class="math display">\[X_1 = \{b, ba, bb\}^\ast . (ba.X_0 U
    \epsilon)\]</span></p>
<p>On remplace dans X0 : <span class="math display">\[X_0 = (a U b.\{b, ba, bb\}^\ast .ba).X_0 U b.\{b, ba,
    bb\}^\ast U \epsilon\]</span></p>
<p>Encore une fois, avec le lemme : <span class="math display">\[X0 = (a U b.\{b, ba, bb\}^\ast.ba)^\ast .
    (b.{b, ba, bb}* U \epsilon)\]</span></p>
<p>Et on termine en remplaçant <span class="math display">\[X_0\]</span> et <span class="math display">\[X_1\]</span> dans <span class="math display">\[X_2\]</span>.</p>
<ul>
<li>On veut montrer que <span class="math display">\[\Sigma^\ast\]</span> est toujours solution si <span class="math display">\[A\]</span> contient le mot vide.</li>
</ul>
<p>Si A contient eps, alors <span class="math display">\[A.Σ* = Σ*\]</span> de plus, <span class="math display">\[B\]</span> est inclus dans <span class="math display">\[Σ*\]</span> donc <span class="math display">\[A.Σ* U B = Σ*\]</span></p>
<p>donc <span class="math display">\[Σ*\]</span> est bien solution de l’équation <span class="math display">\[X = A.X U B\]</span></p>
<ul>
<li><p>Pour prouver le lemme, il faut montrer que A*.B est bien une solution puis l’unicité (ce qu’on va faire en montrant qu’elle est la plus petit et la plus grande)</p></li>
<li><p>Montrons d’abord que <span class="math display">\[A*.B\]</span> est une solution de <span class="math display">\[X = A.X U B\]</span></p></li>
</ul>
<p><span class="math display">\[A*.B = (eps U A.A*).B = B U A.A*.B\]</span> or le produit de langages est associatif, donc <span class="math display">\[A*.B = A(A*.B U B)\]</span></p>
<ul>
<li>Dans la cas où <span class="math display">\[A\]</span> ne contient pas le mot vide Soit <span class="math display">\[S\]</span> une solution, et <span class="math display">\[w\]</span> un mot de <span class="math display">\[S\]</span> Supposons que <span class="math display">\[w\]</span> est le plus court possible tel que <span class="math display">\[w\]</span> n’est pas dans <span class="math display">\[A*.B\]</span> <span class="math display">\[w\]</span> est dans <span class="math display">\[S = A.S U B\]</span> donc <span class="math display">\[w\]</span> est soit :
<ul>
<li>dans <span class="math display">\[B\]</span> (impossible)</li>
<li>soit dans <span class="math display">\[AS\]</span></li>
</ul></li>
</ul>
<p>donc <span class="math display">\[w = u.v\]</span> avec <span class="math display">\[u\]</span> dans <span class="math display">\[A\]</span> et <span class="math display">\[v\]</span> dans <span class="math display">\[S v\]</span> est aussi dans <span class="math display">\[A*.B\]</span> (car <span class="math display">\[|v| &lt; |w|\]</span>) donc <span class="math display">\[w\]</span> est dans <span class="math display">\[A.A*.B\]</span>, donc dans <span class="math display">\[A*.B\]</span></p>
<p>Supposons maintenant que <span class="math display">\[S\]</span> est une solution et <span class="math display">\[w\]</span> dans <span class="math display">\[A*.B\]</span> qui n’est pas dans <span class="math display">\[S\]</span>, de longueur minimale</p>
<p>On a toujours que <span class="math display">\[A*.B = A.A*B U B\]</span> donc <span class="math display">\[w\]</span> appartient à l’un des deux ensembles Or <span class="math display">\[B\]</span> est inclus dans <span class="math display">\[S\]</span>, donc <span class="math display">\[w\]</span> est dans <span class="math display">\[A.A*.B\]</span> Ainsi, <span class="math display">\[w = x.y.z\]</span> avec <span class="math display">\[x\]</span> non-vide, <span class="math display">\[y\]</span> dans <span class="math display">\[A*\]</span> et <span class="math display">\[z\]</span> dans <span class="math display">\[B\]</span></p>
<p><span class="math display">\[yz\]</span> est dans <span class="math display">\[A*.B\]</span>, donc dans <span class="math display">\[S\]</span> or <span class="math display">\[S = AS U B\]</span>, donc <span class="math display">\[x.yz\]</span> est dans <span class="math display">\[S\]</span> -&gt; contradiction</p>
<ul>
<li>On construit l’automate en créant un état par variable + un état final et on crée les transitions pour chaque règle (cf. cours)</li>
</ul>
<h2 id="exercice-2">Exercice 2 :</h2>
<p>L’intuition naïve qu’on pourrait avoir serait “d’inverser” les résultats de chaque règle. Cependant, cette méthode génère en fait le miroir du langage de la grammaire de départ.</p>
<p>À partir d’une grammaire linéaire droite G, on peut obtenir un automate fini A qui accepte le langage de la grammaire. Ensuite, on calcule l’automate A’ qui accepte le langage miroir, ce qui permet d’obtenir une grammaire linéaire droite G’. Enfin, on inverse “naïvement” G’ et on obtient une grammaire linéaire gauche G’’ de même langage que G. (on peut bien sûr effectuer l’opération inverse)</p>
<p>On peut aussi convertir en automate fini puis inverser les états initiaux et finaux du résultat, ainsi que toutes les transitions. FH: cette transformation correspond au calcul de l’automate miroir dans la solution ci-dessus. C’est une étape de la construction, mais elle ne répond pas totalement à la question</p>
<h3 id="parenthèse-sur-un-arbre-de-dérivation-pour-une-grammaire-régulière">Parenthèse sur un arbre de dérivation pour une grammaire régulière</h3>
<p><span class="math display">\[\begin{align} S &amp;\rightarrow aS | bT \\
T &amp;\rightarrow aT | bS | \epsilon \end{align}\]</span></p>
<p>pour une génération <span class="math display">\[S \Rightarrow aS \Rightarrow abT \Rightarrow ab\]</span></p>
<pre><code>     S
    / \
   a   S
      / \
      b  T
         |
        eps</code></pre>
<p><span class="math display">\[S \rightarrow S + S | x\]</span></p>
<p>On peut avoir deux suites de dérivations différentes, mais le même arbre 1. <span class="math display">\[S \Rightarrow S + S \Rightarrow x + S \Rightarrow x + x\]</span> 2. <span class="math display">\[S \Rightarrow S + S \Rightarrow S + x \Rightarrow x + x\]</span></p>
<pre><code>       S
    /  |  \
   S   +   S
   |       |
   x       x</code></pre>
<p><span class="math display">\[S \Rightarrow S+S \Rightarrow S+S+S \Rightarrow\]</span> Dans ce cas, on peut choisir de remplacer le premier ou le deuxième <span class="math display">\[S\]</span> par <span class="math display">\[S + S\]</span></p>
<p>En remplaçant le deuxième, on trouve l’arbre suivant :</p>
<pre><code>       S
    /  |  \
   S   +   S
   |     / | \
   x     S +  S
         |    |
         x    x</code></pre>
<h2 id="exercice-3">Exercice 3</h2>
<p>On est en présence d’une grammaire non-linéaire (à cause de la première règle qui mène à A1B avec deux symboles non-terminaux)</p>
<ol type="1">
<li><span class="math display">\[S \rightarrow A1B
A1B \rightarrow 0A1B | 1B
B \rightarrow 0B | 1B | eps\]</span></li>
</ol>
<p><span class="math display">\[S \rightarrow A&#39;
A&#39; \rightarrow 0A&#39; | 1B
B \rightarrow 0B | 1B | eps\]</span></p>
<p>Finalement en supprimant la variable inutile <span class="math display">\[S \rightarrow 0S | 1B \\
B \rightarrow 0B | 1B | eps\]</span></p>
<p>Il faut garder à l’esprit que les grammaire hors-contexte ne sont pas toutes équivalentes à des grammaires linéaires.</p>
<h2 id="exercice-4">Exercice 4</h2>
<p>Conversion de langages en grammaires</p>
<ol type="1">
<li><p><span class="math display">\[\{a^n.b^n\} : S \rightarrow aSb | eps\]</span></p></li>
<li><p><span class="math display">\[\{a^n.b^m, m &lt;= n\} : S \rightarrow aS | aSb| eps\]</span></p></li>
</ol>
<p>D’ailleurs, cette grammaire est ambigüe</p>
<p><span class="math display">\[S \Rightarrow aS \Rightarrow aaSb \Rightarrow aab\]</span> mais aussi <span class="math display">\[S \Rightarrow aSb \Rightarrow aaSb \Rightarrow aab\]</span> qui ont deux arbres différents donc on a deux façon différentes de construire <span class="math display">\[aab\]</span></p>
<ol start="3" type="1">
<li><p><span class="math display">\[{w.w^R} : S \rightarrow aSa | bSb | eps\]</span> qui n’est pas ambigüe</p></li>
<li><p>Les mots de Dyck : <span class="math display">\[S \rightarrow SS | (S) | [S] | {S} | \epsilon\]</span> qui est ambigüe</p></li>
<li><p>variante avec les parenthèses dans l’ordre : <span class="math display">\[ 1: {}, 2: (), 3: []\]</span></p></li>
</ol>
<p><span class="math display">\[S \rightarrow SS | {T} | \epsilon \\
T \rightarrow TT | (U) | \epsilon \\
U \rightarrow UU | [] | \epsilon\]</span></p>
<h2 id="exercice-5">Exercice 5</h2>
<p><span class="math display">\[S \rightarrow S + S | S * S \\
S \rightarrow 0 | 1\]</span></p>
<ol type="1">
<li><p>Cette grammaire est hors-contexte</p></li>
<li><p>On exhibe deux arbres différents qui génèrent le même mot cf. la Parenthèse au début de ces notes</p></li>
</ol>
<p>Problème : difficulté pour évaluer l’expression (arithmétique) car on ne sait pas quel arbre choisir</p>
<ol start="3" type="1">
<li><p>On peut se baser sur l’expression régulière <span class="math display">\[({0,1}{+,x})*{0,1}\]</span>, on trouve <span class="math display">\[S \rightarrow 0+S | 1+S | 0*S | 1*S | 0 | 1\]</span></p></li>
<li><p>on ajoute la règle <span class="math display">\[S \rightarrow (S)\]</span> Il n’y a pas de grammaire régulière qui décrit ce nouveau langage, car ce n’est pas un langage régulier</p></li>
</ol>

</body>
</html>
