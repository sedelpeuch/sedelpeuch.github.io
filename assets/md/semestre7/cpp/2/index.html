<!DOCTYPE html>
<html lang="en-Us"><head>
  <meta charset="utf-8">
  <title>La couche objet - Partie 2 : Constructeur, Destructeurs, Pointeur this, Statique, Surcharge</title>

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Semestre 9 de l&#39;ENSEIRB-MATEMECA">
  <meta name="author" content="Sébastien">
  <meta name="generator" content="Hugo 0.74.3" />

  <!-- plugins -->
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/plugins/bootstrap/bootstrap.min.css">
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/plugins/Ionicons/css/ionicons.min.css">
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/plugins/magnific-popup/magnific-popup.css">
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/plugins/slick/slick.css">
  

  <!-- Main Stylesheet -->
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/scss/style.min.css" media="screen">

  <!--Favicon-->
  <link rel="shortcut icon" href="https://Sdelpeuch.github.io/images/favicon.png" type="image/x-icon">
  <link rel="icon" href="https://Sdelpeuch.github.io/images/favicon.png" type="image/x-icon">

</head><body>
<!-- preloader start -->
<div class="preloader">
  
</div>
<!-- preloader end -->

<header class="navigation">
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        
        <nav class="navbar">
          
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navigation">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">
              <img src="https://Sdelpeuch.github.io/images/telechargement.png" alt="Semestre 9" width="65px" class="img-responsive">
            </a>
          </div>
          
          <div class="collapse navbar-collapse" id="navigation">
            <ul class="nav navbar-nav navbar-right">
              
              
              <li><a href="/">Accueil</a></li>
              
              
              
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true"
                  aria-expanded="false">Semestre 9 <span class="ion-ios-arrow-down"></span></a>
                <ul class="dropdown-menu">
                  
                  <li><a href="/semestre9/controle">Contrôle commande</a></li>
                  
                  <li><a href="/semestre9/interaction">IHR</a></li>
                  
                  <li><a href="/semestre9/maths">Mathématiques</a></li>
                  
                  <li><a href="/semestre9/modelisation">Modélisation</a></li>
                  
                  <li><a href="/semestre9/mecatronique">Mécatronique</a></li>
                  
                  <li><a href="/semestre9/imagerie">Outils d&#39;imagerie</a></li>
                  
                  <li><a href="/semestre9/reachy">Reachy</a></li>
                  
                  <li><a href="/semestre9/energie">Énergétique</a></li>
                  
                </ul>
              </li>
              
              
              
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true"
                  aria-expanded="false">ENSEIRB-MATMECA <span class="ion-ios-arrow-down"></span></a>
                <ul class="dropdown-menu">
                  
                  <li><a href="/semestre5/semestre_5">Semestre 5</a></li>
                  
                  <li><a href="/semestre6/semestre_6">Semestre 6</a></li>
                  
                  <li><a href="/semestre7/semestre_7">Semestre 7</a></li>
                  
                  <li><a href="/semestre8/semestre_8">Semestre 8</a></li>
                  
                </ul>
              </li>
              
              
              
              <li><a href="/cpbx">CPBx</a></li>
              
              
              
              <li><a href="/contact">Contact</a></li>
              
              

              
            </ul>
          </div>
        </nav>
      </div>
    </div>
  </div>
</header>

<section class="page-title bg-2" style="background-image: url('https://Sdelpeuch.github.io/images/banner/cpp.jpg');">
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        <div class="block">
          <h1>La couche objet - Partie 2 : Constructeur, Destructeurs, Pointeur this, Statique, Surcharge</h1>
          <p></p>
        </div>
      </div>
    </div>
  </div>
</section>


<section class="page-wrapper">
	<div class="container">
		<div class="row">
			<div class="col-md-8">
				<div class="post post-single">
					<h2 class="post-title">La couche objet - Partie 2 : Constructeur, Destructeurs, Pointeur this, Statique, Surcharge</h2>
					<div class="post-meta">
						<ul>
              <li><i class="ion-calendar"></i> November 4, 2020</li>
              
              
              
              
              
              
              <li><i class="ion-pricetags"></i> 
                
                <a href="/tags/c&#43;&#43;">C&#43;&#43;</a>
								
              </li>
            </ul>
					</div>
					
					
					
					<div class="post-content post-excerpt">
						<h2 id="constructeurs-et-destructeurs">Constructeurs et destructeurs</h2>
<p>Le <em>constructeur</em> et le <em>destructeur</em> sont deux méthodes particulières qui sont
appelées respectivement à la création et à la destruction d&rsquo;un objet. Toute
classe a un constructeur et un destructeur par défaut, fournis par le
compilateur. Ces constructeurs et destructeurs appellent les constructeurs par
défaut et les destructeurs des classes de base et des données membre de la
classe, mais en dehors de cela, ils ne font absolument rien. Il est donc souvent
nécessaire de les redéfinir afin de gérer certaines actions qui doivent avoir
lieu lors de la création d&rsquo;un objet et de leur destruction. Par exemple, si
l&rsquo;objet doit contenir des objets allouées dynamiquement, il faut leur réserver
de la mémoire à la création de l&rsquo;objet ou au moins mettre les pointeurs
correspondants à NULL. À la destruction de l&rsquo;objet, il convient de restituer la
mémoire allouée, s&rsquo;il en a été alloué. On peut trouver bien d&rsquo;autres situations
où une phase d&rsquo;initialisation et une phase de terminaison son nécessaires.</p>
<p>Dés qu&rsquo;un constructeur ou un destructeur a été défini par l&rsquo;utilisateur, le
compilateur ne définit plus automatiquement le constructeur ou le destructeur
par défaut correspondant. En particulier, si l&rsquo;utilisateur définit un
constructeur prenant des paramètres, il ne sera plus possible de construire un
objet simplement, sans fournir les paramètres à ce constructeur, à moins bien
entendu de définir également un constructeur qui ne prenne pas de paramètres.</p>
<h3 id="définition-des-constructeurs-et-des-destructeurs">Définition des constructeurs et des destructeurs</h3>
<p>Le constructeur se définit comme une méthode normale. Cependant, pour que le
compilateur puisse la reconnaître en tant que constructeur, les deux conditions
suivantes doivent vérifiées :</p>
<ul>
<li>elle doit porter le même nom que la classe</li>
<li>elle ne doit avoir aucun type, pas même le type void</li>
</ul>
<p>Le destructeur doit également respecter ces règles. Pour différencier du
constructeur, son nom sera toujours précédé du signe tilde.</p>
<p>Un constructeur est appelé automatiquement lors de l&rsquo;instanciation de l&rsquo;objet.
Le destructeur est appelé automatiquement lors de sa destruction. Cette
destruction a lieu lors de la sortie du bloc de portée courante pour les objets
de classe de stockage <code>auto</code>. Pour les objets alloués dynamiquement, le
constructeur et le destructeur sont appelés automatiquement par les expressions
qui utilisent les opérateurs <code>new, new[], delete, delete[]</code>. C&rsquo;est pour cela
qu&rsquo;il est recommandé de les utiliser à la place des fonctions <code>malloc</code> et <code>free</code>
du C pour créer dynamiquement des objets. De plus, il ne faut pas utiliser
<code>delete</code> ou <code>delete[]</code> sur des pointeurs de type void, car il n&rsquo;existe pas
d&rsquo;objets de type void. La compilateur ne peut donc pas déterminer quel est le
destructeur à appeler avec ce type de pointer.</p>
<p>Le constructeur est appelé après l&rsquo;allocation de la mémoire de l&rsquo;objet et le
destructeur est appelé avant la libération de cette mémoire. La gestion de
l&rsquo;allocation dynamique de mémoire avec les classes est ainsi simplifiée. Dans le
cas des tables, l&rsquo;ordre de construction est celui des adresses croissantes, et
l&rsquo;ordre de destruction est celui des adresses décroissantes. C&rsquo;est dans cet
ordre que les constructeurs et destructeurs de chaque élement du tableau sont
appelés.</p>
<p>Les constructeurs pourront avoir des paramètres. Ils peuvent donc être
surchargés, mais pas les destructeurs. Cela est dû au fait qu&rsquo;en général on
connaît le contexte dans lequel un objet est créé, mais qu&rsquo;on ne peut pas
connaître le contexte dans lequel il est détruit : il ne peut donc y avoir qu&rsquo;un
seul destructeur. Les constructeurs qui ne prennent pas de paramètre ou dont
tous les paramètres ont une valeur par défaut, remplacent automatiquement les
constructeurs par défaut définis par le compilateur lorsqu&rsquo;il n&rsquo;y a aucun
constructeur dans les classes. Cela signifie que ce sont ces constructeurs qui
seront appelés automatiquement par les constructeurs par défaut des classes
dérivées.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">chaine</span>    <span style="color:#75715e">// Implémente une chaîne de caractères.
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> s;   <span style="color:#75715e">// Le pointeur sur la chaîne de caractères.
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    chaine(<span style="color:#66d9ef">void</span>);           <span style="color:#75715e">// Le constructeur par défaut.
</span><span style="color:#75715e"></span>    chaine(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>);   <span style="color:#75715e">// Le constructeur. Il n&#39;a pas de type.
</span><span style="color:#75715e"></span>    <span style="color:#f92672">~</span>chaine(<span style="color:#66d9ef">void</span>);          <span style="color:#75715e">// Le destructeur.
</span><span style="color:#75715e"></span>};
 
chaine<span style="color:#f92672">::</span>chaine(<span style="color:#66d9ef">void</span>)
{
    s<span style="color:#f92672">=</span>NULL;                 <span style="color:#75715e">// La chaîne est initialisée avec
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> ;                <span style="color:#75715e">// le pointeur nul.
</span><span style="color:#75715e"></span>}
 
chaine<span style="color:#f92672">::</span>chaine(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> Taille)
{
    s <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[Taille<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]; <span style="color:#75715e">// Alloue de la mémoire pour la chaîne.
</span><span style="color:#75715e"></span>    s[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;\0&#39;</span>;              <span style="color:#75715e">// Initialise la chaîne à &#34;&#34;.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span>;
}
 
chaine<span style="color:#f92672">::~</span>chaine(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#66d9ef">if</span> (s<span style="color:#f92672">!=</span>NULL) <span style="color:#66d9ef">delete</span>[] s; <span style="color:#75715e">// Restitue la mémoire utilisée si
</span><span style="color:#75715e"></span>                             <span style="color:#75715e">// nécessaire.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><p>Pour passer les paramètres au constructeur, on donne la liste des paramètres
entre parenthèses juste après le nom de l&rsquo;objet lors de son instanciation :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">chaine s1;        <span style="color:#75715e">// Instancie une chaîne de caractères
</span><span style="color:#75715e"></span>                  <span style="color:#75715e">// non initialisée.
</span><span style="color:#75715e"></span>chaine <span style="color:#a6e22e">s2</span>(<span style="color:#ae81ff">200</span>);   <span style="color:#75715e">// Instancie une chaîne de caractères
</span><span style="color:#75715e"></span>                  <span style="color:#75715e">// de 200 caractères.
</span></code></pre></div><p>Les constructeurs devront parfois effectuer des tâches plus compliquées que
celles données dans cet exemple. En général, ils peuvent faire toutes les
opérations faisables dans une méthode normale, sauf utiliser les données non
initialisées bien entendu. En particulier, les données des sous-objets d&rsquo;un
objet ne sont pas initialisées tant que les constructeurs des classes de base ne
sont pas appelés. C&rsquo;est pour cela qu&rsquo;il faut toujours appeler les constructeurs
des classes de base avant d&rsquo;exécuter le constructeur de la classe en cours
d&rsquo;instanciation. Si les constructeurs des classes de base ne sont pas appelés
explicitement, le compilateur appellera, par défaut, les constructeurs des
classes mères qui ne prennent pas de paramètre ou dont tous les paramètres ont
une valeur par défaut.</p>
<p>Comment appeler les constructeurs et les destructeurs des classes mères lors de
l&rsquo;instanciation et de la destruction d&rsquo;une classe dérivée ? Le compilateur ne
peut en effet pas savoir quel constructeur il faut appeler parmi les différents
constructeurs surchargés potentiellement présents &hellip; Pour appeler un autre
constructeur d&rsquo;une classe de base que le constructeur ne prenant pas de
paramètre, il faut spécifier explicitement ce constructeur avec ses paramètres
après le nom du constructeur de la classe fille, en les séparant de deux points.</p>
<p>En revanche, il est inutile de préciser le destructeur à appeler, puisque
celui-ci est unique. Le programmeur ne doit donc pas appeler lui-même les
destructeurs des classes mères, le langage s&rsquo;en charge.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/* Déclaration de la classe mère. */</span>
 
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Mere</span>
{
    <span style="color:#66d9ef">int</span> m_i;
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Mere(<span style="color:#66d9ef">int</span>);
    <span style="color:#f92672">~</span>Mere(<span style="color:#66d9ef">void</span>);
};
 
<span style="color:#75715e">/* Définition du constructeur de la classe mère. */</span>
 
Mere<span style="color:#f92672">::</span>Mere(<span style="color:#66d9ef">int</span> i)
{
    m_i<span style="color:#f92672">=</span>i;
    printf(<span style="color:#e6db74">&#34;Exécution du constructeur de la classe mère.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span>;
}
 
<span style="color:#75715e">/* Définition du destructeur de la classe mère. */</span>
 
Mere<span style="color:#f92672">::~</span>Mere(<span style="color:#66d9ef">void</span>)
{
    printf(<span style="color:#e6db74">&#34;Exécution du destructeur de la classe mère.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span>;
}
 
<span style="color:#75715e">/* Déclaration de la classe fille. */</span>
 
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fille</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Mere
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Fille(<span style="color:#66d9ef">void</span>);
    <span style="color:#f92672">~</span>Fille(<span style="color:#66d9ef">void</span>);
};
 
<span style="color:#75715e">/* Définition du constructeur de la classe fille
</span><span style="color:#75715e">   avec appel du constructeur de la classe mère. */</span>
 
Fille<span style="color:#f92672">::</span>Fille(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">:</span> Mere(<span style="color:#ae81ff">2</span>)
{
    printf(<span style="color:#e6db74">&#34;Exécution du constructeur de la classe fille.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span>;
}
 
<span style="color:#75715e">/* Définition du destructeur de la classe fille
</span><span style="color:#75715e">   avec appel automatique du destructeur de la classe mère. */</span>
 
Fille<span style="color:#f92672">::~</span>Fille(<span style="color:#66d9ef">void</span>)
{
    printf(<span style="color:#e6db74">&#34;Exécution du destructeur de la classe fille.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><p>Lors de l&rsquo;instanciation d&rsquo;un objet de la classe fille, le programme affichera
dans l&rsquo;ordre les messages suivants :</p>
<ol>
<li>Exécution du constructeur de la classe mère</li>
<li>Exécution du constructeur de la classe fille</li>
</ol>
<p>et lors de la destruction de l&rsquo;objet</p>
<ol>
<li>Exécution du destructeur de la classe fille</li>
<li>Exécution du destructeur de la classe mère</li>
</ol>
<p>Si l&rsquo;on n&rsquo;avait pas précisé que le constructeur à appeler pour la classe Mère
était le constructeur prenant un entier en paramètre, le compilateur aurait
essayé d&rsquo;appeler le constructeur par défaut de cette classe. Or, ce constructeur
n&rsquo;étant plus généré automatiquement par le compilateur (à cause de la définition
d&rsquo;un constructeur prenant un paramètre), il y aurait eu une erreur de
compilation.</p>
<p>Il est possible d&rsquo;appeler plusieurs constructeurs si la classé dérive de
plusieurs classes de base. Pour cela, il suffit de lister les constructeurs un à
un, en séparant leurs appels par des virgules. On notera cependant que l&rsquo;ordre
dans lequel les constructeurs sont appelés n&rsquo;est pas forcément l&rsquo;ordre dans
lequel ils sont listés dans la définition du constructeur de la classe fille. En
effet, le C++ appelle toujours les constructeurs dans l&rsquo;ordre d&rsquo;apparition de
leurs classes dans la liste des classes de base de la classe dérivée.</p>
<blockquote>
<p>Une fonction virtuelle peut donc toujours être appelée dans un constructeur,
mais la fonction effectivement appelée est celle de la classe du sous-objet en
cours de construction : pas celle de la classe de l&rsquo;objet complet. Ainsi, si
une classe A hérite d&rsquo;une classe B et qu&rsquo;elles ont toutes les deux une
fonction virtuelle f, l&rsquo;appel de f dans le constructeur de B utilisera la
fonction f de B, pas celle de A (même si l&rsquo;objet que l&rsquo;on instancie est de
classe A).</p>
</blockquote>
<p>La syntaxe utilisée pour appeler les constructeurs des classes de base peut
également être utilisée pour initialiser les données membres de la classe. En
particulier, cette syntaxe est obligatoire pour les données membres constantes
et pour les références, car le C++ ne permet pas l&rsquo;affectation d&rsquo;une valeur à
des variables de ce type. Encore une fois, l&rsquo;ordre d&rsquo;appel des constructeurs des
données membres ainsi initialisées n&rsquo;est pas forcément l&rsquo;ordre dans lequel ils
sont listés dans le constructeur de classe. En effet, le C++ utilise cette fois
l&rsquo;ordre de déclaration de chaque donnée membre.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">tableau</span>
{
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> m_iTailleMax;
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>m_pDonnees;
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    tableau(<span style="color:#66d9ef">int</span> iTailleMax);
    <span style="color:#f92672">~</span>tableau();
};
 
tableau<span style="color:#f92672">::</span>tableau(<span style="color:#66d9ef">int</span> iTailleMax) <span style="color:#f92672">:</span>
    m_iTailleMax(iTailleMax)    <span style="color:#75715e">// Initialise la donnée membre constante.
</span><span style="color:#75715e"></span>{
    <span style="color:#75715e">// Allocation d&#39;un tableau de m_iTailleMax entrées :
</span><span style="color:#75715e"></span>    m_pDonnees <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[m_iTailleMax];
}
 
tableau<span style="color:#f92672">::~</span>tableau()
{
    <span style="color:#75715e">// Destruction des données :
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">delete</span>[] m_pDonnees;
}
</code></pre></div><h3 id="constructeurs-de-copie">Constructeurs de copie</h3>
<p>Il faudra parfois créer un constructeur de copie. Le but de ce type de
constructeur est d&rsquo;initialiser un objet lors de son instanciation à partir d&rsquo;un
autre objet. Toute classe dispose d&rsquo;un constructeur de copie par défaut généré
automatiquement par le compilateur, dont le seul but est de recopier les champs
de l&rsquo;objet à recopier un à un dans les champs de l&rsquo;objet à instancier.
Toutefois, ce constructeur par défaut ne suffira pas toujours, et le programmeur
devra parfois en fournir un explicitement.</p>
<p>Ce sera notamment le cas lorsque certaines données des objets auront été
allouées dynamiquement. Une copie brutale des champs d&rsquo;un objet dans un autre ne
ferait que recopier les pointeurs, pas les données pointées. Ainsi, la
modification de ces données pour un objet entraînerait la modification des
données de l&rsquo;autre objet, ce qui ne serait sans doute pas l&rsquo;effet désiré.</p>
<p>La définition des constructeurs de copie se fait comme celle des constructeurs
normaux. Le nom doit être celui de la classe, et il ne doit y avoir aucun type.
Dans la liste des paramètres cependant, il devra toujours y avoir une référence
sur l&rsquo;objet à copier.</p>
<p>Pour la classe chaine définie ci-dessus, il faut un constructeur de copie.
Celui-ci peut être déclaré de la façon suivante</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">chaine(<span style="color:#66d9ef">const</span> chaine <span style="color:#f92672">&amp;</span>Source);
</code></pre></div><p>où Source est l&rsquo;objet à copier. Si l&rsquo;on rajoute la donnée membre Taille dans la
déclaration de la classe, la définition de ce constructeur peut être :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">chaine<span style="color:#f92672">::</span>chaine(<span style="color:#66d9ef">const</span> chaine <span style="color:#f92672">&amp;</span>Source)
{
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;                   <span style="color:#75715e">// Compteur de caractères.
</span><span style="color:#75715e"></span>    Taille <span style="color:#f92672">=</span> Source.Taille;
    s <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[Taille <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];    <span style="color:#75715e">// Effectue l&#39;allocation.
</span><span style="color:#75715e"></span>    strcpy(s, Source.s);         <span style="color:#75715e">// Recopie la chaîne de caractères source.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><p>Le constructeur de copie est appelé dans toute instanciation avec
initialisation, comme celles qui suivent</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">chaine <span style="color:#a6e22e">s2</span>(s1);
chainse s2 <span style="color:#f92672">=</span> s1;
</code></pre></div><p>Dans les deux exemples, c&rsquo;est le constructeur de copie qui est appelé. En
particulier, à la deuxième ligne, le constructeur normal n&rsquo;est pas appelé et
aucune affectation entre objets n&rsquo;a lieu.</p>
<h3 id="utilisation-des-constructeurs-dans-les-transtypages">Utilisation des constructeurs dans les transtypages</h3>
<p>Les constructeurs sont utilisés dans les conversions de type dans lesquelles le
type cible est celui de la classe du constructeur. Ces conversions peuvent être
soit implicites (dans une expression), soit explicite (à l&rsquo;aide d&rsquo;un
transtypage). Par défaut, les conversions implicites sont légales, pourvu qu&rsquo;il
existe un constructeur dont le premier paramètre a le même type que l&rsquo;objet
source. Par exemple, la classe Entier suivante :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Entier</span>
{
    <span style="color:#66d9ef">int</span> i;
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Entier(<span style="color:#66d9ef">int</span> j)
    {
        i<span style="color:#f92672">=</span>j;
        <span style="color:#66d9ef">return</span> ;
    }
};
</code></pre></div><p>dispose d&rsquo;un constructeur de transtypage pour les entiers. Les expressions</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;
Entier e1, e2<span style="color:#f92672">=</span>j;
e1<span style="color:#f92672">=</span>j;
</code></pre></div><p>sont donc légales, la valeur entière située à la droite de l&rsquo;expression étant
convertie implicitement en un objet du type de la classe Entier.</p>
<p>Si, pour une raison quelconque, ce comportement n&rsquo;est pas souhaitable, on peut
forcer le compilateur à n&rsquo;accepter que les conversions explicites (à l&rsquo;aide de
transtypage). Pour cela, il suffit de placer le mot clé <code>explicit</code> avant la
déclaration du constructeur. Par exemple, le constructeur de la classe chaine
vue ci-dessus prenant un entier en paramètre risque d&rsquo;être utilisé dans des
conversions implicites. Or ce constructeur ne permet pas de construire une
chaîne de caractères à partir d&rsquo;un entier, et ne doit pas être utilisé dans les
opérations de transtypage. Ce constructeur doit donc être déclaré <code>explicit</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">chaine</span>
{
    size_t Taille;
    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> s;
 
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    chaine(<span style="color:#66d9ef">void</span>);
    <span style="color:#75715e">// Ce constructeur permet de préciser la taille de la chaîne
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// à sa création :
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">explicit</span> <span style="color:#a6e22e">chaine</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>);
    <span style="color:#f92672">~</span>chaine(<span style="color:#66d9ef">void</span>);
};
</code></pre></div><p>Avec cette déclaration, l&rsquo;expression suivante</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;
chainse s<span style="color:#f92672">=</span>j;
</code></pre></div><p>n&rsquo;est plus valide, alors qu&rsquo;elle l&rsquo;était lorsque le constructeur n&rsquo;était pas
explicit.</p>
<h2 id="pointeur-this">Pointeur <code>this</code></h2>
<p>Nous allons à présent voir comment les fonctions membres, qui appartiennent à la
classe, peuvent accéder aux données d&rsquo;un objet, qui est une instance de cette
classe. Cela est indispensable pour bien comprendre les paragraphes suivants.</p>
<p>À chaque appel d&rsquo;une fonction membre, le compilateur passe implicitement un
pointeur sur les données de l&rsquo;objet en paramètre. Ce paramètre est le premier
paramètre de la fonction. Ce mécanisme est complètement invisible au programmeur,
et nous ne nous attarderons pas dessus.</p>
<p>En revanche, in faut savoir que le pointeur sur l&rsquo;objet est accessible à
l&rsquo;intérieur de la fonction membre. Il porte le nom <code>this</code>. Par conséquent,
<code>*this</code> représente l&rsquo;objet lui-même. Nous verrons une utilisation de <code>this</code> dans
le paragraphe suivant</p>
<p><code>this</code> est un pointeur constant, c&rsquo;est à dire qu&rsquo;on ne peut pas le modifier (il
est donc impossible de faire des opérations arithmétiques dessus). Cela est tout
à fait normal, puisque le faire reviendrait à sortir de l&rsquo;objet en cours (celui
pour lequel la méthode en cours d&rsquo;exécution travaille).</p>
<p>Il est possible de transformer ce pointeur constant en un pointeur constant sur
des données constantes pour chaque fonction membre. Le pointeur ne peut toujours
pas être modifié, et les données de l&rsquo;objet ne peuvent pas être modifiées non
plus. L&rsquo;objet est donc considéré par la fonction membre concernée comme un objet
constant. Cela revient à dire que la fonction membre s&rsquo;interdit la modification
des données de l&rsquo;objet. On parvient à ce résultat en ajoutant le mot clé <code>const</code>
à la suite de l&rsquo;en te de la fonction membre.</p>
<p>Il est à noter qu&rsquo;une méthode qui n&rsquo;est pas déclarée comme étant <code>const</code> modifie
a priori les données de l&rsquo;objet sur lequel elle travaille. Donc, si elle est
appelée sur un objet déclaré <code>const</code>, une erreur de compilation se produit. Ce
comportement est normal. On devra donc toujours déclarer <code>const</code> une méthode qui
ne modifie pas réellement l&rsquo;objet, afin de laisse à l&rsquo;utilisateur le choix de
déclarer <code>const</code> ou non les objets de sa classe.</p>
<h2 id="données-et-fonctions-membres-statiques">Données et fonctions membres statiques</h2>
<p>Nous allons voir dans ce paragraphe l&rsquo;emploi du mot clé <code>static</code> dans les
classes. Ce mot clé intervient pour caractériser les données membres statiques
des classes, les fonctions membres statiques des classes, et les données
statiques des fonctions membres.</p>
<h3 id="données-membres-statiques">Données membres statiques</h3>
<p>Une classe peut contenir des données membres statiques. Ces données sont soit
des données membres propres à la classe, soit des données locales statiques des
fonctions membres de la classe. Dans tous les cas, elles appartiennent à la
classe, et non pas aux objets de cette classe. Elles sont donc communes à tous
ces objets.</p>
<p>Il est impossible d&rsquo;initialiser les données d&rsquo;une classe dans le constructeur de
la classe, car le constructeur n&rsquo;initialise que les données des nouveaux objets.
Les données statiques ne sont pas spécifiques à un objet particulier et ne
peuvent donc pas être initialisées dans le constructeur. En fait, leur
initialisation doit se faire lors de leur définition, en dehors de la
déclaration de la classe. Pour préciser la classe à laquelle les données sont
définies appartiennent, on devra utiliser l&rsquo;opérateur de résolution de portée.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">test</span>
{
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> i;       <span style="color:#75715e">// Déclaration dans la classe.
</span><span style="color:#75715e"></span>    ...
};
 
<span style="color:#66d9ef">int</span> test<span style="color:#f92672">::</span>i<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>;         <span style="color:#75715e">// Initialisation en dehors de la classe.
</span></code></pre></div><p>La variable <code>test::i</code> sera partagée par tous les objets de classe test, et sa
valeur initiale est 3.</p>
<p>Les variables statiques des fonctions membres doivent être initialisées à
l&rsquo;intérieur des fonctions membres. Elles appartiennent également à la classe, et
non pas aux objets. De plus, leur portée est réduite à celle du bloc dans lequel
elles ont été déclarées. Ainsi le code suivante :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">test</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> n(<span style="color:#66d9ef">void</span>);
};
 
<span style="color:#66d9ef">int</span> test<span style="color:#f92672">::</span>n(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> compte<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">return</span> compte<span style="color:#f92672">++</span>;
}
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
    test objet1, objet2;
    printf(<span style="color:#e6db74">&#34;%d &#34;</span>, objet1.n());   <span style="color:#75715e">// Affiche 0
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, objet2.n());  <span style="color:#75715e">// Affiche 1
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>affichera 0 et 1, parque la variable statique compte est la même pour les deux
objets</p>
<h3 id="fonctions-membres-statiques">Fonctions membres statiques</h3>
<p>Les classes peuvent également contenir des fonctions membres statiques. Cela
peut surprendre à première vue, puisque les fonctions membres appartiennent déjà
à la classe, c&rsquo;est à dire à tous les objets. En fait, cela signifie que ces
fonctions membres ne recevront pas le pointeur sur l&rsquo;objet <code>this</code>, comme c&rsquo;est
le cas pour les autres fonctions membres. Par conséquent, elles ne pourront
accéder qu&rsquo;aux données statiques de l&rsquo;objet</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Entier</span>
{
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> j;
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> get_value(<span style="color:#66d9ef">void</span>);
};
 
<span style="color:#66d9ef">int</span> Entier<span style="color:#f92672">::</span>j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
 
<span style="color:#66d9ef">int</span> Entier<span style="color:#f92672">::</span>get_value(<span style="color:#66d9ef">void</span>)
{
    j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;         <span style="color:#75715e">// Légal.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> i;    <span style="color:#75715e">// ERREUR ! get_value ne peut pas accéder à i.
</span><span style="color:#75715e"></span>}
</code></pre></div><p>La fonction <code>get_value</code> de l&rsquo;exemple ci-dessus ne peut pas accéder à la donnée
membre non statique <code>i</code>, parce qu&rsquo;elle ne travaille sur aucun objet. Son champ
d&rsquo;action est uniquement la classe Entier. En revanche, elle peut modifier la
variable statique <code>j</code>, puisque celle-ci appartient à la classe Entier et non aux
objets de cette classe.</p>
<p>L&rsquo;appel des fonctions membre statiques se fait exactement comme celui des
fonctions membres non statiques, en spécifiant l&rsquo;identificateur d&rsquo;un des objets
de la classe et le nom de la fonction membre, séparés par un point. Cependant,
comme les fonctions membres ne travaillent pas sur les objets des classes mais
plutôt sur les classes elles-mêmes, la présence de l&rsquo;objet lors de l&rsquo;appel est
facultatif. On peut donc se contenter d&rsquo;appeler une fonction statique en
qualifiant son nom du nom de la classe à laquelle elle appartient à l&rsquo;aide de
l&rsquo;opérateur de résolution de portée.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Entier</span>
{
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> i;
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> get_value(<span style="color:#66d9ef">void</span>);
};
 
<span style="color:#66d9ef">int</span> Entier<span style="color:#f92672">::</span>i<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>;
 
<span style="color:#66d9ef">int</span> Entier<span style="color:#f92672">::</span>get_value(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#66d9ef">return</span> i;
}
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#75715e">// Appelle la fonction statique get_value :
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> resultat<span style="color:#f92672">=</span>Entier<span style="color:#f92672">::</span>get_value();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Les fonctions membres statiques sont souvent utilisées afin de regrouper un
certain nombre de fonctionnalités en rapport avec leur classe. Ainsi, elles sont
facilement localisable et les risques de conflits de noms entre deux fonctions
membres homonymes sont réduits. Nous verrons également plus tard comment éviter
les conflits de noms globaux dans le cadre des espaces de nommage.</p>
<h2 id="surcharge-des-opérateurs">Surcharge des opérateurs</h2>
<p>On a vu précédemment que les opérateurs ne se différencient des fonctions que
syntaxiquement, pas logiquement. D&rsquo;ailleurs, le compilateur traite un appel à un
opérateur comme un appel à une fonction. Le C++ permet donc de surcharger les
opérateurs pour les classes définies par l&rsquo;utilisateur, en utilisant une
syntaxe particulière calquée sur la syntaxe utilisée pour définir des fonctions
membres normales. En fait, il est même possible de surcharger les opérateurs du
langage pour les classes de l&rsquo;utilisateur en dehors de la définition de ces
classes. Le C++ dispose donc de deux méthodes différentes pour surcharger les
opérateurs.</p>
<p>Nous allons à présent voir dans les sections suivantes les deux syntaxes
permettant de surcharger les opérateurs pour les types de l&rsquo;utilisateur, ainsi
que les règles spécifiques à certains opérateurs particuliers.</p>
<h3 id="surcharge-des-opérateurs-internes">Surcharge des opérateurs internes</h3>
<p>Une première méthode pour surcharger les opérateurs consiste à les considérer
comme des méthodes normales de la classe sur laquelle ils s&rsquo;appliquent. Le nom
de ces méthodes est donné par le mot clé <code>operator</code>, suivi de l&rsquo;opérateur à
surcharger. Le type de la fonction de l&rsquo;opérateur est le type du résultat donné
par l&rsquo;opération, et les paramètres, donnés entre parenthèses, sont les
opérandes. Les opérateurs de ce type sont appelés opérateurs internes, parce
qu&rsquo;ils sont déclarés à l&rsquo;intérieur de la classe.</p>
<p>Avec cette syntaxe, le premier opérande est toujours l&rsquo;objet auquel cette
fonction s&rsquo;applique. Cette manière de surcharger les opérateurs est donc
particulièrement bien adaptée pour les opérateurs qui modifient l&rsquo;objet sur
lequel ils travaillent, comme par exemple ,es opérateurs =, +=, ++, etc. Les
paramètres de la fonction opérateur sont alors le deuxième opérande et les
suivants.</p>
<p>Les opérateurs définis en interne devront souvent renvoyer l&rsquo;objet sur lequel
ils travaillent (ce n&rsquo;est pas une nécessité cependant). Cela est faisable grâce
au pointeur <code>this</code>.</p>
<h3 id="surcharge-des-opérateurs-externes">Surcharge des opérateurs externes</h3>
<p>Une deuxième possibilité nous est offerte par le langage pour surcharger les
opérateurs. La définition de l&rsquo;opérateur ne se fait plus dans la classe qui
l&rsquo;utilise, mais en dehors de celle-ci, par surcharge d&rsquo;un opérateur de l&rsquo;espace
de nommage global. Il s&rsquo;agit donc d&rsquo;opérateurs externes cette fois.</p>
<p>La surcharge des opérateurs externes se fait donc exactement comme on surcharge
les fonctions normales. Dans ce cas, tous les opérandes de l&rsquo;opérateur devront
être passés en paramètres : il n&rsquo;y aura pas de paramètre implicite (le pointeur
<code>this</code> n&rsquo;est pas passé en paramètre).</p>
<p>L&rsquo;avantage de cette syntaxe est que l&rsquo;opérateur est réellement symétrique,
contrairement à ce qui se passe pour ces opérateurs définis à l&rsquo;intérieur de la
classe. Ainsi, si l&rsquo;utilisation de cet opérateur nécessite un transtypage sur
l&rsquo;un des opérandes, il n&rsquo;est pas nécessaire que cet opérande soit
obligatoirement le deuxième. Donc si la classe dispose de constructeurs
permettant de convertir un type de donnée en son propre type, ce type de donnée
peut être utilisé avec tous les opérateurs de la classe.</p>
<p>On constatera que les opérateurs externes doivent être déclarés comme étant des
fonctions amies de la classe sur laquelle ils travaillent, faut de quoi ils ne
pourraient pas manipuler les données membres de leurs opérandes.</p>
<p>La syntaxe des opérateurs externes permet également d&rsquo;implémenter les opérateurs
pour lesquels le type de la valeur de retour est celui de l&rsquo;opérande de gauche
et que le type de cet opérande n&rsquo;est pas une classe définie par l&rsquo;utilisateur
(par exemple si c&rsquo;est un type prédéfini). En effet, on ne peut pas définir
l&rsquo;opérateur à l&rsquo;intérieur de la classe du premier opérande dans ce cas, puisque
cette classe est déjà définie. De même, cette syntaxe peut être utile dans le
cas de l&rsquo;écriture d&rsquo;opérateurs optimisés pour certains types de données, pour
lesquels les opérations réalisées par l&rsquo;opérateur sont plus simples que celles
qui auraient été effectuées après transtypage.</p>

					</div>
					<div class="post-comments">
						
					</div>
				</div>
			</div>
      <div class="col-md-4">
        <aside class="sidebar">





















































<div class="widget widget-latest-post">
    <h4 class="widget-title">Derniers cours</h4>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/semestre9/energie/2/">Généralités sur les machines tournantes</a></h4>
        <h5>[Énergie]</h5>
        <p>La constitution d&rsquo;une machine tournante est …</p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/semestre9/energie/1/">Grandeurs éléectriques utiles, définition de l&#39;actionneur, plan mécanique couple-vitesse, transmission mécanique</a></h4>
        <h5>[Énergie]</h5>
        <p>Régime des grandeurs électriques rencontrées …</p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/semestre9/modelisation/1/">Mouvements, changements de coordonnées</a></h4>
        <h5>[Modélisation]</h5>
        <p>Repère affine $[O_i, R_i = {x_i, y_i z_i}]$ Une …</p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/semestre9/imagerie/2/">Introduction</a></h4>
        <h5>[Outils d&#39;imagerie]</h5>
        <p>Cours Traitements classiques couleur $$\{(A,B,C)= …</p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/semestre9/interaction/1/">Introduction à la cobotique</a></h4>
        <h5>[Interactions homme robot]</h5>
        <p>Introduction Pourquoi fait on de la robotique ? …</p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/semestre9/imagerie/1/">Introduction</a></h4>
        <h5>[Outils d&#39;imagerie]</h5>
        <p>Cours Commençons par définir les différents termes …</p>
      </div>
    </div>
    
  </div>
</aside>


      </div>
		</div>
	</div>
</section>

<footer class="footer">
	<div class="container">
		<div class="row">
			<div class="col-md-12">
				<div class="footer-manu">
					<ul>
            
					</ul>
				</div>
				<p class="copyright">Copyright © 2020 <a href="https://themefisher.com">Themefisher</a> All Rights Reserved</p>
			</div>
		</div>
	</div>
</footer>



<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCcABaamniA6OL5YvYSpB3pFMNrXwXnLwU&amp;libraries=places"></script>




<script src="https://Sdelpeuch.github.io/plugins/jQuery/jquery.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/bootstrap/bootstrap.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/slick/slick.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/magnific-popup/jquery.magnific-popup.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/shuffle/shuffle.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/google-map/gmap.js"></script>




<script src="https://Sdelpeuch.github.io/js/script.min.js"></script>







<script src="https://cdnjs.cloudflare.com/ajax/libs/js-cookie/2.2.1/js.cookie.min.js"></script>
<div id="js-cookie-box" class="cookie-box cookie-box-hide">
	This site uses cookies. By continuing to use this website, you agree to their use. <span id="js-cookie-button" class="btn btn-main btn-solid-border">I Accept</span>
</div>
<script>
	(function ($) {
		const cookieBox = document.getElementById('js-cookie-box');
		const cookieButton = document.getElementById('js-cookie-button');
		if (!Cookies.get('cookie-box')) {
			cookieBox.classList.remove('cookie-box-hide');
			cookieButton.onclick = function () {
				Cookies.set('cookie-box', true, {
					expires:  2 
				});
				cookieBox.classList.add('cookie-box-hide');
			};
		}
	})(jQuery);
</script>


<style>
.cookie-box {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  text-align: center;
  z-index: 9999;
  padding: 1rem 2rem;
  background: rgb(71, 71, 71);
  transition: all .75s cubic-bezier(.19, 1, .22, 1);
  color: #fdfdfd;
}

.cookie-box-hide {
  display: none;
}
</style>
</body>

</html>