"use strict";(self.webpackChunksedelpeuch_net=self.webpackChunksedelpeuch_net||[]).push([[6348],{62750:(e,r,s)=>{s.r(r),s.d(r,{assets:()=>l,contentTitle:()=>u,default:()=>a,frontMatter:()=>t,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"enseirb/s7/prog_sys/11","title":"Les verous de fichiers","description":"M\xe9canismes de contr\xf4le d\'acc\xe8s concurrents \xe0 un fichier, les verrous sont d\'une","source":"@site/docs/enseirb/s7/prog_sys/11.md","sourceDirName":"enseirb/s7/prog_sys","slug":"/enseirb/s7/prog_sys/11","permalink":"/pr-preview/pr-15/docs/enseirb/s7/prog_sys/11","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Les verous de fichiers"},"sidebar":"tutorialSidebar","previous":{"title":"Les signaux","permalink":"/pr-preview/pr-15/docs/enseirb/s7/prog_sys/10"},"next":{"title":"Algorithmes Distribu\xe9s & Interblocages","permalink":"/pr-preview/pr-15/docs/enseirb/s7/prog_sys/12"}}');var i=s(74848),o=s(28453);const t={title:"Les verous de fichiers"},u=void 0,l={},c=[{value:"Caract\xe9ristiques d&#39;un verrou",id:"caract\xe9ristiques-dun-verrou",level:2},{value:"Le mode op\xe9ratoire des verrous",id:"le-mode-op\xe9ratoire-des-verrous",level:2},{value:"Manipulation des verrous",id:"manipulation-des-verrous",level:2},{value:"Utilisation de <code>fcntl</code> pour manipuler les verrous",id:"utilisation-de-fcntl-pour-manipuler-les-verrous",level:2}];function d(e){const r={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["M\xe9canismes de contr\xf4le d'acc\xe8s concurrents \xe0 un fichier, les verrous sont d'une\ngrande utilit\xe9 dans les applications de gestion et dans l'\xe9laboration de bases\nde donn\xe9es partag\xe9es. Les verrous sont rattach\xe9s aux ",(0,i.jsx)(r.strong,{children:"inoeuds"}),". Ainsi toutes\nles ouvertures d'un m\xeame fichier, et \xe0 fortiori tous les descripteurs sur ces\nouvertures, voient le verrou. La protection r\xe9alis\xe9e par le verrou a donc lieu\nsur le fichier physique. Un verrou est la ",(0,i.jsx)(r.strong,{children:"propri\xe9t\xe9"})," d'un seul ",(0,i.jsx)(r.strong,{children:"processus"}),",\net seul le processus propri\xe9taire du verrou peut le modifier ou l'enlever,\nattention le verrou ne prot\xe8ge pas contre les acc\xe8s du processus propri\xe9taire"]}),"\n",(0,i.jsx)(r.h2,{id:"caract\xe9ristiques-dun-verrou",children:"Caract\xe9ristiques d'un verrou"}),"\n",(0,i.jsx)(r.p,{children:"Les verrous sont d\xe9finis par deux caract\xe9ristiques"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"La port\xe9e"})," : ensemble de positions du fichier auxquelles le verrou\ns'applique. Cet ensemble est un intervalle, soit une portion de fichier\n",(0,i.jsx)(r.code,{children:"[position1, position2]"})," soit jusqu'\xe0 la fin du fichier ",(0,i.jsx)(r.code,{children:"[position1, fin de fichier["})," dans ce dernier cas si le fichier augmente, le verrou prot\xe8ge les\nnouvelles positions"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Le type"})," : qui d\xe9crit les possibilit\xe9s de cohabitation des diff\xe9rents\nverrous"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"le-mode-op\xe9ratoire-des-verrous",children:"Le mode op\xe9ratoire des verrous"}),"\n",(0,i.jsxs)(r.p,{children:["Le mode op\xe9ratoire joue sur le comportement des primitives ",(0,i.jsx)(r.code,{children:"read"})," et ",(0,i.jsx)(r.code,{children:"write"}),".\nLes verrous d'un fichier sont soit consultatifs soit imp\xe9ratifs. Dans le premier\nmode, la pr\xe9sence d'un verrou n'est test\xe9e qu'\xe0 la pose d'un verrou, la pose\nsera refus\xe9e s'il existe un verrou de port\xe9e non disjointe et que l'un des deux\nverrous est exclusif. Dans le second mode, la pr\xe9sence de verrous est test\xe9e\npour la pose mais aussi pour les appels syst\xe8mes ",(0,i.jsx)(r.code,{children:"read"})," et ",(0,i.jsx)(r.code,{children:"write"}),". Dans le mode\nconsultatif, les verrous n'ont d'effet que sur les processus jouant\neffectivement le jeu, c'est \xe0 dire, posant des verrous sur les zones du fichiers\nsur lesquels ils veulent r\xe9aliser une lecture (verrou partag\xe9) ou une \xe9criture\n(verrou exclusif)."]}),"\n",(0,i.jsx)(r.p,{children:"Dans le mode imp\xe9ratif, les verrous ont un impact sur les lectures / \xe9critures\nde tous les processus :"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"sur les verrous de type partag\xe9, toute tentative d'\xe9criture par un autre\nprocessus est bloqu\xe9e"}),"\n",(0,i.jsx)(r.li,{children:"sur les verrous de type exclusif, toute tentative de lecture ou d'\xe9criture par\nun autre processus est bloqu\xe9e"}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["Pour rendre l'utilisation imp\xe9rative il faut sous linux monter le disque avec\nl'option ",(0,i.jsx)(r.code,{children:"-o mand"}),". Puis il faut utiliser la commande ",(0,i.jsx)(r.code,{children:"chmod"})," pour positionner\nle ",(0,i.jsx)(r.code,{children:"SETGID bit"})]}),"\n",(0,i.jsx)(r.h2,{id:"manipulation-des-verrous",children:"Manipulation des verrous"}),"\n",(0,i.jsxs)(r.p,{children:["La structure de verrou ",(0,i.jsx)(r.code,{children:"flock"})," :"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:"struct flock{\n    short l_type; //F_RDLCK (verrou partag\xe9), F_WRLCK (verrou exclusif), F_UNCLK (d\xe9verrouillage)\n    short l_whence; //SEEK_SET, SEEK_CUR, SEEK_END\n    off_t l_start; //position relative \xe0 l_whence\n    off_t l_len; //longueur de l'intervalle\n    pid_t l_pid; //PID du processus propri\xe9taire\n};\n"})}),"\n",(0,i.jsxs)(r.p,{children:["Les manipulations de verrous se font avec la primitive ",(0,i.jsx)(r.code,{children:"fcntl"}),", c'est \xe0 dire par\nle biais d'un descripteur. Pour poser un verrou partag\xe9, ce descripteur doit\npointer sur une ouverture en lecture. De m\xeame, il faut un descripteur sur une\nouverture en \xe9criture pour un verrou de type exclusif"]}),"\n",(0,i.jsxs)(r.p,{children:["Pour d\xe9crire la port\xe9e du verrou que l'on veut poser, on utilise la m\xeame syntaxe\nque pour la primitive ",(0,i.jsx)(r.code,{children:"lseek"}),", le d\xe9but de l'intervalle est ",(0,i.jsx)(r.code,{children:"whence+l_start"})]}),"\n",(0,i.jsxs)(r.p,{children:["La longueur du verrou est d\xe9finie par le champ ",(0,i.jsx)(r.code,{children:"l_len"}),". Si cette valeur est\nnulle, le verrou va jusqu'\xe0 la fin du fichier. Le champ ",(0,i.jsx)(r.code,{children:"l_pid"})," contient le pid\ndu processus propri\xe9taire du verrou, ce champ est rempli par ",(0,i.jsx)(r.code,{children:"fcntl"})," dans le cas\nd'un appel consultatif (",(0,i.jsx)(r.code,{children:"F_GETLK"}),")."]}),"\n",(0,i.jsxs)(r.h2,{id:"utilisation-de-fcntl-pour-manipuler-les-verrous",children:["Utilisation de ",(0,i.jsx)(r.code,{children:"fcntl"})," pour manipuler les verrous"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-c",children:"#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\nint fcntl(int desc, int commande, struct flock *verrou);\n"})}),"\n",(0,i.jsx)(r.p,{children:"Trois commandes sont possible :"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"F_SETLK"})," pose non bloquante"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"F_SETLKW"})," pose bloquante (Wait)"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"F_GETLK"})," test d'existence d'un verrou incompatible avec le verrou pass\xe9 en\nparam\xe8tre"]}),"\n"]})]})}function a(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,r,s)=>{s.d(r,{R:()=>t,x:()=>u});var n=s(96540);const i={},o=n.createContext(i);function t(e){const r=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function u(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),n.createElement(o.Provider,{value:r},e.children)}}}]);