"use strict";(self.webpackChunksedelpeuch_net=self.webpackChunksedelpeuch_net||[]).push([[2814],{53707:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>r,toc:()=>d});var t=n(85893),a=n(11151);const l={title:"La couche objet - Partie 1 : Classe, H\xe9ritage, Classe virtuelle, fonction et classes amies"},i=void 0,r={id:"enseirb/s7/cpp/1",title:"La couche objet - Partie 1 : Classe, H\xe9ritage, Classe virtuelle, fonction et classes amies",description:"La couche objet constitue sans doute la plus grande innovation du C++ par",source:"@site/docs/enseirb/s7/cpp/1.md",sourceDirName:"enseirb/s7/cpp",slug:"/enseirb/s7/cpp/1",permalink:"/pr-preview/pr-7/docs/enseirb/s7/cpp/1",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"La couche objet - Partie 1 : Classe, H\xe9ritage, Classe virtuelle, fonction et classes amies"},sidebar:"tutorialSidebar",previous:{title:"Programmation C++",permalink:"/pr-preview/pr-7/docs/enseirb/s7/cpp/"},next:{title:"La couche objet - Partie 2 : Constructeur, Destructeurs, Pointeur this, Statique, Surcharge",permalink:"/pr-preview/pr-7/docs/enseirb/s7/cpp/2"}},o={},d=[{value:"G\xe9n\xe9ralit\xe9s",id:"g\xe9n\xe9ralit\xe9s",level:2},{value:"Extensions de la notion de type du C",id:"extensions-de-la-notion-de-type-du-c",level:2},{value:"D\xe9claration de classes en C++",id:"d\xe9claration-de-classes-en-c",level:2},{value:"Encapsulation des donn\xe9es",id:"encapsulation-des-donn\xe9es",level:2},{value:"H\xe9ritage",id:"h\xe9ritage",level:2},{value:"Classes virtuelles",id:"classes-virtuelles",level:2},{value:"Fonctions et classes amies",id:"fonctions-et-classes-amies",level:2},{value:"Fonctions amies",id:"fonctions-amies",level:3},{value:"Classes amies",id:"classes-amies",level:3}];function c(e){const s={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.p,{children:"La couche objet constitue sans doute la plus grande innovation du C++ par\nrapport au C. Le but de la programmation objet est de permettre une abstraction\nentre l'impl\xe9mentation des modules et leur utilisation, apportant ainsi un plus\ngrand confort dans la programmation. Elle s'int\xe8gre donc parfaitement dans le\ncadre de la modularit\xe9. Enfin, l'encapsulation des donn\xe9es permet une meilleure\nprotection et donc une plus grande fiabilit\xe9 des programmes."}),"\n",(0,t.jsx)(s.h2,{id:"g\xe9n\xe9ralit\xe9s",children:"G\xe9n\xe9ralit\xe9s"}),"\n",(0,t.jsx)(s.p,{children:"Th\xe9oriquement, il y a une nette distinction entre les donn\xe9es et les op\xe9rations\nqui leur sont appliqu\xe9s. En tout cas, les donn\xe9es et le code ne se m\xe9langent pas\ndans la m\xe9moire de l'ordinateur, sauf cas particulier. Cependant l'analyse des\nprobl\xe8mes \xe0 traiter se pr\xe9sente d'une mani\xe8re plus naturelle si l'on consid\xe8re\nles donn\xe9es avec leurs propri\xe9t\xe9s. Les donn\xe9es constituent les variables, et les\npropri\xe9t\xe9s les op\xe9rations qu'on peut leur appliquer. De ce point de vue, les\ndonn\xe9es et le code sont logiquement ins\xe9parables, m\xeame s'ils sont plac\xe9s en\ndiff\xe9rents endroits de la m\xe9moire de l'ordinateur."}),"\n",(0,t.jsx)(s.p,{children:"Ces consid\xe9rations conduisent \xe0 la notion d'objet. Un objet est un ensemble de\ndonn\xe9es sur lesquelles des proc\xe9dures peuvent \xeatre appliqu\xe9es. Ces proc\xe9dures ou\nfonctions applicables aux donn\xe9es sont appel\xe9es m\xe9thodes. La programmation d'un\nobjet se fait donc en indiquant les donn\xe9es de l'objet et en d\xe9finissant les\nproc\xe9dures qui peuvent lui \xeatre appliqu\xe9es. Il se peut qu'il y ait plusieurs\nobjets identiques, dont les donn\xe9es ont bien entendu des valeurs diff\xe9rentes,\nmais qui utilisent le m\xeame jeu de m\xe9thodes. On dit que ces diff\xe9rents objets\nappartiennent \xe0 la m\xeame classe d'objets. Une classe constitue donc une sorte de\ntype, et les objets de cette classe en sont des instances. La classe d\xe9finit\ndonc la structure des donn\xe9es, alors appel\xe9es champs ou variables d'instances,\nque les objets correspondants auront, ainsi que les m\xe9thodes de l'objet. \xc0\nchaque instanciation, une allocation de m\xe9moire est faite pour les donn\xe9es du\nnouvel objet cr\xe9\xe9. L'initialisation de l'objet est d\xe9truit, une autre m\xe9thode\nest appel\xe9e : le destructeur. L'utilisateur peut d\xe9finir ses propres\nconstructeurs et destructeurs d'objets si n\xe9cessaire."}),"\n",(0,t.jsx)(s.p,{children:"Comme seules les valeurs des donn\xe9es des diff\xe9rents objets d'une classe\ndiff\xe8rent, les m\xe9thodes sont mises en commun pour tous les objets d'une m\xeame\nclasse (c'est \xe0 dire que les m\xe9thodes ne sont pas recopi\xe9es). Pour que les\nm\xe9thodes appel\xe9es pour un objet sachent sur quelles donn\xe9es elles doivent\ntravailler, un pointeur sur l'objet contenant ces donn\xe9es leur est pass\xe9 en\nparam\xe8tre. Ce m\xe9canisme est compl\xe8tement transparent pour le programmeur en C++.\nNous voyons donc que non seulement la programmation orient\xe9e objet est plus\nlogique, mais elle est \xe9galement plus efficace (les m\xe9thodes sont mises en\ncommun, les donn\xe9es sont s\xe9par\xe9es)."}),"\n",(0,t.jsx)(s.p,{children:"Enfin, les donn\xe9es des objets peuvent \xeatre prot\xe9g\xe9es : c'est \xe0 dire que seules\nles m\xe9thodes de l'objet peuvent y acc\xe9der. Ce n'est pas une obligation, mais\ncela accro\xeet la fiabilit\xe9 des programmes. Si une erreur se produit, seules les\nm\xe9thodes de l'objet doivent \xeatre v\xe9rifi\xe9es. De plus, les m\xe9thodes constituent\nainsi une interface entre les donn\xe9es de l'objet et l'utilisateur de l'objet.\nCet utilisateur n'a donc pas \xe0 savoir comment les donn\xe9es sont g\xe9r\xe9es dans\nl'objet, il ne doit utiliser que les m\xe9thodes. Les avantages sont imm\xe9diats : il\nne risque pas de faire des erreurs de programmation en modifiant les donn\xe9es\nlui-m\xeame, l'objet est r\xe9utilisable dans un autre programme parce qu'il a une\ninterface standardis\xe9e, et on peut modifier l'impl\xe9mentation interne de l'objet\nsans avoir \xe0 refaire tout le programme, pourvu que les m\xe9thodes gardent le m\xeame\nnom, les m\xeames param\xe8tres et la m\xeame s\xe9mantique. Cette notion de protection des\ndonn\xe9es et de masquage de l'impl\xe9mentation interne aux utilisateurs de l'objet\nconstitue ce que l'on appelle l'encapsulation. Les avantages de l'encapsulation\nseront souvent mis en valeur dans la suite au travers d'exemples."}),"\n",(0,t.jsx)(s.h2,{id:"extensions-de-la-notion-de-type-du-c",children:"Extensions de la notion de type du C"}),"\n",(0,t.jsx)(s.p,{children:"Il faut avant tout savoir que la couche objet n'est pas un simple ajout au\nlangage C, c'est une v\xe9ritable extension. En effet, les notions qu'elles a\napport\xe9es ont \xe9t\xe9 int\xe9gr\xe9es au C \xe0 tel point que le typage des donn\xe9es de C a\nfusionn\xe9 avec la notion de classe. Ainsi, les types pr\xe9d\xe9finis char, int,\ndouble, etc repr\xe9sentent \xe0 pr\xe9sent l'ensemble des propri\xe9t\xe9s des variables ayant\nce type. Ces propri\xe9t\xe9s constituent la classe de ces variables, et elles sont\naccessibles par les op\xe9rateurs. Par exemple, l'addition est une op\xe9ration\npouvant porter sur des entiers qui renvoie un objet de la classe entier. Par\ncons\xe9quent, les types de base se manipuleront exactement comme des objets. Du\npoint de vue du C++, les utiliser revient d\xe9j\xe0 \xe0 faire de la programmation\norient\xe9e objet."}),"\n",(0,t.jsx)(s.p,{children:"De m\xeame, le programmeur peut, \xe0 l'aide de la notion de classe d'objets, d\xe9finir\nde nouveaux types. Ces types comprennent la structure des donn\xe9es repr\xe9sent\xe9es\npar ces types et les op\xe9rations qui peuvent leur \xeatre appliqu\xe9es. En fait, le\nC++ assimile compl\xe8tement les classes avec les types, et la d\xe9finition d'un\nnouveau type se fait donc en d\xe9finissant la classes des variables de ce type."}),"\n",(0,t.jsx)(s.h2,{id:"d\xe9claration-de-classes-en-c",children:"D\xe9claration de classes en C++"}),"\n",(0,t.jsx)(s.p,{children:"Afin de permettre la d\xe9finition des m\xe9thodes qui peuvent \xeatre appliqu\xe9es aux\nstructures des classes C++, la syntaxe des structures C a \xe9t\xe9 \xe9tendue. Il est \xe0\npr\xe9sent possible de d\xe9finir compl\xe8tement des m\xe9thodes dans la d\xe9finition de la\nstructure. Cependant il est pr\xe9f\xe9rable de la reporter et de ne laisser que leur\nd\xe9claration dans la structure. En effet, cela accro\xeet la lisibilit\xe9 et permet de\nmasquer l'impl\xe9mentation de la classe \xe0 ses utilisateurs en ne leur montrant que\nsa d\xe9claration dans un fichier d'en t\xeate. Ils ne peuvent donc ni la voir, ni la\nmodifier. La syntaxe est la suivante :"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"class Nom{\n    attribute; \n    methode;\n}\n"})}),"\n",(0,t.jsxs)(s.p,{children:["o\xf9 ",(0,t.jsx)(s.code,{children:"Nom"})," est le nom de la classe. Elle peut contenir divers champs de divers\ntypes. Les m\xe9thodes peuvent \xeatre des d\xe9finitions de fonctions, ou seulement\nleurs d\xe9clarations. Si on ne donne que leurs d\xe9clarations, on devra les d\xe9finir\nplus loin. Pour cela, il faudra sp\xe9cifier la classe \xe0 laquelle elles\nappartiennent avec la syntaxe suivante"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"type classe:nom(param\xe8tres){\n    //d\xe9finition de la m\xe9thode\n}\n"})}),"\n",(0,t.jsxs)(s.p,{children:["La syntaxe est donc identique \xe0 la d\xe9finition d'une fonction normale, \xe0 la\ndiff\xe9rence pr\xe8s que leur nom est pr\xe9c\xe9d\xe9 du nom de la classe \xe0 laquelle elles\nappartiennent et deux deux points. Cet op\xe9rateur ",(0,t.jsx)(s.code,{children:"::"})," est appel\xe9 l'op\xe9rateur de\nr\xe9solution de port\xe9e. Il permet, d'une mani\xe8re g\xe9n\xe9rale, de sp\xe9cifier le bloc\nauquel l'objet qui le suit appartient. Ainsi, le fait de pr\xe9c\xe9der le nom de la\nm\xe9thode par le nom de la classe permet au compilateur de savoir de quelle classe\ncette m\xe9thode fait partie. Rien n'interdit, en effet, d'avoir des m\xe9thodes de\nm\xeame signature, pourvu qu'elles soient dans des classes diff\xe9rentes."]}),"\n",(0,t.jsx)(s.p,{children:"De m\xeame, l'op\xe9rateur de r\xe9solution de port\xe9e permettra d'acc\xe9der \xe0 une variable\nglobale lorsqu'une autre variable homonyme aura \xe9t\xe9 d\xe9finie dans le bloc en\ncours. Les champs d'une classe peuvent \xeatre acc\xe8des comme des variables normales\ndans les m\xe9thodes de cette classes."}),"\n",(0,t.jsx)(s.p,{children:"L'acc\xe8s aux m\xe9thodes de la classe se fait comme pour acc\xe9der aux champs des\nstructures. On donne le nom de l'objet et le nom du champ ou de la m\xe9thode,\ns\xe9par\xe9s par un point. Par exemple :"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"int i; \nfor (i=0; i<100; ++i)\n    if(clientele[i].dans_le_rouge()) relance(clientele[i]);\n"})}),"\n",(0,t.jsx)(s.p,{children:"Lorsque les fonctions membres d'une classe sont d\xe9finies dans la d\xe9claration de\ncette classe, le compilateur les impl\xe9mente en inline. Si les m\xe9thodes ne sont\npas d\xe9finies dans la classe, la d\xe9claration de la classe sera mise dans un\nfichier d'en-t\xeate, et la d\xe9finition des m\xe9thodes sera report\xe9e dans un fichier\nC++, ce qui sera compil\xe9 et li\xe9 aux autres fichiers utilisant la classe client.\nBien entendu, il est toujours possible de d\xe9clarer les fonctions membres comme\n\xe9tant des fonctions inline m\xeame lorsqu'elles sont d\xe9finies en dehors de la\nd\xe9claration de la classe. Pour cela, il faut utiliser le mot cl\xe9 inline, et\nplacer le code de ces fonctions dans le fichier d'en-t\xeate."}),"\n",(0,t.jsx)(s.h2,{id:"encapsulation-des-donn\xe9es",children:"Encapsulation des donn\xe9es"}),"\n",(0,t.jsxs)(s.p,{children:["Les divers champs d'une structure sont accessibles en n'importe quel endroit du\nprogramme. Une op\xe9ration telle que celle-ci est donc faisable\n",(0,t.jsx)(s.code,{children:"clientele[0].Sole=25 000;"}),". Le solde d'un client peut donc \xeatre modifi\xe9 sans\npasser par une m\xe9thode dont ce serait le but. Elle pourrait par exemple v\xe9rifier\nque l'on n'affecte pas un solde sup\xe9rieur au solde maximal autoris\xe9 par le\nprogramme (la borne sup\xe9rieure des valeurs des entiers sign\xe9s)."]}),"\n",(0,t.jsx)(s.p,{children:"Il est possible d'emp\xeacher l'acc\xe8s des champs ou de certaines m\xe9thodes \xe0 toute\nfonction autre que celles de la classe. Cette op\xe9ration s'appelle\nl'encapsulation. Pour la r\xe9aliser il faut utiliser les mots cl\xe9s suivants :"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"public"})," : les acc\xe8s sont libres"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"private"})," : les acc\xe8s sont autoris\xe9s dans les fonctions de classe seulement"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"protected"})," : les acc\xe8s sont autoris\xe9s dans les fonctions de la classe et de\nses descendantes (voir la section suivante) seulement. Le mot cl\xe9 ",(0,t.jsx)(s.code,{children:"protected"}),"\nn'est utilis\xe9 que dans le cadre de l'h\xe9ritage des classes. La section suivante\nd\xe9taillera ce point."]}),"\n",(0,t.jsx)(s.p,{children:"Pour changer les droits d'acc\xe8s des champs et des m\xe9thodes d'une classe, il\nfaut faire pr\xe9c\xe9der ceux-ci du mot cl\xe9 indiquant les droits d'acc\xe8s suivi des\ndeux points. Par exemple pour prot\xe9ger les donn\xe9es relatives au client, on\nchangera simplement la d\xe9claration de la classe en :"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"class client\n{\nprivate:   // Donn\xe9es priv\xe9es :\n \n    char Nom[21], Prenom[21];\n    unsigned int Date_Entree;\n    int Solde;\n    // Il n'y a pas de m\xe9thode priv\xe9e.\n \npublic:    // Les donn\xe9es et les m\xe9thodes publiques :\n \n    // Il n'y a pas de donn\xe9e publique.\n    bool dans_le_rouge(void);\n    bool bon_client(void)\n};\n"})}),"\n",(0,t.jsx)(s.p,{children:"Outre la v\xe9rification de la validit\xe9 des op\xe9rations l'encapsulation a comme\nint\xe9r\xeat fondamental de d\xe9finir une interface stable pour la classe au niveau des\nm\xe9thodes et donn\xe9es membres publiques et prot\xe9g\xe9es. L'impl\xe9mentation de cette\ninterface, r\xe9alis\xe9e en priv\xe9, peut \xeatre modifi\xe9e \xe0 loisir sans pour autant\nperturber les utilisateurs de cette classe, tant que cette interface n'est pas\nelle-m\xeame modifi\xe9e."}),"\n",(0,t.jsxs)(s.p,{children:["Par d\xe9faut, les classes construites avec ",(0,t.jsx)(s.code,{children:"struct"})," ont tous les membres publics.\nLes classes construites avec \u0300class` ont tous les membres priv\xe9s."]}),"\n",(0,t.jsx)(s.h2,{id:"h\xe9ritage",children:"H\xe9ritage"}),"\n",(0,t.jsx)(s.p,{children:"L'h\xe9ritage permet de donner \xe0 une classe toutes les caract\xe9ritiques d'une ou de\nplusieurs autres classes. Les classes dont elle h\xe9rite sont appel\xe9es classes\nm\xe8res, classes de base ou classes ant\xe9c\xe9dentes. La classe elle-m\xeame est appel\xe9e\nclasse file, classe d\xe9riv\xe9e ou classe descendante."}),"\n",(0,t.jsx)(s.p,{children:"Les propri\xe9t\xe9s h\xe9rit\xe9es sont les champs et les m\xe9thodes des classes de base."}),"\n",(0,t.jsx)(s.p,{children:"Pour faire un h\xe9ritage en C++, il faut faire suivre le nom de la classe fille\npar la liste des classes m\xe8res dans la d\xe9claration avec les restrictions d'acc\xe8s\naux donn\xe9es, chaque \xe9l\xe9ment \xe9tant s\xe9par\xe9 des autres par une virgule. La syntaxe\nest la suivante"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"class Classe_mere\n{\n\n};\nclass Classe_fille : public Classe_mere\n"})}),"\n",(0,t.jsx)(s.p,{children:"On peut utiliser les mots cl\xe9s private, protected et public dans l'h\xe9ritage \xe0 la\nplace de public."}),"\n",(0,t.jsx)(s.p,{children:"Il est possible de red\xe9finir les fonctions et les donn\xe9es des classes de base\ndans une classe d\xe9riv\xe9e. Par exemple, si une classe B d\xe9rive de la classe A, et\nque toutes deux contiennent une donn\xe9e d, les instances de la classe B\nutiliseront la donn\xe9e d de la classe B et les instances de la classe A\nutiliseront la donn\xe9e d de la classe A. Cependant, les objets de classe B\ncontiendront \xe9galement un sous-objet, lui m\xeame instance de la classe de base A.\nPar cons\xe9quent, ils contiendront la donn\xe9e d de la classe A, mais cette derni\xe8re\nsera cach\xe9e par la donn\xe9e d de la classe la plus d\xe9riv\xe9e, \xe0 savoir la classe B."}),"\n",(0,t.jsx)(s.p,{children:"Ce m\xe9canisme est g\xe9n\xe9ral : quand une classe d\xe9riv\xe9e red\xe9finit un membre d'une\nclasse de base, ce membre est cach\xe9 et on ne peut plus acc\xe9der directement qu'au\nmembre red\xe9fini (celui de la classe d\xe9riv\xe9e). Cependant, il est possible\nd'acc\xe9der aux donn\xe9es cach\xe9es si l'on conna\xeet leur classe, pour cela, il faut\nnommer le membre compl\xe8tement \xe0 l'aide de l'op\xe9rateur de r\xe9solution de port\xe9e.\nLe nom complet d'un membre est constitu\xe9 du nom de sa classe suivi de\nl'op\xe9rateur de r\xe9solution de port\xe9e, suivis du nom du membre."}),"\n",(0,t.jsx)(s.h2,{id:"classes-virtuelles",children:"Classes virtuelles"}),"\n",(0,t.jsx)(s.p,{children:"Supposons \xe0 pr\xe9sent qu'une classe D h\xe9rite de deux classes m\xe8res, les classes B\net C. Supposons \xe9galement que ces deux classes h\xe9ritent d'une classe m\xe8re\ncommune appel\xe9e classe A. On sait que B et C h\xe9ritent des donn\xe9es et des\nm\xe9thodes publiques et prot\xe9g\xe9es de A. De m\xeame, D h\xe9rite des donn\xe9es de B et C,\net par leur interm\xe9diaire des donn\xe9es de A. Il se pose donc le probl\xe8me\nsuivant : quelles sont les donn\xe9es que l'on doit utiliser quand on r\xe9f\xe9rence les\nchamps de A ? Celles de B ou celles de C ? On peut acc\xe9der aux deux sous-objets\nde classe A en sp\xe9cifiant le chemin \xe0 suivre dans l'arbre g\xe9n\xe9alogique \xe0 l'aide\nde l'op\xe9rateur de r\xe9solution de port\xe9e. Cependant, cela n'est ni pratique ni\nefficace, et en g\xe9n\xe9ral, on s'attend \xe0 ce qu'une seule copie de A apparaisse\ndans D. Le probl\xe8me est r\xe9solu en d\xe9clarant virtuelle la classe de base commune\ndans la sp\xe9cification de l'h\xe9ritage pour les classes filles. Les donn\xe9es de la\nclasse de base ne seront alors plus dupliqu\xe9es. Pour d\xe9clarer une classe m\xe8re\ncomme une classe virtuelle, il faut faire pr\xe9c\xe9der son nom du mot cl\xe9 virtual\ndans l'h\xe9ritage des classes filles."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:'class A\n{\nprotected:\n    int Donnee;        // La donn\xe9e de la classe de base.\n};\n \n// H\xe9ritage de la classe A, virtuelle :\nclass B : virtual public A\n{\nprotected:\n    int Valeur_B;      // Autre donn\xe9e que "Donnee" (h\xe9rit\xe9e).\n};\n \n// A est toujours virtuelle :\nclass C : virtual public A\n{\nprotected:\n    int valeur_C;      // Autre donn\xe9e\n                       // ("Donnee" est acquise par h\xe9ritage).\n};\n \nclass D : public B, public C   // Ici, Donnee n\'est pas dupliqu\xe9.\n{\n    /* D\xe9finition de la classe D. */\n};\n'})}),"\n",(0,t.jsx)(s.p,{children:"Premi\xe8rement, il est impossible de transtyper directement un pointeur sur un\nobjet d'une classe de base virtuelle en un pointeur sur un objet de ses classes\nd\xe9riv\xe9es. Il faut imp\xe9rativement utiliser l'op\xe9rateur de transtypage dynamique.\nCet op\xe9rateur sera d\xe9crit plus tard."}),"\n",(0,t.jsx)(s.p,{children:"Deuxi\xe8mement, chaque classe d\xe9riv\xe9e directement ou indirectement d'une classe\nvirtuelle doit en appeler le constructeur explicitement dans son constructeur si\ncelui-ci prend des param\xe8tres. En effet, elle ne peut pas se fier au fait qu'une\nautre de ses classes de base, elle-m\xeame d\xe9riv\xe9e de la classe de base virtuelle,\nappelle un constructeur sp\xe9cifique, car il est possible que plusieurs classes de\nbase cherchent \xe0 initialiser diff\xe9remment chacune un objet commun h\xe9rit\xe9 de\nclasse virtuelle. Pour reprendre l'exemple donn\xe9e ci-dessus, si les classes B et\nC appellaient toutes les deux un constructeur non trivial de la classe virtuell\nA et que la classe D appellait elle m\xeame les constructeurs de B et C, le sous\nobjet h\xe9rit\xe9 de A serait construit plusieurs fois. Pour \xe9viter cela, le\ncompilateur ignore purement et simplement les appels au constructeur des classes\nde bases virtuelles dans les classes de base d\xe9riv\xe9es. Il faut donc\nsyst\xe9matiquement le sp\xe9cifier, \xe0 chaque niveau de la hi\xe9rarchie de classe. La\nnotion de constructeur sera vue plus tard."}),"\n",(0,t.jsx)(s.h2,{id:"fonctions-et-classes-amies",children:"Fonctions et classes amies"}),"\n",(0,t.jsx)(s.p,{children:"Il est parfois n\xe9cessaire d'avoir des fonctions qui ont un acc\xe8s illimit\xe9 aux\nchamps d'une classe. En g\xe9n\xe9ral, l'emploi de telles fonctions traduit un manque\nd'analyse dans la hi\xe9rarchie des classes, mais pour toujours. Elles restent donc\nn\xe9cessaires malgr\xe9 tout."}),"\n",(0,t.jsxs)(s.p,{children:["De telles fonctions sont appel\xe9es des fonctions amies. Pour qu'une fonction soit\namie d'une classe, il faut qu'elle soit d\xe9clar\xe9e dans la classe avec le mot cl\xe9\n",(0,t.jsx)(s.code,{children:"friend"}),"."]}),"\n",(0,t.jsx)(s.p,{children:"Il est \xe9galement possible de faire une classe amie d'une autre classe, mais dans\nce cas cette classe devrait peut-\xeatre \xeatre une classe fille. L'utilisation des\nclasses amies peut traduire un d\xe9faut de conception."}),"\n",(0,t.jsx)(s.h3,{id:"fonctions-amies",children:"Fonctions amies"}),"\n",(0,t.jsxs)(s.p,{children:["Les fonctions amies se d\xe9clarent en faisant pr\xe9c\xe9der la d\xe9claration classique de\nla fonction du mot cl\xe9 ",(0,t.jsx)(s.code,{children:"friend"})," \xe0 l'int\xe9rieur de la classe cible. Les fonctions\namies ne sont pas des m\xe9thodes de la classe cependant (cela n'aurait pas de sens\npuisque les m\xe9thodes ont d\xe9j\xe0 acc\xe8s aux membre de la classe)."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"class A\n{\n    int a;                        // Une donn\xe9e priv\xe9e.\n    friend void ecrit_a(int i);   // Une fonction amie.\n};\n \nA essai;\n \nvoid ecrit_a(int i)\n{\n    essai.a=i;          // Initialise a.\n    return;\n}\n"})}),"\n",(0,t.jsx)(s.p,{children:"Il est possible de d\xe9clarer amie une fonction d'une autre classe, en pr\xe9cisant\nson nom complet \xe0 l'aide de l'op\xe9rateur de r\xe9solution de port\xe9e."}),"\n",(0,t.jsx)(s.h3,{id:"classes-amies",children:"Classes amies"}),"\n",(0,t.jsxs)(s.p,{children:["Pour rendre toutes les m\xe9thodes d'une classe amies d'une autre classe, il suffit\nde d\xe9clarer la classe compl\xe8te comme \xe9tant amie. Pour cela, il faut encore une\nfois utiliser le mot cl\xe9 ",(0,t.jsx)(s.code,{children:"friend"})," avant la d\xe9claration de la classe, \xe0\nl'int\xe9rieur de la classe cible. Cette fois encore, la classe amie d\xe9clar\xe9e ne\nsera pas une sous-classe de la classe cible, mais bien une classe de port\xe9e\nglobale"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:'#include <stdio.h>\n \nclass Hote\n{\n    friend class Amie;  // Toutes les m\xe9thodes de Amie sont amies.\n \n    int i;              // Donn\xe9e priv\xe9e de la classe Hote.\n \npublic:\n    Hote(void)\n    {\n        i=0;\n        return ;\n    }\n};\n \nHote h;\n \nclass Amie\n{\npublic:\n    void print_hote(void)\n    {\n        printf("%d\\n", h.i); // Acc\xe8de \xe0 la donn\xe9e priv\xe9e de h.\n        return ;\n    }\n};\n \nint main(void)\n{\n    Amie a;\n    a.print_hote();\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(s.p,{children:"On remarquera plusieurs choses importantes. Premi\xe8rement, l'amiti\xe9 n'est pas\ntransitive. Cela signifie que les amis des amis ne sont pas des amis. Une classe\nA amie d'une classe B, elle-m\xeame amie d'une classe C, n'est pas amie de la\nclasse C par d\xe9faut. Il faut la d\xe9clarer amie explicitement si on d\xe9sire qu'elle\nle soit. Deuxi\xe8mement, les amis ne sont pas h\xe9rit\xe9s. Ainsi, si une classe A est\namie d'une classe B et que la classe C est une classe fille de la classe B,\nalors A n'est pas amie de la classe C par d\xe9faut. Encore une fois, il faut la\nd\xe9clarer amie explicitement. Ces remarques s'appliquent \xe9galement aux fonctions amies."})]})}function u(e={}){const{wrapper:s}={...(0,a.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},11151:(e,s,n)=>{n.d(s,{Z:()=>r,a:()=>i});var t=n(67294);const a={},l=t.createContext(a);function i(e){const s=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(l.Provider,{value:s},e.children)}}}]);