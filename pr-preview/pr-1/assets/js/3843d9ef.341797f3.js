"use strict";(self.webpackChunksedelpeuch_net=self.webpackChunksedelpeuch_net||[]).push([[7024],{68035:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>u,contentTitle:()=>t,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>o});var i=n(85893),a=n(11151);const r={title:"Gestion m\xe9moire"},t=void 0,l={id:"enseirb/s8/se/3",title:"Gestion m\xe9moire",description:"Programmation modulaire",source:"@site/docs/enseirb/s8/se/3.md",sourceDirName:"enseirb/s8/se",slug:"/enseirb/s8/se/3",permalink:"/pr-preview/pr-1/docs/enseirb/s8/se/3",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Gestion m\xe9moire"},sidebar:"tutorialSidebar",previous:{title:"Processus et ex\xe9cution",permalink:"/pr-preview/pr-1/docs/enseirb/s8/se/2"},next:{title:"Concurrence et synchronisation",permalink:"/pr-preview/pr-1/docs/enseirb/s8/se/4"}},u={},o=[{value:"Programmation modulaire",id:"programmation-modulaire",level:2},{value:"M\xe9moire virtuelle",id:"m\xe9moire-virtuelle",level:2},{value:"Pagination",id:"pagination",level:3},{value:"Segmentation",id:"segmentation",level:3},{value:"Approches hybrides : Segments pagin\xe9s",id:"approches-hybrides--segments-pagin\xe9s",level:3},{value:"Partage m\xe9moire",id:"partage-m\xe9moire",level:3},{value:"Tables de pages",id:"tables-de-pages",level:2},{value:"Bilan",id:"bilan",level:3},{value:"Pagination \xe0 la demande et d\xe9fauts de page",id:"pagination-\xe0-la-demande-et-d\xe9fauts-de-page",level:2},{value:"Projection de fichiers",id:"projection-de-fichiers",level:3},{value:"Copy-on-Write",id:"copy-on-write",level:3},{value:"Le swap",id:"le-swap",level:3},{value:"Heuristiques de gestion m\xe9moire",id:"heuristiques-de-gestion-m\xe9moire",level:2},{value:"Support mat\xe9riel",id:"support-mat\xe9riel",level:2},{value:"M\xe9moire du noyau",id:"m\xe9moire-du-noyau",level:2}];function d(e){const s={em:"em",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h2,{id:"programmation-modulaire",children:"Programmation modulaire"}),"\n",(0,i.jsx)(s.p,{children:"Le chargement des programmes est l'assemblage de modules (programme,\nbiblioth\xe8ques). Le calcul des adresses m\xe9moires se fait via deux moyens :"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"le chargement absolu par le programmeur, le compilateur ou l'assembleur"}),"\n",(0,i.jsx)(s.li,{children:"le chargement dynamique qui sont des adresses relatives calcul\xe9es \xe0 l'ex\xe9cution"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Pour cela on utilse de l'\xe9dition de liens , c'est \xe0 dire l'utilisation de\n\"symboles\" pour r\xe9f\xe9rencer des adresses inconnues. Les r\xe9f\xe9rences non-r\xe9solues\nprovoquent des chargement d'autres modules. Cela permet de mettre \xe0 jour des\nmodules sans recompiler"}),"\n",(0,i.jsx)(s.p,{children:"Comment stocker les adresses si on peut charger \xe0 diff\xe9rents endroits ?\nLes adresses absolues sont simples \xe0 g\xe9rer mais imposent un emplacement du code\nen m\xe9moire et impose un seul programme ou m\xe9moire virtuelle. Les adresses\nrelatives sont ajust\xe9es plus tard, au chargement ou \xe0 l'ex\xe9cution (\xe9dition de\nliens entre modules, fixer les adresses \xe0 l'int\xe9rieur des modules)."}),"\n",(0,i.jsx)(s.p,{children:"Le code est ind\xe9pendant de la position, on utilise uniquement des adresses\nrelatives (facile \xe0 charger, pas besoin de modifier le code, peu co\xfbteux en\ntemps)"}),"\n",(0,i.jsx)(s.h2,{id:"m\xe9moire-virtuelle",children:"M\xe9moire virtuelle"}),"\n",(0,i.jsx)(s.p,{children:"Nous souhaitons que chaque processus voit un espace lin\xe9aire. Cependant il n'est\npas forc\xe9ment lin\xe9aire physiquement et n'est pas forc\xe9ment utilis\xe9\nint\xe9gralement. Nous souhaitons aussi que la taille ne soit pas limit\xe9 par la\nm\xe9moire physique ainsi que pouvoir prot\xe9ger et partager la m\xe9moire."}),"\n",(0,i.jsx)(s.p,{children:"L'int\xe9r\xeat de la m\xe9moire virtuelle est de nous offrir plus de m\xe9moire que de\nm\xe9moire physique disponible. Les codes et donn\xe9es non-utilis\xe9es peuvent donc\nrester sur le disque (charg\xe9s par l'OS quand ils deviennent n\xe9cessaires). Elle\npermet aussi de faire cohabiter de nombreux processsus mais surtout d'isoler des\nprocessus puisque l'espace virtuel des autres processsus est inaccessible."}),"\n",(0,i.jsx)(s.p,{children:"Cette abstraction n'entraine pas de contraintes pour le programmeur puisque\nl'abstraction est lin\xe9aire et uniforme du stockage physique."}),"\n",(0,i.jsx)(s.p,{children:"En revanche la m\xe9moire virtuelle poss\xe8de des inconv\xe9nients, en effet le premier\nest un inconv\xe9nient de performance puisque l'on consomme de l'espace m\xe9moire\npour stocker des tables de pages mais aussi de la consommation en temps pour\nconsulter la table des pages."}),"\n",(0,i.jsx)(s.h3,{id:"pagination",children:"Pagination"}),"\n",(0,i.jsx)(s.p,{children:"Permet une forte non-contiguit\xe9 de l'espace virtuel en m\xe9moire physique. Il y a\nune division de la m\xe9moire physique en bloc de taille fixe et la division de\nl'espace virtuel en blocs de tailles fixes. Chaque cadre virtuel n\xe9cessite\nl'allocation d'une page physique."}),"\n",(0,i.jsx)(s.p,{children:"L'association entre les pages et les cadres est g\xe9r\xe9e par l'OS (table de pages),\nil n'y a pas de contrainte sur le choix des pages (les espaces virtuels\ndispers\xe9s dans l'espace physique). Aucune adresse virtuelle ne pointe sur les\npages de autres processus."}),"\n",(0,i.jsx)(s.p,{children:"La traduction des adresses virtuelles \xe9quivaut au num\xe9ro du cadre virtuel plus\nle d\xe9calage. Ce num\xe9ro est l'index dans le table de page et permet de r\xe9cup\xe9rer\nle num\xe9ro de page physique. L'adresse physique est alors \xe9gale au PFN (page\nframe number) plus le d\xe9calage."}),"\n",(0,i.jsx)(s.p,{children:"Chaque cadre virtuel dispose de bits de protections, un bit permet de dire si la\npage est valide ou non (seg fault), un bit permet de dire si la page est\npr\xe9sente ou non (d\xe9fauts de page, swap ...). En fonction de l'architecture il\npeut y avoir des bits de read-only, read-write etc"}),"\n",(0,i.jsx)(s.p,{children:"Les avantages de la pagination sont multiples, l'allocation de pages est\nfaciles, le swap de morceaux de programmes aussi (tous les cadres virtuels ont\nla m\xeame taille, un bit de pr\xe9sence est utilis\xe9 pour savoir si swapp\xe9 ou non). Le\npartage et la protection des pages est facile."}),"\n",(0,i.jsx)(s.p,{children:"En revanche cela implique une fragmentation interne (de l'ordre de la taille\nd'une page), cela est co\xfbteux (2 r\xe9f\xe9rences par acc\xe8s m\xe9moire) et implique une\nconsommation de m\xe9moire importante."}),"\n",(0,i.jsx)(s.h3,{id:"segmentation",children:"Segmentation"}),"\n",(0,i.jsx)(s.p,{children:"Cela consiste \xe0 partitionner la m\xe9moire en unit\xe9s logiques (code, tas, pile).\nL'espace d'adressage est alors d\xe9fini par l'ensemble des segments ind\xe9pendants.\nLes adresses virtuelles sont alors compos\xe9 du s\xe9lecteur de segment plus du\nd\xe9calage dans ce segment. Cela permet de mettre en place une protection par\nsegment et un partage \xe0 forte granularit\xe9. Cependant l'allocation est difficile et le swap est\nplus lourd que lors de la pagination."}),"\n",(0,i.jsx)(s.h3,{id:"approches-hybrides--segments-pagin\xe9s",children:"Approches hybrides : Segments pagin\xe9s"}),"\n",(0,i.jsx)(s.p,{children:"Nous utilisons des segments pour distinguer des unit\xe9s logiques (code, tas,\npile) et une pagination interne \xe0 chaque segment (allocation, swap \xe0 granularit\xe9\nfine). La traduction d'une adresse virtuelle en adresse physique est en deux\ntemps"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"D\xe9calage d'index dans la table de pages via la table des segments : adresse lin\xe9aire"}),"\n",(0,i.jsx)(s.li,{children:"Traduction de l'adresse lin\xe9aire en adresse physique via la table des pages."}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"partage-m\xe9moire",children:"Partage m\xe9moire"}),"\n",(0,i.jsx)(s.p,{children:"Plusieurs zones virtuelles peuvent pointer sur les m\xeames pages physiques avec\ndes protections diff\xe9rentes. Il existe un compteur de r\xe9f\xe9rences dans les pages,\nla page est libre quand la derni\xe8re r\xe9f\xe9rence est rel\xe2ch\xe9e. On peut alors la\nr\xe9utiliser."}),"\n",(0,i.jsx)(s.h2,{id:"tables-de-pages",children:"Tables de pages"}),"\n",(0,i.jsx)(s.p,{children:"La table de page est d\xe9fini par l'ensemble des associations entre les cadres\nvirtuels et la validit\xe9, la localisation et la protection. Elle est acc\xe9d\xe9\nquasiquement uniquement par adresse virtuelle. La table des pages compl\xe8te prend\nbeaucoup de place en m\xe9moire (4MB pour un espace 32 bits avec pages de 4Ko)."}),"\n",(0,i.jsx)(s.p,{children:"Une grande part de l'espace d'adressage n'est pas utilis\xe9 car il n'est pas\nvalide ou valide mais inutilis\xe9 actuellement. Ainsi doit on vraiment d\xe9crire\ntoutes ces pages virtuelles inutiles individuellement ?"}),"\n",(0,i.jsx)(s.p,{children:"L'id\xe9e est d'utiliser des tables hi\xe9rarchiques \xe0 plusieurs niveaux, chaque\nniveau est un tableau d'indirection vers des sous-tableaux. Cela permet de\nsupprimer les tableaux inutiles (au lieu d'allouer un tableau d'entr\xe9es\ninvalides, on marque le pointeur du p\xe8re comme invalide)"}),"\n",(0,i.jsx)(s.p,{children:"Si un processus n'utilise qu'un seul cadre virtuel alors on alloue une seule\npage par niveau. Si un processus utilise toute la m\xe9moire virtuelle alors le\ndernier niveau fait exactement la m\xeame taille qu'une table lin\xe9aire \xe0 1 seul\nniveau (surco\xfbt des niveaux sup\xe9rieurs est n\xe9gligeable de l'ordre de 1/ nombre\nde pointeurs par niveau)."}),"\n",(0,i.jsx)(s.p,{children:"Les processeurs supportent 2 \xe0 4 niveaux et l'OS les utilise comme il veut."}),"\n",(0,i.jsx)(s.p,{children:"Les adresses virtuelles sont \xe9gales \xe0 l'agr\xe9agation d'index pour chaque niveau.\n(premiers bits est l'entr\xe9e dans la table du premier niveau etc). L'os choisit\nle nombre de bits en faisant tenir la table et chaque sous-table dans une page\nexactement. La traduction des adresses virtuelles en adresses physique se fait\nvia le parcours de la table de haut en bas."}),"\n",(0,i.jsx)(s.p,{children:"Concernant les tables de pages hach\xe9es, on r\xe9alise l'hachage de l'adresse\nvirtuelle puis un parcours d'une liste pour localise la PTE. Cela est efficace\npour les espaces d'adressage tr\xe8s dispers\xe9s, lent pour les espaces remplis."}),"\n",(0,i.jsx)(s.h3,{id:"bilan",children:"Bilan"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Table lin\xe9aire originale : tr\xe8s simple, bon temps d'acc\xe8s, tr\xe8s mauvais en\nespace m\xe9moire"}),"\n",(0,i.jsx)(s.li,{children:"Table hi\xe9rarchique : assez simple, bon temps d'acc\xe8s, tr\xe8s bon en espace\nm\xe9moire"}),"\n",(0,i.jsx)(s.li,{children:"Table hach\xe9e : relativement simple, temps d'acc\xe8s bon en moyenne, tr\xe8s tr\xe8s\nbon en espace m\xe9moire"}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"pagination-\xe0-la-demande-et-d\xe9fauts-de-page",children:"Pagination \xe0 la demande et d\xe9fauts de page"}),"\n",(0,i.jsx)(s.p,{children:"L'OS peut souvent \xeatre fain\xe9ant (ne pas charger une page en m\xe9moire tant qu'elle\nn'est pas acc\xe9d\xe9e), cela implique un d\xe9faut de page lors du premier acc\xe8s qui\nentra\xeene l'allocation et le remplissage de la page (reprise sur erreur)"}),"\n",(0,i.jsxs)(s.p,{children:["On utilise aussi la pagination \xe0 la demande (",(0,i.jsx)(s.em,{children:"demand paging"}),") puisque la m\xe9moire\nn'est qu'un cache des donn\xe9es manipul\xe9es par le processus. Initialement tout est\nsur le disque, entre temps, on charge ce qui est acc\xe9d\xe9 quand c'est n\xe9cessaire."]}),"\n",(0,i.jsxs)(s.p,{children:["Un ",(0,i.jsx)(s.strong,{children:"d\xe9faut de page"})," est un acc\xe8s qui ne peut \xeatre r\xe9alis\xe9 par le mat\xe9riel (le\nprocesseur ne peut pas le faire) et demande l'aide de l'OS (adresse virtuelle\ninvalide, adresse valide mais page absente en m\xe9moire physique, adresse valide\nmais \xe9criture interdite)"]}),"\n",(0,i.jsx)(s.p,{children:"L'OS a d\xe9fini un traitant pour l'exception \"d\xe9faut de page\". Le traitant va\nalors identifier le probl\xe8me, le r\xe9parer si cela est possible (chargement d'une\npage depuis le disque) sinon le processus ne peut pas continuer."}),"\n",(0,i.jsx)(s.p,{children:"L'allocation de pages se fait via l'OS, il dispose d'une liste de pages libres.\nSi la liste est vide, il faut lib\xe9rer une page (sinon il y a une erreur)."}),"\n",(0,i.jsx)(s.p,{children:"Pour charger une page lors d'un d\xe9faut nous allons d'une part r\xe9cup\xe9rer une page\nlibre et d'autre par localiser les donn\xe9es \xe0 charger. Il suffit ensuite de\nsoumettre l'I/O de lecture depuis le disque. Lorsque l'I/O termine il suffit\nd'adapter le statut de la page et reprendre le processus."}),"\n",(0,i.jsx)(s.p,{children:"La pagination \xe0 la demande poss\xe8de les avantages suivants :"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Localit\xe9 temporelle : une page acc\xe9d\xe9e r\xe9cemment le sera s\xfbrement \xe0 nouveau\ndans le futur proche"}),"\n",(0,i.jsx)(s.li,{children:"Localit\xe9 spatiale : les zones m\xe9moire voisines seront s\xfbrement acc\xe9d\xe9es dans\nle futur proche"}),"\n",(0,i.jsx)(s.li,{children:"Une page charg\xe9e va \xeatre r\xe9utilis\xe9e plusieurs fois"}),"\n",(0,i.jsx)(s.li,{children:"En moyenne, on utilise beaucoup les choses d\xe9j\xe0 charg\xe9es"}),"\n",(0,i.jsx)(s.li,{children:"Ne pas charger trop de choses inutilement"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"En revanche certaines applications ne respectent pas vraiment la localit\xe9\nspatiale ou temporelle, les politiques de chargement et remplacement doivent\n\xeatre bonnes."}),"\n",(0,i.jsx)(s.h3,{id:"projection-de-fichiers",children:"Projection de fichiers"}),"\n",(0,i.jsx)(s.p,{children:"Dans un OS tout est fichier. L'OS ne fait que manipuler des pages de fichiers.\nNous pouvons r\xe9aliser une projection publique o\xf9 les modifications effectu\xe9es en\nm\xe9moire sont r\xe9percut\xe9es dans le fichier. Ou une projection priv\xe9e o\xf9 les\nmodifications sont sauv\xe9es dans le swap et sont perdues \xe0 la fin du processus."}),"\n",(0,i.jsx)(s.p,{children:"La projection anonyme est une projection sans fichier de support. Il utilise la\npile ou le tas et est utilis\xe9 par malloc pour les allocations en dehors du tas.\nIl peut \xeatre priv\xe9 ou public."}),"\n",(0,i.jsx)(s.h3,{id:"copy-on-write",children:"Copy-on-Write"}),"\n",(0,i.jsx)(s.p,{children:"Les copies m\xe9moire co\xfbtent cher, il faut \xe9viter de dupliquer inutilement et\nretarder la duplication au maximum jusqu'\xe0 la premi\xe8re modification concurrente.\nPour d\xe9tecter une modification concurrent la page est mise en lecture seule dans\nle mat\xe9riel et provoquer un d\xe9faut de page. Le traitant alloue une page, copie\nle contenu dedans et la donne au processus."}),"\n",(0,i.jsx)(s.h3,{id:"le-swap",children:"Le swap"}),"\n",(0,i.jsx)(s.p,{children:"Le swap est une extension de la m\xe9moire physique. Elle est plus lente et n'a pas\nbesoin d'\xeatre d\xe9r\xe9f\xe9rencable par le processeur et est enti\xe8rement g\xe9r\xe9 par l'OS."}),"\n",(0,i.jsx)(s.p,{children:"Historiquement on swappait des processus entiers ce qui provoque la suspension\ncompl\xe8te de l'ex\xe9cution. La pagination permet la granularit\xe9 de la page. Un\nprocessus gigantesque peut continuer \xe0 s'ex\xe9cuter en r\xe9sidant essentiellement\ndans le swap."}),"\n",(0,i.jsx)(s.p,{children:"Les PTE valides mais non-pr\xe9sentes peuvent pointer vers un bloc du swap. Un\nacc\xe8s provoque un d\xe9faut de page et le chargement du bloc en m\xe9moire. L'OS\nd\xe9cide de quelles pages envoyer sur le disque (selon le principe de localit\xe9)."}),"\n",(0,i.jsx)(s.p,{children:"Le swap sert uniquement quand il faut lib\xe9rer de la m\xe9moire physique. Seules les\npages priv\xe9es et/ou anonymes vont dans le swap (la lib\xe9rations des pages de\nmappings publics les renvoit sur le disque contenant le fichier correspondant)"}),"\n",(0,i.jsx)(s.h2,{id:"heuristiques-de-gestion-m\xe9moire",children:"Heuristiques de gestion m\xe9moire"}),"\n",(0,i.jsx)(s.p,{children:"Le chargement des pages se fait quand elles sont acc\xe9d\xe9es lors du d\xe9faut de\npage. Le prepaging et prefaulting permet de charger \xe0 l'avance des pages\nsuivantes (principe de localit\xe9). Le chargement s'effectue g\xe9n\xe9ralement dans\nn'importe quelle page physique. Lorsque l'on utilise une architecture NUMA on\nprivil\xe9gie g\xe9n\xe9ralement l'utilisation de m\xe9moire proche."}),"\n",(0,i.jsxs)(s.p,{children:["Les modifications sont sauv\xe9es sur les pages modifi\xe9es dans des fichiers\ncorrespondants ou dans le swap. Les pages mapp\xe9es sont difficiles \xe0 g\xe9rer, il\nn'y a pas dappel explicite \xe0 l'OS lors des modifications. Le mat\xe9riel ajoute\nalors un bit ",(0,i.jsx)(s.em,{children:"Dirty"})," et l'on sauve uniquement les pages ",(0,i.jsx)(s.em,{children:"Dirty"}),"."]}),"\n",(0,i.jsx)(s.p,{children:"Concernant le swap nous allons swaper les pages non-utilis\xe9es \xe0 l'avenir\n(algorithme de Belady) en utilisant la politique LRU (Least Recentyle Used) ou\nLFU (Least Frequently Used). Le swap se produit soit au dernier moment, soit\nquand la m\xe9moire disponible passe en dessous d'un seuil."}),"\n",(0,i.jsx)(s.p,{children:"On conserve en m\xe9moire le plus de choses possibles car elle est rapide au cas o\xf9\ncela serve plus tard. On effectue des sauvegardes r\xe9guli\xe8re des modifications\nsans forc\xe9ment lib\xe9rer les pages. En r\xe9gime permanent, un OS utilise toute la\nm\xe9moire, au cas o\xf9. Les pages publiques sont gard\xe9es en m\xe9moire si un processus\nles r\xe9utilise et les pages priv\xe9es jusqu'\xe0 la fin du processus courant."}),"\n",(0,i.jsx)(s.p,{children:"Si une allocation m\xe9moire \xe9choue le syst\xe8me doit tout de m\xeame survivre.\nL'utilisateur doit pouvoir continuer \xe0 utiliser le syst\xe8me (tuer un processus\npour lib\xe9rer de la m\xe9moire). Pour d\xe9terminer qui tuer plusieurs politiques\nexistent, tuer ceux qui essaie d'allouer, ceux qui allouent beaucoup ou les\nprocessus les moins importants."}),"\n",(0,i.jsx)(s.h2,{id:"support-mat\xe9riel",children:"Support mat\xe9riel"}),"\n",(0,i.jsx)(s.p,{children:"Le code manipule uniquement des adresses virtuelles mais le processeur doit les\ntraduire en adresse physique. Il faut que la table des pages soit accessible au\nmat\xe9riel (soit directement par une MMU, soit indirectement par l'OS via une exception)"}),"\n",(0,i.jsx)(s.p,{children:"La MMU (memory management unit) est un cricuit d\xe9di\xe9 du processeur pour traduire\nles adresses virtuelles. Cependant la traduction des adresses virtuelles peut\n\xeatre lente. Il est de plus n\xe9cessaire de cacher les traductions (Translation\nLookaside Buffer). Si le TLB cache miss :"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Si MMU, la MMU parcourt la table des pages"}),"\n",(0,i.jsx)(s.li,{children:"Si pas de MMU, exception g\xe9r\xe9e par l'OS."}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"m\xe9moire-du-noyau",children:"M\xe9moire du noyau"}),"\n",(0,i.jsx)(s.p,{children:"L'espace d'adressage utilis\xe9 par le noyau se divise en deux partie. D'une part il existe un espace virtuel sp\xe9cifique au noyau accessible uniquement en mode\nprivil\xe9gi\xe9. Et un espace virtuel utilisateur du processus courant utilis\xe9\npendant un appel syst\xe8me ou une interruption."}),"\n",(0,i.jsx)(s.p,{children:"Le noyau est un contexte d'ex\xe9cution et \xe0 potentiellement le droit d'acc\xe9der \xe0\ntout ce qui poss\xe8de une adresse virtuelle. Cependant il est r\xe9ellement besoin de\nson propre code et de ses donn\xe9es propres pour fonctionner (10-100 Mo). Le noyau\nne mappe rien par d\xe9faut \xe0 part le strict minimum."})]})}function p(e={}){const{wrapper:s}={...(0,a.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},11151:(e,s,n)=>{n.d(s,{Z:()=>l,a:()=>t});var i=n(67294);const a={},r=i.createContext(a);function t(e){const s=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);