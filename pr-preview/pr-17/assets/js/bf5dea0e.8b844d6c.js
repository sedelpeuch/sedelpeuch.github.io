"use strict";(self.webpackChunksedelpeuch_net=self.webpackChunksedelpeuch_net||[]).push([[5715],{28453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>a});var r=n(96540);const t={},i=r.createContext(t);function o(e){const s=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(i.Provider,{value:s},e.children)}},30161:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>o,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"enseirb/s7/prog_sys/7","title":"La m\xe9moire","description":"La m\xe9moire d\'un ordinateur se d\xe9compose en plusieurs \xe9l\xe9ments, dont le prix et","source":"@site/docs/enseirb/s7/prog_sys/7.md","sourceDirName":"enseirb/s7/prog_sys","slug":"/enseirb/s7/prog_sys/7","permalink":"/pr-preview/pr-17/docs/enseirb/s7/prog_sys/7","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"La m\xe9moire"},"sidebar":"tutorialSidebar","previous":{"title":"Les processus","permalink":"/pr-preview/pr-17/docs/enseirb/s7/prog_sys/6"},"next":{"title":"La m\xe9moire virtuelle","permalink":"/pr-preview/pr-17/docs/enseirb/s7/prog_sys/8"}}');var t=n(74848),i=n(28453);const o={title:"La m\xe9moire"},a=void 0,l={},u=[{value:"La m\xe9moire centrale",id:"la-m\xe9moire-centrale",level:3},{value:"Allocation contigu\xeb",id:"allocation-contigu\xeb",level:2},{value:"Pas de gestion de la m\xe9moire",id:"pas-de-gestion-de-la-m\xe9moire",level:3},{value:"Le moniteur r\xe9sidant",id:"le-moniteur-r\xe9sidant",level:3},{value:"Le registre barri\xe8re",id:"le-registre-barri\xe8re",level:3},{value:"Le registre base",id:"le-registre-base",level:3},{value:"Le swap",id:"le-swap",level:3},{value:"Le co\xfbt du swap",id:"le-co\xfbt-du-swap",level:3},{value:"Utilisation de la taille des processus",id:"utilisation-de-la-taille-des-processus",level:3},{value:"Swap et ex\xe9cutions concurrentes",id:"swap-et-ex\xe9cutions-concurrentes",level:3},{value:"Ordonnancement en m\xe9moire des processus",id:"ordonnancement-en-m\xe9moire-des-processus",level:2}];function d(e){const s={h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.p,{children:"La m\xe9moire d'un ordinateur se d\xe9compose en plusieurs \xe9l\xe9ments, dont le prix et\nle temps d'acc\xe8s sont tr\xe8s variables. Nous d\xe9velopperons dans ce chapitre et le\nsuivant les questions et solutions relatives \xe0 la m\xe9moire centrale. L'importance\nde la gestion de la m\xe9moire centrale vient de son co\xfbt et du co\xfbt relatif des\nautres formes de stockage."}),"\n",(0,t.jsx)(s.h3,{id:"la-m\xe9moire-centrale",children:"La m\xe9moire centrale"}),"\n",(0,t.jsx)(s.p,{children:"La m\xe9moire est un tableau \xe0 une dimension de mots machines (ou d'octets), chacun\nayant une adresse propre. Les \xe9changes avec l'ext\xe9rieur se font en g\xe9n\xe9ral par\ndes lectures ou des \xe9critures \xe0 des adresses sp\xe9cifiques. Le syst\xe8me UNIX est\nmulti-t\xe2che, ceci pour maximiser l'utilisation du PCU. Cette technique pose\ncomme condition obligatoire que la m\xe9moire centrale soit utilis\xe9e et ou partag\xe9e\nentre les diff\xe9rentes t\xe2ches. Les solutions de gestion de la m\xe9moire sont tr\xe8s\nd\xe9pendantes du mat\xe9riel et ont mis longtemps \xe0 \xe9voluer vers les solutions\nactuelles. Nous allons voir plusieurs approches qui peuvent servir dans des\nsituations particuli\xe8res. La m\xe9moire est le point central dans un syst\xe8me\nd'exploitation, c'est \xe0 travers elle que l'unit\xe9 centrale communique avec\nl'ext\xe9rieur."}),"\n",(0,t.jsx)(s.h2,{id:"allocation-contigu\xeb",children:"Allocation contigu\xeb"}),"\n",(0,t.jsx)(s.h3,{id:"pas-de-gestion-de-la-m\xe9moire",children:"Pas de gestion de la m\xe9moire"}),"\n",(0,t.jsx)(s.p,{children:"Cette m\xe9thode, qui a l'avantage de la simplicit\xe9 et de la rapidit\xe9, permet toute\nlibert\xe9 quand \xe0 l'utilisation de la m\xe9moire. En effet, toute adresse est\naccessible, et peut \xeatre utilis\xe9e pour n'importe qu'elle t\xe2che. Le d\xe9savantage :\naucune fonctionnalit\xe9, tout doit \xeatre reprogramm\xe9, typiquement il n'y a pas de\nsyst\xe8me d'exploitation."}),"\n",(0,t.jsx)(s.h3,{id:"le-moniteur-r\xe9sidant",children:"Le moniteur r\xe9sidant"}),"\n",(0,t.jsx)(s.p,{children:"On cherche \xe0 prot\xe9ger le noyau des interfaces possibles de la part des\nutilisateurs. Pour cela, toute adresse d'instruction ou de donn\xe9e manipul\xe9e par\nun programme utilisateur est compar\xe9e \xe0 un registre barri\xe8re. Tant que l'adresse\nest sup\xe9rieur \xe0 la barri\xe8re, l'adresse est l\xe9gale, sinon l'adresse est une\nr\xe9f\xe9rence ill\xe9gale au moniteur et une interruption est \xe9mise. Cette m\xe9thode\ndemande que pour tout acc\xe8s \xe0 la m\xe9moire une v\xe9rification de la validit\xe9 de\nl'adresse soit r\xe9alis\xe9e. Ceci ralentit toute ex\xe9cution d'un acc\xe8s m\xe9moire.\nGlobalement ce temps suppl\xe9mentaire peut \xeatre oubli\xe9."}),"\n",(0,t.jsx)(s.h3,{id:"le-registre-barri\xe8re",children:"Le registre barri\xe8re"}),"\n",(0,t.jsx)(s.p,{children:"L'impl\xe9mentation d'un tel m\xe9canisme doit \xeatre r\xe9alis\xe9e de fa\xe7on mat\xe9rielle. La\nvaleur du registre barri\xe8re est parfois r\xe9alis\xe9e de fa\xe7on fixe sur une machine,\nce qui pose les probl\xe8mes d\xe8s que l'on veut changer le noyau et ou prot\xe9ger plus\nde m\xe9moire."}),"\n",(0,t.jsx)(s.h3,{id:"le-registre-base",children:"Le registre base"}),"\n",(0,t.jsx)(s.p,{children:"Le m\xe9canisme suivant est une notion plus utile et plus ergonomique pour d\xe9crire\nla zone d'adressage d'un programme, et utile pour r\xe9soudre le probl\xe8me de\nd\xe9placement des programmes en m\xe9moire. En effet, du fait que l'on utilise un\nregistre barri\xe8re, les adresses utilisables de la m\xe9moire ne commencent plus \xe0\n0000, alors que l'utilisateur veut continuer \xe0 utiliser des adresses logiques\nqui commencent \xe0 0000. Pour continuer \xe0 fournit cette possibilit\xe9 le registre\nbarri\xe8re est transform\xe9 en registre de base. \xc0 chaque utilisation logique du\nprogramme, on ajoute \xe0 cette adresse la valeur du registre de base pour trouver\nl'adresse physique. L'utilisateur ne conna\xeet plus les adresses physiques. Il\ntravaille uniquement avec des adresses logiques. Le moniteur a \xe9videmment une\nvaleur nulle pour son registre de base et donc peut adresser toute la m\xe9moire.\nLe changement de la valeur du registre de base se fait de fa\xe7on prot\xe9g\xe9e en mode\nmoniteur. Ces deux syst\xe8mes de protection de la m\xe9moire sont clairement\nmonoprocessus. Seul le moniteur peut \xeatre prot\xe9g\xe9 par ces m\xe9canismes, il n'est\npas possible de prot\xe9ger les processus entre eux."}),"\n",(0,t.jsx)(s.h3,{id:"le-swap",children:"Le swap"}),"\n",(0,t.jsx)(s.p,{children:"Il est possible avec les registres barri\xe8re ou les registres de base d'\xe9crire\ndes syst\xe8mes temps partag\xe9, en utilisant le m\xe9canisme de swap. Swapper, c'est\n\xe9changer le contenu de la m\xe9moire centrale avec le contenu d'une m\xe9moire\nsecondaire. Par extension swapper devient l'action de d\xe9placer une zone m\xe9moire\nde la m\xe9moire vers le support de swap ou r\xe9ciproquement du p\xe9riph\xe9rique de swap\nvers la m\xe9moire. Le syst\xe8me va r\xe9aliser cet \xe9change \xe0 chaque changement de\ncontexte. Les syst\xe8mes de swap utilisent une m\xe9moire secondaire qui est en\ng\xe9n\xe9ral un disque mais on peut utiliser d'autre supports secondaire plus lents\nou plus rapides comme des bandes ou m\xe9moires secondaires."}),"\n",(0,t.jsx)(s.h3,{id:"le-co\xfbt-du-swap",children:"Le co\xfbt du swap"}),"\n",(0,t.jsx)(s.p,{children:"Sur un tel syst\xe8me, le temps de commutation de t\xe2ches est tr\xe8s important. Il est\ndonc n\xe9cessaire que chaque processus de l'unit\xe9 de traitement en temps\nsuffisamment long pour que le ralentissement d\xfb au swap ne soit pas trop\nsensible. Que se passe t'il sinon ? Le syst\xe8me utilise la majeure partie de ses\nressource \xe0 d\xe9placer des processus en et hors m\xe9moire centrale. L'unit\xe9 de\ntraitement n'est plus utilis\xe9e au maximum"}),"\n",(0,t.jsx)(s.h3,{id:"utilisation-de-la-taille-des-processus",children:"Utilisation de la taille des processus"}),"\n",(0,t.jsx)(s.p,{children:"Pour am\xe9liorer les m\xe9canismes de swap, on remarque que le temps de swap est\nproportionnel \xe0 la taille des donn\xe9es \xe0 d\xe9placer. Pour am\xe9liorer les\nperformances, il faut donc introduire la notion de taille effective d'un\nprocessus, ce qui permet d'am\xe9liorer le d\xe9bit mais cela impose que toutes les\naugmentations ou r\xe9ductions de taille d'un processus utilisateur soient r\xe9alis\xe9e\npar un appel syst\xe8me afin que le noyau connaisse \xe0 tout moment la taille r\xe9elle\nde chaque processus."}),"\n",(0,t.jsx)(s.h3,{id:"swap-et-ex\xe9cutions-concurrentes",children:"Swap et ex\xe9cutions concurrentes"}),"\n",(0,t.jsx)(s.p,{children:"Une autre approche tr\xe8s efficace est de r\xe9aliser le swap pendant l'ex\xe9cution\nd'un autre processus. Mais avec le syst\xe8me de registres de relocation c'est\ndangereux. En effet nous ne pouvons pas assurer qu'un processus utilisateur\ndonn\xe9 ne va pas \xe9crire dans les adresses r\xe9serv\xe9es \xe0 un autre processus."}),"\n",(0,t.jsx)(s.h2,{id:"ordonnancement-en-m\xe9moire-des-processus",children:"Ordonnancement en m\xe9moire des processus"}),"\n",(0,t.jsx)(s.p,{children:"Les choix de l'impl\xe9mentation des m\xe9canismes d'adressage influence \xe9norm\xe9ment\nl'ordonnancement des processus. Nous travaillons dans le cas d'un syst\xe8me de\ntraitement par lots c'est \xe0 dire en temps partag\xe9 mais les processus restent en\nm\xe9moire tout le temps de leur ex\xe9cution. S'il n'y a plus de place le processus\nest mis en attente. Nous devons r\xe9soudre le probl\xe8me suivant : il nous faut un\nalgorithme pour choisir dynamiquement, parmi les blocs libres de la m\xe9moire\ncentrale, celui qui va recevoir le nouveau processus (algorithme d'allocation de\nm\xe9moire \xe0 un processus). On reconna\xeet en g\xe9n\xe9ral trois m\xe9thodes"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Fisrt fit"})," le premier bloc suffisamment grand pour contenir notre processus\nest choisi"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Best fit"})," le plus petit bloc suffisamment grand pour contenir notre\nprocessus est choisi"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Worst-fil"})," le bloc qui nous laisse le plus grand morceau de m\xe9moire libre\nest choisi."]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"De nombreuse exp\xe9riences pratiques et des simulations ont montr\xe9 que le meilleur\nest first fit puis best fit et que ces deux algorithmes sont beaucoup plus\nefficaces que worst fit."})]})}function c(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);