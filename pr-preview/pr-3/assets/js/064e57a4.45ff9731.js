"use strict";(self.webpackChunksedelpeuch_net=self.webpackChunksedelpeuch_net||[]).push([[2782],{48883:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var s=t(85893),r=t(11151);const i={title:"Les exceptions en C++"},o=void 0,c={id:"enseirb/s7/cpp/5",title:"Les exceptions en C++",description:"Une exception est l'interruption de l'ex\xe9cution du programme \xe0 la suite d'un",source:"@site/docs/enseirb/s7/cpp/5.md",sourceDirName:"enseirb/s7/cpp",slug:"/enseirb/s7/cpp/5",permalink:"/pr-preview/pr-3/docs/enseirb/s7/cpp/5",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Les exceptions en C++"},sidebar:"tutorialSidebar",previous:{title:"La couche objet - Partie 4 : Les entr\xe9es/sorties, M\xe9thodes virtuelles, D\xe9rivation, Classe abstraites",permalink:"/pr-preview/pr-3/docs/enseirb/s7/cpp/4"},next:{title:"Les espaces de nommage",permalink:"/pr-preview/pr-3/docs/enseirb/s7/cpp/6"}},a={},l=[{value:"Lancement et r\xe9cup\xe9ration d&#39;une exception",id:"lancement-et-r\xe9cup\xe9ration-dune-exception",level:2},{value:"Remont\xe9e des exceptions",id:"remont\xe9e-des-exceptions",level:2},{value:"Liste des exceptions autoris\xe9es pour une fonction",id:"liste-des-exceptions-autoris\xe9es-pour-une-fonction",level:2},{value:"Hi\xe9rarchie des exceptions",id:"hi\xe9rarchie-des-exceptions",level:2},{value:"Exceptions dans les contructeurs",id:"exceptions-dans-les-contructeurs",level:2}];function u(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Une exception est l'interruption de l'ex\xe9cution du programme \xe0 la suite d'un\n\xe9v\xe9nement particulier. Le but des exceptions est de r\xe9aliser des traitements\nsp\xe9cifiques aux \xe9v\xe9nements qui en sont la cause. Ces traitements peuvent\nr\xe9tablir le programme dans son mode de fonctionnement normal, auquel cas son\nex\xe9cution reprend. Il se peut aussi que le programme se termine, si aucun\ntraitement n'est appropri\xe9."}),"\n",(0,s.jsx)(n.p,{children:"Le C++ supporte les exceptions logicielles, dont le but est de g\xe9rer les erreurs\nqui surviennent lors de l'ex\xe9cution des programmes. Lorsqu'une telle erreur\nsurvient, le programme doit lancer une exception. L'ex\xe9cution normale du\nprogramme s'arr\xeate d\xe8s que l'exception est lanc\xe9e, et le contr\xf4le est pass\xe9 \xe0 un\ngestionnaire d'exception. Lorsqu'un gestion d'exception s'ex\xe9cute, on dit qu'il\na attrap\xe9 l'exception."}),"\n",(0,s.jsx)(n.p,{children:"Les exceptions permettent une gestion simplifi\xe9e des erreurs, parce qu'elles en\nreportent le traitement. Le code peut alors \xeatre \xe9crit sans se soucier des cas\nparticuliers, ce qui le simplifie grandement. Les cas particuliers sont trait\xe9s\ndans les gestionnaires d'exception."}),"\n",(0,s.jsx)(n.p,{children:"En g\xe9n\xe9ral, une fonction qui d\xe9tecte une erreur d'ex\xe9cution ne peut pas se\nterminer normalement. Comme son traitement n'ap as pu se d\xe9rouler normalement,\nil est probable que la fonction qui l'a appel\xe9e consid\xe8re elle aussi qu'une\nerreur a eu lieu et termine son ex\xe9cution. L'erreur remonte ainsi la liste des\nappelants de la fonction qui a g\xe9n\xe9r\xe9 l'erreur. Ce processus continue, de\nfonction en fonction, jusqu'\xe0 ce que l'erreur soit compl\xe8tement g\xe9r\xe9e ou jusqu'\xe0\nce que le programme se termine (ce cas survient lorsque la fonction principale\nne peut pas g\xe9rer l'erreur)."}),"\n",(0,s.jsx)(n.p,{children:"Traditionnellement, ce m\xe9canisme est impl\xe9ment\xe9 \xe0 l'aide de codes de retour des\nfonctions. Chaque fonction doit renvoyer une valeur sp\xe9cifique \xe0 l'issue de son\nex\xe9cution, permettant d'indiquer si elle s'est correctement d\xe9roul\xe9e ou non. La\nvaleur renvoy\xe9e est donc utilis\xe9e par l'appelant pour d\xe9terminer la nature de\nl'erreur, et, si erreur il y a, prendre les mesures n\xe9cessaires. Cette m\xe9thode\npermet \xe0 chaque fonction de lib\xe9rer les ressources qu'elle a allou\xe9es lors de la\nremont\xe9e des erreurs, et d'effectuer ainsi sa part du traitement d'erreur."}),"\n",(0,s.jsx)(n.p,{children:"Malheureusement, cette technique n\xe9cessite de tester les codes de retour de\nchaque fonction appel\xe9e, et la logique d'erreur d\xe9velopp\xe9e finit par devenir\ntr\xe8s lourde, puisque ces tests s'imbriquent les une \xe0 la suite des autres et que\nle code du traitement des erreurs se trouve m\xe9lang\xe9 avec le code du\nfonctionnement normal de l'algorithme. Cette complication peut devenir ing\xe9rable\nlorsque plusieurs valeurs de codes de retour peuvent \xeatre renvoy\xe9es afin de\ndistinguer les diff\xe9rents cas d'erreur possible, car il peut en d\xe9couler un\ngrand nombre de tests et beaucoup de cas particulier \xe0 g\xe9rer dans les fonctions\nappelantes."}),"\n",(0,s.jsx)(n.p,{children:"Certains programmes utilisent donc une solution astucieuse, qui consiste \xe0\nd\xe9porter le traitement des erreurs \xe0 effectuer en dehors de l'algorithme par des\nsauts vers la fin de la fonction. Le code de nettoyage, qui se trouve alors\napr\xe8s l'algorithme, est ex\xe9cut\xe9 compl\xe8tement si tout se passe correctement. En\nrevanche, si la moindre erreur est d\xe9tect\xe9e en cours d'ex\xe9cution, un saut est\nr\xe9alis\xe9 vers la partie du code de nettoyage correspondante au traitement qui a\nd\xe9j\xe0 \xe9t\xe9 effectu\xe9. Ainsi, ce code n'est \xe9crit qu'une seule fois, et le\ntraitement des erreurs est situ\xe9 en dehors du traitement normal."}),"\n",(0,s.jsx)(n.p,{children:"La solution pr\xe9c\xe9dente est tout \xe0 fait valable (en fait, c'est m\xeame la solution\nla plus simple), mais elle souffre d'un inconv\xe9nient. Elle rend le programme\nmoins structur\xe9, car toutes les ressources utilis\xe9es par l'algorithme doivent\n\xeatre accessibles depuis le code de traitement des erreurs. Ces ressources\ndoivent donc \xeatre plac\xe9es dans une porte relativement globale, voir d\xe9clar\xe9es en\nte de fonction. De plus, le traitement des codes d'erreurs multiples pose\ntoujours les m\xeames probl\xe8mes de complication des tests."}),"\n",(0,s.jsx)(n.p,{children:"La solution qui met en oeuvre les exceptions est beaucoup plus simple, puisque\nla fonction qui d\xe9tecte une erreur peut se contenter de lancer une exception.\nCette exception interrompt l'ex\xe9cution de la fonction, et un gestionnaire\nd'exception appropri\xe9 est recherch\xe9. La recherche du gestionnaire suit le m\xeame\nchemin que celui utilis\xe9 lors de la remont\xe9e des erreurs : \xe0 savoir la liste des\nappelants. La premi\xe8re fonction appelante qui contient un gestionnaire\nd'exception appropri\xe9 prend donc le contr\xf4le, et effectue le traitement de\nl'erreur. Si le traitement est complet, le programme reprend son ex\xe9cution\nnormale. Dans le cas contraire, le gestionnaire d'exception peut relancer\nl'exception (auquel cas le gestionnaire d'exception suivant est recherch\xe9) ou\nterminer le programme."}),"\n",(0,s.jsx)(n.p,{children:"Le m\xe9canisme des exceptions du C++ garantit que tous les objets de classe de\nstockage automatique sont d\xe9truits lorsque l'exception qui remonte sort de leur\nport\xe9e. Ainsi, si toutes les ressources sont encapsul\xe9es dans des classes\ndisposant d'un destructeur capable de les d\xe9truire ou de les ramener dans un\n\xe9tat coh\xe9rent, la remont\xe9e des exceptions effectue automatiquement le m\xe9nage. De\nplus, les exceptions peuvent \xeatre typ\xe9es, et caract\xe9riser ainsi la nature de\nl'erreur qui s'est produite. Ce m\xe9canisme est donc strictement \xe9quivalent en\ntermes de fonctionnalit\xe9s aux aux codes d'erreurs utilis\xe9s pr\xe9c\xe9demment."}),"\n",(0,s.jsx)(n.p,{children:"Comme on le voit, les exceptions permettent de simplifier le code, en reportant\nen dehors de l'algorithme normal le traitement des erreurs. Par ailleurs, la\nlogique d'erreur est compl\xe8tement prise en charge par le langage, et le\nprogrammeur n'a plus \xe0 faire les tests qui permettent de d\xe9terminer le\ntraitement appropri\xe9 pour chaque type d'erreur. Les m\xe9canismes de gestion des\nexceptions du C++ sont d\xe9crits dans les paragraphes suivants."}),"\n",(0,s.jsx)(n.h2,{id:"lancement-et-r\xe9cup\xe9ration-dune-exception",children:"Lancement et r\xe9cup\xe9ration d'une exception"}),"\n",(0,s.jsxs)(n.p,{children:["En C++, lorsqu'il faut lancer une exception, on doit cr\xe9er un objet dont la\nclasse caract\xe9rise cette exception, et utiliser le mot cl\xe9 ",(0,s.jsx)(n.code,{children:"throw"}),". Sa syntaxe\nest la suivante :"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"throw objet;\n"})}),"\n",(0,s.jsx)(n.p,{children:"o\xf9 objet est l'objet correspondant \xe0 l'exception. Cet objet peut \xeatre de\nn'importe quel type, et pourra ainsi caract\xe9riser pleinement l'exception."}),"\n",(0,s.jsxs)(n.p,{children:["L'exception doit alors \xeatre trait\xe9e par le gestionnaire d'exception\ncorrespondant. On ne peut attraper que les exceptions qui sont apparues dans une\nzone de code limit\xe9e (cette zone est dite prot\xe9g\xe9e contre les erreurs\nd'ex\xe9cution), pas sur tout un programme. On doit donc placer le code susceptible\nde lancer une exception d'un bloc d'instructions particulier. Ce bloc est\nintroduit avec le mot cl\xe9 ",(0,s.jsx)(n.code,{children:"try"})," :"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"try{\n    // Code susceptible de g\xe9n\xe9rer des exceptions\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Les gestionnaires d'exceptions doivent suivre le bloc ",(0,s.jsx)(n.code,{children:"try"}),". Ils sont introduits\navec le mot cl\xe9 ",(0,s.jsx)(n.code,{children:"catch"})," :"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"catch (classe [&][temp]){\n    //Traitement de l'exception associ\xe9e \xe0 la classe\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["De m\xeame, les blocs ",(0,s.jsx)(n.code,{children:"catch"})," peuvent recevoir leurs param\xe8tres par valeur ou par\nr\xe9f\xe9rence, comme le montre la syntaxe indiqu\xe9e ci-dessus. En g\xe9n\xe9ral, il est\npr\xe9f\xe9rable d'utiliser une r\xe9f\xe9rence, afin d'\xe9viter une nouvelle copie de l'objet\nde l'exception pour le bloc ",(0,s.jsx)(n.code,{children:"catch"}),". Toutefois, on prendra garde au fait que\ndans ce cas, les modifications effectu\xe9es sur le param\xe8tre seront effectu\xe9es\ndans la copie de travail du compilateur et seront donc \xe9galement visibles dans\nles blocs ",(0,s.jsx)(n.code,{children:"catch"})," des fonctions appelantes ou de port\xe9e sup\xe9rieure, si\nl'exception est relanc\xe9e apr\xe8s traitement."]}),"\n",(0,s.jsxs)(n.p,{children:["Il peut y avoir plusieurs gestionnaires d'exceptions. Chacun traitera les\nexceptions qui ont \xe9t\xe9 g\xe9n\xe9r\xe9es dans le bloc ",(0,s.jsx)(n.code,{children:"try"})," et dont l'objet est de la\nclasse indiqu\xe9e par son param\xe8tre. Il n'est pas n\xe9cessaire de donner un nom \xe0\nl'objet (temp) dans l'expression ",(0,s.jsx)(n.code,{children:"catch"}),". Cependant, cela permet de le\nr\xe9cup\xe9rer, ce qui peut \xeatre n\xe9cessaire si l'on doit r\xe9cup\xe9rer des informations\nsur la nature de l'erreur."]}),"\n",(0,s.jsxs)(n.p,{children:["Enfin, il est possible de d\xe9finir un gestionnaire d'exception universel, qui\nr\xe9cup\xe9rera toutes les exceptions possibles, quels que soient leurs types. Ce\ngestionnaire d'exception doit prendre comme param\xe8tre trois points de suspension\nentre parenth\xe8ses dans sa clause ",(0,s.jsx)(n.code,{children:"catch"}),". Bien entendu, dans ce cas, il est\nimpossible de sp\xe9cifier une variable qui contient l'exception, puisque son type\nest ind\xe9fini."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <iostream>\n \nusing namespace std;\n \nclass erreur   // Premi\xe8re exception possible, associ\xe9e\n               // \xe0 l\'objet erreur.\n{\npublic:\n    int cause;  // Entier sp\xe9cifiant la cause de l\'exception.\n    // Le constructeur. Il appelle le constructeur de cause.\n    erreur(int c) : cause(c) {}\n    // Le constructeur de copie. Il est utilis\xe9 par le m\xe9canisme\n    // des exceptions :\n    erreur(const erreur &source) : cause(source.cause) {}\n};\n \nclass other {};   // Objet correspondant \xe0 toutes\n                  // les autres exceptions.\n \nint main(void)\n{\n    int i;            // Type de l\'exception \xe0 g\xe9n\xe9rer.\n    cout << "Tapez 0 pour g\xe9n\xe9rer une exception Erreur, "\n        "1 pour une Enti\xe8re :";\n    cin >> i;         // On va g\xe9n\xe9rer une des trois exceptions\n                      // possibles.\n    cout << endl;\n    try               // Bloc o\xf9 les exceptions sont prises en charge.\n    {\n        switch (i)    // Selon le type d\'exception d\xe9sir\xe9e,\n        {\n        case 0:\n            {\n                erreur a(0);\n                throw (a);   // on lance l\'objet correspondant\n                             // (ici, de classe erreur).\n                             // Cela interrompt le code. break est\n                             // donc inutile ici.\n            }\n        case 1:\n            {\n                int a=1;\n                throw (a);   // Exception de type entier.\n            }\n        default:             // Si l\'utilisateur n\'a pas tap\xe9 0 ou 1,\n            {\n                other c;     // on cr\xe9e l\'objet c (type d\'exception\n                throw (c);   // other) et on le lance.\n            }\n        }\n    }                 // fin du bloc try. Les blocs catch suivent :\n    catch (erreur &tmp) // Traitement de l\'exception erreur ...\n    {                 // (avec r\xe9cup\xe9ration de la cause).\n        cout << "Erreur erreur ! (cause " << tmp.cause << ")" << endl;\n    }\n    catch (int tmp)   // Traitement de l\'exception int...\n    {\n        cout << "Erreur int ! (cause " << tmp << ")" << endl;\n    }\n    catch (...)       // Traitement de toutes les autres\n    {                 // exceptions (...).\n                      // On ne peut pas r\xe9cup\xe9rer l\'objet ici.\n        cout << "Exception inattendue !" << endl;\n    }\n    return 0;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Selon ce qu'entre l'utilisateur, une exception du type erreur, int ou other est g\xe9n\xe9r\xe9e."}),"\n",(0,s.jsx)(n.h2,{id:"remont\xe9e-des-exceptions",children:"Remont\xe9e des exceptions"}),"\n",(0,s.jsxs)(n.p,{children:["Les fonctions int\xe9ress\xe9es par les exceptions doivent les capter avec le mot cl\xe9\n",(0,s.jsx)(n.code,{children:"catch"})," comme on l'a vu ci-dessus. Elles peuvent alors effectuer tous les\ntraitements d'erreurs que le C++ ne fera pas automatiquement. Ces traitements\ncomprennent g\xe9n\xe9ralement le r\xe9tablissement de l'\xe9tat des donn\xe9es manipul\xe9es par\nla fonction (dont, pour les fonctions membres d'une classe, les donn\xe9es membres\nde l'objet courant), ainsi que la lib\xe9ration des ressources non encapsul\xe9es dans\ndes objets de classe de stockage automatique (par exemple, les fichiers ouverts,\nles connexions r\xe9seau, etc)."]}),"\n",(0,s.jsx)(n.p,{children:"Une fois ce travail effectu\xe9, elles peuvent, si elles le d\xe9sirent, relancer\nl'exception, afin de permettre un traitement compl\xe9mentaire par leur fonction\nappelante. Le parcours de l'exception s'arr\xeatera donc d\xe8s que l'erreur aura \xe9t\xe9\ncompl\xe8tement trait\xe9e. Bien entendu, il est \xe9galement possible de lancer une\nautre exception que celle que l'on a re\xe7ue, comme ce peut \xeatre par exemple le\ncas si le traitement de l'erreur provoque lui-m\xeame une erreur."}),"\n",(0,s.jsxs)(n.p,{children:["Pour relancer l'exception en cours de traitement dans un gestionnaire\nd'exception, il faut utiliser le mot cl\xe9 ",(0,s.jsx)(n.code,{children:"throw"}),". La syntaxe est la suivante :"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"throw ;\n"})}),"\n",(0,s.jsx)(n.p,{children:"L'exception est alors relanc\xe9e, avec comme valeur l'objet que le compilateur a\nconstruit en interne pour propager l'exception. Les gestionnaires d'exception\npeuvent donc modifier les param\xe8tres des exceptions, s'ils les attrapent avec\nune r\xe9f\xe9rence."}),"\n",(0,s.jsx)(n.h2,{id:"liste-des-exceptions-autoris\xe9es-pour-une-fonction",children:"Liste des exceptions autoris\xe9es pour une fonction"}),"\n",(0,s.jsxs)(n.p,{children:["Il est possible de sp\xe9cifier les exceptions qui peuvent \xeatre lanc\xe9es par une\nfonction. Pour cela, il faut faire suivre son en-t\xeate du mot cl\xe9 ",(0,s.jsx)(n.code,{children:"throw"})," avec,\nentre parenth\xe8ses et s\xe9par\xe9es par des virgules, les classes des exceptions\nqu'elle est autoris\xe9e \xe0 lancer. Par exemple, la fonction suivante :"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int fonction_sensible(void)\nthrow(int, double, erreur){\n    ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["n'a le droit de lancer que des exceptions du type ",(0,s.jsx)(n.code,{children:"int"}),", ",(0,s.jsx)(n.code,{children:"double"})," ou ",(0,s.jsx)(n.code,{children:"erreur"}),".\nSi une exception d'un autre type est lanc\xe9e, par exemple une exception du type\n",(0,s.jsx)(n.code,{children:"char*"}),", il se produit encore une fois une erreur \xe0 l'ex\xe9cution."]}),"\n",(0,s.jsxs)(n.p,{children:["En fait, la fonction ",(0,s.jsx)(n.code,{children:"std::unexpected"})," est appel\xe9e. Cette fonction se comporte\nde mani\xe8re similaire \xe0 ",(0,s.jsx)(n.code,{children:"std::terminate"}),", puisqu'elle appelle par d\xe9faut une\nfonction de traitement de l'erreur qui elle-m\xeame appelle la fonction\n",(0,s.jsx)(n.code,{children:"std::terminate"})," (et donc ",(0,s.jsx)(n.code,{children:"abort"})," en fin de compte). Cela conduit \xe0 la\nterminaison du programme. On peut encore une fois changer ce comportement par\nd\xe9faut en rempla\xe7ant la fonction appel\xe9e par ",(0,s.jsx)(n.code,{children:"std::unexpected"})," par une autre\nfonction \xe0 l'aide de ",(0,s.jsx)(n.code,{children:"std::set_unexpected"}),", qui est d\xe9clar\xe9e dans le fichier\nd'en-t\xeate exception. Cette derni\xe8re attend en param\xe8tre un pointeur sur la\nfonction de traitement d'erreur, qui ne doit prendre aucun param\xe8tre et qui ne\ndoit rien renvoyer. ",(0,s.jsx)(n.code,{children:"std::set_unexpected"})," renvoie le pointeur sur la fonction de\ntraitement d'erreur pr\xe9c\xe9demment appel\xe9e par ",(0,s.jsx)(n.code,{children:"std::unexpected"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Il est possible de relancer une autre exception \xe0 l'int\xe9rieur de la fonction de\ntraitement d'erreur. Si cette exception satisfait la liste des exceptions\nautoris\xe9es, le programme reprend son cours normalement dans le gestionnaire\ncorrespondant. C'est g\xe9n\xe9ralement ce que l'on cherche \xe0 faire. Le gestionnaire\npeut \xe9galement lancer une exception de type ",(0,s.jsx)(n.code,{children:"std::bad_exception"}),", d\xe9clar\xe9e comme\nsuit dans le fichier d'en-t\xeate exception :"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class bad_exception : public exception\n{\npublic:\n    bad_exception(void) throw();\n    bad_exception(const bad_exception &) throw();\n    bad_exception &operator=(const bad_exception &) throw();\n    virtual ~bad_exception(void) throw();\n    virtual const char *what(void) const throw();\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"Cela a pour cons\xe9quence de terminer le programme."}),"\n",(0,s.jsxs)(n.p,{children:["Enfin, le gestionnaire d'exceptions non autoris\xe9es peut directement mettre fin \xe0\nl'ex\xe9cution du programme en appelant ",(0,s.jsx)(n.code,{children:"std::terminate"}),". C'est le comportement\nutilis\xe9 par la fonction ",(0,s.jsx)(n.code,{children:"std::unexpected"})," d\xe9finie par d\xe9faut."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <iostream>\n#include <exception>\n \nusing namespace std;\n \nvoid mon_gestionnaire(void)\n{\n    cout << "Une exception ill\xe9gale a \xe9t\xe9 lanc\xe9e." << endl;\n    cout << "Je relance une exception de type int." << endl;\n    throw 2;\n}\n \nint f(void) throw (int)\n{\n    throw "5.35";\n}\n \nint main(void)\n{\n    set_unexpected(&mon_gestionnaire);\n    try\n    {\n        f();\n    }\n    catch (int i)\n    {\n        cout << "Exception de type int re\xe7ue : " <<\n           i << endl;\n    }\n    return 0;\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"hi\xe9rarchie-des-exceptions",children:"Hi\xe9rarchie des exceptions"}),"\n",(0,s.jsxs)(n.p,{children:["Le m\xe9canisme des exceptions du C++ se base sur le typage des objets, puisque le\nlancement d'une exception n\xe9cessite la construction d'un objet qui la\ncaract\xe9rise, et le bloc ",(0,s.jsx)(n.code,{children:"catch"})," destination de cette exception sera s\xe9lectionn\xe9\nen fonction du type de cet objet. Bien entendu, les objets utilis\xe9s pour lancer\nles exceptions peuvent contenir des informations concernant la nature des\nerreurs qui se produisent, mais il est \xe9galement possible de classifier ces\nerreurs par cat\xe9gories en se basant sur les types."]}),"\n",(0,s.jsx)(n.p,{children:"En effet, les objets exceptions peuvent \xeatre des instances de classes disposant\nde relations d'h\xe9ritage. Comme les objets des classes d\xe9riv\xe9es peuvent \xeatre\nconsid\xe9r\xe9s comme des instances de leurs classes de base, les gestionnaires\nd'exception peuvent r\xe9cup\xe9rer les exceptions de ces classes d\xe9riv\xe9es en\nr\xe9cup\xe9rant un objet du type d'une de leurs classes de base. Ainsi, il est\npossible de classifier les diff\xe9rents cas d'erreurs en d\xe9finissant une\nhi\xe9rarchie de classe d'exceptions, et d'\xe9crire des traitements g\xe9n\xe9riques en\nn'utilisant que les objets d'un certain niveau dans cette hi\xe9rarchie."}),"\n",(0,s.jsx)(n.p,{children:"Le m\xe9canisme des exceptions se montre donc plus puissant que toutes les autres\nm\xe9thodes de traitement d'erreurs \xe0 ce niveau, puisque la s\xe9lection du\ngestionnaire d'erreur est automatiquement r\xe9alis\xe9e par le langage. Cela peut\n\xeatre tr\xe8s pratique pour peu que l'on ait d\xe9fini correctement sa hi\xe9rarchie de\nclasses d'exceptions."}),"\n",(0,s.jsx)(n.p,{children:"La biblioth\xe8que standard C++ d\xe9finit elle-m\xeame un certain nombre d'exceptions\nstandards, qui sont utilis\xe9es pour signaler les erreurs qui se produisent \xe0\nl'ex\xe9cution des programmes. Quelques-unes de ces exceptions ont d\xe9j\xe0 \xe9t\xe9\npr\xe9sent\xe9es avec les fonctionnalit\xe9s qui sont susceptibles de les lancer."}),"\n",(0,s.jsx)(n.h2,{id:"exceptions-dans-les-contructeurs",children:"Exceptions dans les contructeurs"}),"\n",(0,s.jsx)(n.p,{children:"Il est parfaitement l\xe9gal de lancer une exception dans un constructeur. En fait,\nc'est m\xeame la seule solution pour signaler une erreur lors de la construction\nd'un objet, puisque les constructeurs n'ont pas de valeur de retour."}),"\n",(0,s.jsxs)(n.p,{children:["Lorsqu'une exception est lanc\xe9e \xe0 partir d'un constructeur, la construction de\nl'objet \xe9choue. Par cons\xe9quent, le compilateur n'appellera jamais le destructeur\npour cet objet, puisque cela n'a pas de sens. Cependant, ce comportement soul\xe8ve\nle probl\xe8me des objets partiellement initialis\xe9s, pour lesquels il est\nn\xe9cessaire de faire un peu de nettoyage \xe0 la suite du lancement de l'exception.\nLe C++ dispose donc d'une syntaxe particuli\xe8re pour les constructeurs des objets\nsusceptibles de lancer des exceptions. Cette syntaxe particuli\xe8re permet\nsimplement d'utiliser un bloc ",(0,s.jsx)(n.code,{children:"try"})," pour le corps de fonction des constructeurs.\nLes blocs ",(0,s.jsx)(n.code,{children:"catch"})," suivent alors la d\xe9finition du constructeur, et effectuent la\nlib\xe9ration des ressources que le constructeur aurait pu allouer avant que\nl'exception ne se produise."]}),"\n",(0,s.jsxs)(n.p,{children:["Le comportement du bloc ",(0,s.jsx)(n.code,{children:"catch"})," des constructeurs avec bloc ",(0,s.jsx)(n.code,{children:"try"})," est diff\xe9rent\nde celui des blocs ",(0,s.jsx)(n.code,{children:"catch"})," classique. En effet, les exceptions ne sont\nnormalement pas relanc\xe9es une fois qu'elles ont \xe9t\xe9 trait\xe9es. Comme on l'a vu\nci-dessus, il faut utiliser explicitement le mot cl\xe9 ",(0,s.jsx)(n.code,{children:"throw"})," pour relancer une\nexception \xe0 l'issue de son traitement. Dans le cas des constructeurs avec un\nbloc ",(0,s.jsx)(n.code,{children:"try"})," cependant, l'exception est syst\xe9matiquement relanc\xe9e. Le bloc ",(0,s.jsx)(n.code,{children:"catch"}),"\ndu constructeur ne doit donc prendre en charge que la destruction des donn\xe9es\nmembres partiellement construites, et il faut toujours capter l'exception au\nniveau du programme qui a cherch\xe9e \xe0 cr\xe9er l'objet."]}),"\n",(0,s.jsxs)(n.p,{children:["De m\xeame, lorsque la construction de l'objet se fait dans le cadre d'une\nallocation dynamique de m\xe9moire, le compilateur appelle automatiquement\nl'op\xe9rateur ",(0,s.jsx)(n.code,{children:"delete"})," afin de restituer la m\xe9moire allou\xe9e pour cet objet. Il est\ndonc inutile de restituer la m\xe9moire de l'objet allou\xe9 dans le traitement de\nl'exception qui suit la cr\xe9ation dynamique de l'objet, et il ne faut pas y\nappeler l'op\xe9rateur ",(0,s.jsx)(n.code,{children:"delete"})," manuellement."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <iostream>\n#include <stdlib.h>\n \nusing namespace std;\n \nclass A\n{\n    char *pBuffer;\n    int  *pData;\n \npublic:\n    A() throw (int);\n \n    ~A()\n    {\n        cout << "A::~A()" << endl;\n    }\n \n    static void *operator new(size_t taille)\n    {\n        cout << "new()" << endl;\n        return malloc(taille);\n    }\n \n    static void operator delete(void *p)\n    {\n        cout << "delete" << endl;\n        free(p);\n    }\n};\n \n// Constructeur susceptible de lancer une exception :\nA::A() throw (int)\ntry\n{\n    pBuffer = NULL;\n    pData = NULL;\n    cout << "D\xe9but du constructeur" << endl;\n    pBuffer = new char[256];\n    cout << "Lancement de l\'exception" << endl;\n    throw 2;\n    // Code inaccessible :\n    pData = new int;\n}\ncatch (int)\n{\n    cout << "Je fais le m\xe9nage..." << endl;\n    delete[] pBuffer;\n    delete pData;\n}\n \n \nint main(void)\n{\n    try\n    {\n        A *a = new A;\n    }\n    catch (...)\n    {\n        cout << "A\xefe, m\xeame pas mal !" << endl;\n    }\n    return 0;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Dans cet exemple, lors de la cr\xe9ation dynamique d'un objet ",(0,s.jsx)(n.code,{children:"A"}),", une erreur\nd'initialisation se produit et une exception est lanc\xe9e. Celle-ci est alors\ntrait\xe9e dans le bloc ",(0,s.jsx)(n.code,{children:"catch"})," qui suit la d\xe9finition du constructeur de la classe\n",(0,s.jsx)(n.code,{children:"A"}),". L'op\xe9rateur ",(0,s.jsx)(n.code,{children:"delete"})," est bien appel\xe9 automatiquement, mais le destructeur\nde ",(0,s.jsx)(n.code,{children:"A"})," n'est jamais ex\xe9cut\xe9."]}),"\n",(0,s.jsxs)(n.p,{children:["En g\xe9n\xe9ral, si une classe h\xe9rite de une ou plusieurs classes de base, l'appel\naux constructeurs des classes de base doit se faire entre le mot cl\xe9 ",(0,s.jsx)(n.code,{children:"try"})," et la\npremi\xe8re accolade. En effet, les constructeurs des classes de base sont\nsusceptibles, eux aussi, de lancer des exceptions. La syntaxe est alors la\nsuivante"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"Classe::Classe\n   try : Base(param\xe8tres) [, Base(param\xe8tres) [...]]\n{\n}\ncatch ...\n"})})]})}function d(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>o});var s=t(67294);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);