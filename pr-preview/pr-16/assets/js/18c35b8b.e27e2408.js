"use strict";(self.webpackChunksedelpeuch_net=self.webpackChunksedelpeuch_net||[]).push([[3525],{39475:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"enseirb/s7/poo/9","title":"Autres m\xe9canismes (non objet) - Les types param\xe9tr\xe9s","description":"Les types param\xe9tr\xe9s (\\"parameterized type\\") est un m\xe9canisme de programmation","source":"@site/docs/enseirb/s7/poo/9.md","sourceDirName":"enseirb/s7/poo","slug":"/enseirb/s7/poo/9","permalink":"/pr-preview/pr-16/docs/enseirb/s7/poo/9","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Autres m\xe9canismes (non objet) - Les types param\xe9tr\xe9s"},"sidebar":"tutorialSidebar","previous":{"title":"Autres m\xe9canismes (non objet) - Le M\xe9canisme des exceptions","permalink":"/pr-preview/pr-16/docs/enseirb/s7/poo/8"},"next":{"title":"Programmation Syst\xe8me","permalink":"/pr-preview/pr-16/docs/enseirb/s7/prog_sys/"}}');var a=r(74848),t=r(28453);const o={title:"Autres m\xe9canismes (non objet) - Les types param\xe9tr\xe9s"},i=void 0,l={},c=[{value:"Les conetneurs de donn\xe9es",id:"les-conetneurs-de-donn\xe9es",level:2},{value:"Coh\xe9rence de type",id:"coh\xe9rence-de-type",level:2},{value:"Pour les tableaux",id:"pour-les-tableaux",level:3},{value:"Pour les classes &quot;collection&quot;",id:"pour-les-classes-collection",level:3},{value:"Param\xe9trer les types",id:"param\xe9trer-les-types",level:2},{value:"Compilation d&#39;une classe param\xe9tr\xe9e",id:"compilation-dune-classe-param\xe9tr\xe9e",level:3},{value:"Envoi de messages sur un param\xe8tre formel",id:"envoi-de-messages-sur-un-param\xe8tre-formel",level:3},{value:"Relation de type/sous-type entre param\xe8tres effectifs",id:"relation-de-typesous-type-entre-param\xe8tres-effectifs",level:2},{value:"La variance des types param\xe9tr\xe9s",id:"la-variance-des-types-param\xe9tr\xe9s",level:3},{value:"Invariance",id:"invariance",level:4},{value:"Covariance",id:"covariance",level:4},{value:"Contravariance",id:"contravariance",level:4},{value:"Bivariance",id:"bivariance",level:4}];function d(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:'Les types param\xe9tr\xe9s ("parameterized type") est un m\xe9canisme de programmation\ng\xe9n\xe9rique introduit dans la version 5.0 du langage java.'}),"\n",(0,a.jsx)(n.p,{children:"Il permet de d\xe9finir une classe/interface ou une m\xe9thode sans pr\xe9cision du type\nde variables, param\xe8tres et la valeur de retour. La sp\xe9cification des types\nmanquants est faite au moment de l'utilisation (pour une classe \xe0\nl'instanciation ou la d\xe9claration d'une variable de cette classe, pour une\nm\xe9thode \xe0 son appel)."}),"\n",(0,a.jsx)(n.p,{children:"L'exemple standard de la programmation g\xe9n\xe9rique se trouve dans l'utilisation et\nla r\xe9alisation des classes conteneurs de donn\xe9es."}),"\n",(0,a.jsx)(n.h2,{id:"les-conetneurs-de-donn\xe9es",children:"Les conetneurs de donn\xe9es"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"D\xe9finition"})," : une classe \"conteneur\" encapsule une collection d'objets dans\nune structure de donn\xe9es particuli\xe8re (liste, ensemble, pile, arbre, ...). Elle\nest charg\xe9e du stockage, de la gestion (ajouter, enlever,...) de l'acc\xe8s \xe0 un\nobjet et du parcours des objets de la collection (notion d'it\xe9rateur)."]}),"\n",(0,a.jsx)(n.p,{children:"Un conteneur ne d\xe9clenche pas le comportement des objets de la collection (\xe0\npart l'\xe9galit\xe9 et la comparaison tir\xe9). Pourtant, dans un langage typ\xe9, la\nr\xe9alisation de ces conteneurs entra\xeene un probl\xe8me de coh\xe9rence du type des\n\xe9l\xe9ments g\xe9r\xe9s par un conteneur."}),"\n",(0,a.jsx)(n.h2,{id:"coh\xe9rence-de-type",children:"Coh\xe9rence de type"}),"\n",(0,a.jsx)(n.p,{children:'En Java, les classes "conteneurs" les plus communes sont fournies :'}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"par les tableaux"}),"\n",(0,a.jsxs)(n.li,{children:["par des classes collection de l'API standard, dans le paquetage ",(0,a.jsx)(n.code,{children:"java.util"}),"\n(voir les interfaces ",(0,a.jsx)(n.code,{children:"Collection"})," et ",(0,a.jsx)(n.code,{children:"Iterator"}),")."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"pour-les-tableaux",children:"Pour les tableaux"}),"\n",(0,a.jsx)(n.p,{children:"Exemple d'une erreur de coh\xe9rence de type avec un tableau"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'public class CoherenceTableau{\n    static void parcours(Porte[] portes){\n        for(int i = 0; i < portes.length; i++){\n            pourtes[i].ouvrir();\n        }\n    }\n\n    public static void main(String[] args){\n        Porte[] mesPortes = new Porte[3];\n\n        mesPortes[0] = new PorteCoulissante(20);\n        mesPortes[1] = new PorteCharniere();\n        mesPortes[2] = "Coucou";\n\n        parcours(mesPortes);\n    }\n}\n\n/*\n% javac CoherenceTableau.java\nConteneur.java:17: incompatible types\nfound : java.lang.String\nrequired : Porte\nerror\n*/\n'})}),"\n",(0,a.jsx)(n.p,{children:"La d\xe9claration d'un tableau sp\xe9cifie le type des objets accept\xe9s par la\ncollection. La coh\xe9rence de type est v\xe9rifi\xe9e \xe0 la compilation lors de l'ajout\nd'un objet."}),"\n",(0,a.jsx)(n.h3,{id:"pour-les-classes-collection",children:'Pour les classes "collection"'}),"\n",(0,a.jsxs)(n.p,{children:["Dans la r\xe9alisation de ces classes, le type des \xe9l\xe9ments est d\xe9clar\xe9 du type\n",(0,a.jsx)(n.code,{children:"Object"})," puisque c'est la racine de la hi\xe9rarchie de classes en java. Les\nm\xe9thodes d'ajout et d'acc\xe8s utilisent aussi le type ",(0,a.jsx)(n.code,{children:"Object"}),". La coh\xe9rence de\ntype est v\xe9rifi\xe9e \xe0 l'ex\xe9cution lors de l'acc\xe8s \xe0 un \xe9l\xe9ment de la collection.\nIl est n\xe9cessaire d'inclure un code de v\xe9rification de la conversion de type\n(op\xe9rateur ",(0,a.jsx)(n.code,{children:"instanceof"})," ou par capture de l'exception\n",(0,a.jsx)(n.code,{children:"java.lang.ClassCastException"}),")."]}),"\n",(0,a.jsx)(n.h2,{id:"param\xe9trer-les-types",children:"Param\xe9trer les types"}),"\n",(0,a.jsx)(n.p,{children:"Le m\xe9canisme des types param\xe9tr\xe9s peut s'utiliser sur une interface, une classe,\nune m\xe9thode ou un constructeur. L'objectif est de d\xe9tecter l'incoh\xe9rence de type\ndans un conteneur \xe0 la compilation plut\xf4t qu'\xe0 l'ex\xe9cution. Pour cela, il est\npossible de d\xe9finir le type des \xe9l\xe9ments \xe0 l'utilisation du conteneur."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"ClasseParametree<Porte, PassagerStandard> var;\n\nvar = new ClasseParametree<Porte, PassagerStandard>();\nvar.methodeParametree(new DentBleu());\n"})}),"\n",(0,a.jsx)(n.p,{children:'Dans la d\xe9finition d\'une classe param\xe9tr\xe9e, il est n\xe9cessaire de d\xe9clarer des\n"param\xe8tres formels" pour la sp\xe9cification du type. Par convention, le nom du\nparam\xe8tre formel est une seule lettre en majuscule.'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"class ClassParametree<E,T>{\n    private E uneInstance;\n    public T nomMethode(E par1, String par2){\n        T t;\n        //...\n        return t;\n    }\n    public <U> void methodeParametree(U u){\n        //...\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Chaque param\xe8tre effectif pr\xe9cis\xe9 \xe0 l'utilisation va remplacer dans l'ordre\nchaque param\xe8tre formel de la d\xe9finition."}),"\n",(0,a.jsxs)(n.p,{children:["Coh\xe9rence de type pour la version avec type param\xe9tr\xe9 de la classe\n",(0,a.jsx)(n.code,{children:"java.util.Vector"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'Vector<Porte> portes = new Vector<Porte>(5);\n\nportes.add(new PorteCoulissante(999));\nportes.add(new PorteCharniere());\nportes.add("Coucou") // erreur \xe0 la compilation\n\nVector<PorteCoulissante> coulissantes = new Vector<PorteCoulissante>(3);\n\ncoulissantes.add(new PorteCoulissante(666));\ncoulissantes.add(new PorteCharniere()); //erreur \xe0 la compilation\n'})}),"\n",(0,a.jsxs)(n.p,{children:["L'acc\xe8s aux \xe9l\xe9ments se fait sans conversion de type. Le langage Java a\nintroduit une boucle simplifi\xe9e pour le parcours d'un conteneur param\xe9tr\xe9 de\nl'API ",(0,a.jsx)(n.code,{children:"java.util.Collection"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"void boucleSimpleifiee(Vector<Porte> portes){\n    for(Porte p : portes)\n        p.ouvir();\n    //\xe9quivalent \xe0\n    for(Iterator<Porte> it = portes.iterator(); it.hasNext();){\n        Porte p = it.next();\n        p.ouvrir();\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"Remarque"}),": Pour des raisons de compatibilit\xe9, il n'est pas obligatoire de\npr\xe9ciser le type param\xe9tr\xe9 \xe0 la d\xe9claration ou \xe0 l'instanciation (le type est\nalors ",(0,a.jsx)(n.code,{children:"Object"}),")."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"Vector desObjets = new Vector(5);\n// \xe9quivalent \xe0\nVector<Object>  desObjets = new Vector<Object>(5);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"compilation-dune-classe-param\xe9tr\xe9e",children:"Compilation d'une classe param\xe9tr\xe9e"}),"\n",(0,a.jsx)(n.p,{children:"En Java, tous les param\xe8tres effectifs d'une classe param\xe9tr\xe9e partagent le m\xeame\ncode. Il y a toujours un seul fichier compil\xe9 (.class) par classe. Le m\xe9canisme\nn'implique pas une recompilation du code pour chaque utilisation d'une classe\nparam\xe9tr\xe9e."}),"\n",(0,a.jsxs)(n.p,{children:["L'information sur une type param\xe9tr\xe9 est pr\xe9sente que pour la compilation de\nl'utilisation de la classe param\xe9tr\xe9e. Dans la fichier compil\xe9, l'information\nsur le type param\xe9tr\xe9 est remplac\xe9e par le type ",(0,a.jsx)(n.code,{children:"Object"}),'; il y a effacement du\ntype ("erasure type").']}),"\n",(0,a.jsx)(n.p,{children:"Cette compilation unique aboutit \xe0 des contraintes sur l'utilisation des types\nparam\xe9tr\xe9s :"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Un type param\xe9tr\xe9 n'est possible qu'avec des r\xe9f\xe9rences."}),"\n",(0,a.jsxs)(n.li,{children:["Les instruction impliquant la classe ne sont pas autoris\xe9es sur un type\nparam\xe9tr\xe9 : ",(0,a.jsx)(n.code,{children:"new T(),T.methodeDeClasse(), new T[initTaille]"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"envoi-de-messages-sur-un-param\xe8tre-formel",children:"Envoi de messages sur un param\xe8tre formel"}),"\n",(0,a.jsxs)(n.p,{children:["Le compilateur v\xe9rifie la validit\xe9 d'un envoi de message par rapport au type de\nla variable. Il est possible de donner une contrainte sur le param\xe8tre formel\npour s'assurer d'un intervale de type. Par exemple tous les sous-types de\nl'interface ",(0,a.jsx)(n.code,{children:"Porte"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"public <U extends Porte> void parametreUneMethode(U u){\n    u.estFerme();\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Le compilateur v\xe9rifie cette contraintes sur le param\xe8tre effectif. Il est\npossible de combiner ces contraintes, par exemple : ",(0,a.jsx)(n.code,{children:"<T extends Porte 1 Comparable<T>>"})]}),"\n",(0,a.jsx)(n.h2,{id:"relation-de-typesous-type-entre-param\xe8tres-effectifs",children:"Relation de type/sous-type entre param\xe8tres effectifs"}),"\n",(0,a.jsxs)(n.p,{children:["Comment consid\xe9rer les trois conteneurs ",(0,a.jsx)(n.code,{children:"Vector<Porte>, Vector<PorteCoulissante>"})," et ",(0,a.jsx)(n.code,{children:"Vector<PorteCharniere>"})," par rapprot \xe0 la relation\nde type / sous-type entre ",(0,a.jsx)(n.code,{children:"ProteCharniere"}),", ",(0,a.jsx)(n.code,{children:"PorteCoulissante"})," et ",(0,a.jsx)(n.code,{children:"Porte"})," ?"]}),"\n",(0,a.jsxs)(n.p,{children:["Regardons le cas des tableaux, il est possible de passer le param\xe8tre\n",(0,a.jsx)(n.code,{children:"PorteCoulissante[]"})," \xe0 la m\xe9thode ",(0,a.jsx)(n.code,{children:"parcours(Porte[] portes)"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"static void parcours(Porte[] portes){\n    for (Porte p : portes){\n        if(p != null)\n            p.ouvrir();\n    }\n//...\nPorteCoulissante[] coulissantes = new PorteCoulissante[3];\n\ncoulissantes[0] = new PorteCoulissante(20);\ncoulissantes[1] = new PorteCoulissante(10);\ncoulissantes[2] = new PorteCoulissante(11);\n\nparcours(coulissantes);\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Quand la relation de type/sous-type est transmise aux conteneurs, nous avons un\nm\xe9canisme de covariance. C'est le cas pour les tableaux, ",(0,a.jsx)(n.code,{children:"PorteCoulissante[]"}),"\nest sous-type de ",(0,a.jsx)(n.code,{children:"Porte[]"}),". Cela permet de factoriser la m\xe9thode ",(0,a.jsx)(n.code,{children:"parcours()"})," \xe0\ntous les tableaux correspondant \xe0 un sous-type de ",(0,a.jsx)(n.code,{children:"Porte"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Que se passe-t-il si le tableau r\xe9f\xe9renc\xe9 par la variable de type ",(0,a.jsx)(n.code,{children:"Porte[]"})," est\nmodifi\xe9 ?"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"PorteCoulissante[] coulissantes = new PorteCoulissante[3];\n\nPorte[] portes = coulissantes;\nportes[0] = new PorteCoulissante(66);\nportes[1] = new PorteCharniere();\n\ncoulissantes[1].coulisser();\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Les conteneur typ\xe9 par ",(0,a.jsx)(n.code,{children:"PorteCoulissante"})," contient une instance de\n",(0,a.jsx)(n.code,{children:"PorteCharniere"}),". Pour les tableaux, cette incoh\xe9rence est d\xe9tect\xe9e non pas \xe0 la\ncompilation mais \xe0 l'ex\xe9cution : la v\xe9rification est faite au moment de\nl'affectation avec la lev\xe9e de l'exception ",(0,a.jsx)(n.code,{children:"java.lang.ArrayStoreException"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"la-variance-des-types-param\xe9tr\xe9s",children:"La variance des types param\xe9tr\xe9s"}),"\n",(0,a.jsx)(n.p,{children:"Par d\xe9faut, la relation de type/sous-type du param\xe8tre effectif n'est pas\ntransmise \xe0 la classe param\xe9tr\xe9e. C'est l'invariance."}),"\n",(0,a.jsx)(n.p,{children:"Mais, pour permettre la factorisation de code, le langage Java permet de\nmodifier la variance des classes param\xe9tr\xe9es sous certaines contraintes qui vont\nassurer la coh\xe9rence du conteneur."}),"\n",(0,a.jsx)(n.h4,{id:"invariance",children:"Invariance"}),"\n",(0,a.jsxs)(n.p,{children:["Dans notre exemple, ",(0,a.jsx)(n.code,{children:"Vector<PorteCharniere>"})," et ",(0,a.jsx)(n.code,{children:"Vector<PorteCoulissante>"})," ne\nsont pas sous-type de ",(0,a.jsx)(n.code,{children:"Vector<Porte>"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"static void parcours(Vector<Porte> portes){\n    for(Porte p : portes)\n        if(p != null)\n            p.ouvrir();\n}\n//...\nparcours(new Vector<Porte>());\nparcours(new Vector<PorteCoulissante>()); //erreur \xe0 la compilation\nparcours(new Vector<PorteCharniere>()); //erreur \xe0 la compilation\n"})}),"\n",(0,a.jsx)(n.h4,{id:"covariance",children:"Covariance"}),"\n",(0,a.jsxs)(n.p,{children:["Le type de la classe param\xe9tr\xe9e varie de la m\xeame mani\xe8re que le type du\nparam\xe8tre effectif. La covariance est indiqu\xe9e par le mot-cl\xe9 ",(0,a.jsx)(n.code,{children:"extends"})," au\nniveau du param\xe8tre formel. Pour acc\xe9der aux \xe9l\xe9mnets du conteneur, c'est la\nborne sup\xe9rieure qui est fix\xe9e (les \xe9l\xe9ments sont r\xe9cup\xe9r\xe9s \xe0 travers ce type) :\n",(0,a.jsx)(n.code,{children:"<D extends B>"})," toute classe ",(0,a.jsx)(n.code,{children:"D"})," sous-type de la classe ",(0,a.jsx)(n.code,{children:"B"})," ou ",(0,a.jsx)(n.code,{children:"<? extends B>"}),"\ntoute classe sous-type de la classe ",(0,a.jsx)(n.code,{children:"B"}),". Avec la covariance, le code de la\nm\xe9thode ",(0,a.jsx)(n.code,{children:"parcours()"})," est valide pour des instance de ",(0,a.jsx)(n.code,{children:"Vector<PorteCharniere>"})," et\n",(0,a.jsx)(n.code,{children:"Vector<PorteCoulissante>"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"static void parcours(Vector<? extends Porte> portes){\n    for(Porte p : portes)\n        if(p != null)\n            p.ouvrir();\n}\n\nstatic void <T extends Porte> autreEcriture(Vector <T> portes){\n    for(T p : portes)\n        if (p != null)\n            p.ouvrir();\n}\n\n//...\n\nparcours(new Vector<Porte>());\nparcours(new Vector<PorteCoulissante>());\nautreEcriture(new Vector<PorteCharniere>());\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Pour \xe9viter une incoh\xe9rence des \xe9l\xe9ments du conteneur (le probl\xe8me rencontr\xe9\navec les tableaux), la covariance ne permet pas la modification du conteneur\npass\xe9 en param\xe8tre. Dans le code de la m\xe9thode ",(0,a.jsx)(n.code,{children:"parcours(Vector<? extends Porte> portes)"}),", l'instruction ",(0,a.jsx)(n.code,{children:"portes.add(new PorteCharniere());"})," provoque une erreur\nde compilation."]}),"\n",(0,a.jsx)(n.h4,{id:"contravariance",children:"Contravariance"}),"\n",(0,a.jsxs)(n.p,{children:["Pour factoriser le code qui ajoute un \xe9l\xe9ment \xe0 un conteneur, il faut utiliser\nla contravariance. La contravariance est indiqu\xe9e par le mot-cl\xe9 ",(0,a.jsx)(n.code,{children:"super"})," au\nniveau du param\xe8tre formel. Pour modifier le conteneur, il faut fixer la borne\ninf\xe9rieure du type accept\xe9 : ",(0,a.jsx)(n.code,{children:"<? super C>"})," toute classe dont la classe ",(0,a.jsx)(n.code,{children:"C"})," est\nle sous-type."]}),"\n",(0,a.jsxs)(n.p,{children:["Par exemple, pour ajouter des instances de ",(0,a.jsx)(n.code,{children:"PorteCoulissante"}),", il faut que le\ntype param\xe9tr\xe9 soit au moins ",(0,a.jsx)(n.code,{children:"PorteCoulissante"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"static void ajouter(Vector <? super PorteCoulissante> portes){\n    portes.add(new PorteCoulissante(999));\n    portes.add(new PorteCoulissante(666));\n    portes.add(new PorteCharniere()); //erreur \xe0 la compilation\n}\n\najouter(new Vector<Porte>());\najouter(new Vector<PorteCoulissante>());\najouter(new Vector <PorteCharniere>()); //erreur \xe0 la compilation\n"})}),"\n",(0,a.jsx)(n.p,{children:"La contravariance interdit l'acc\xe8s aux \xe9l\xe9ments du conteneur pass\xe9 en param\xe8tre;\ncela provoque une erreur \xe0 la compilation."}),"\n",(0,a.jsx)(n.h4,{id:"bivariance",children:"Bivariance"}),"\n",(0,a.jsxs)(n.p,{children:["La bivariance est indiqu\xe9e par le caract\xe8re joker seul ",(0,a.jsx)(n.code,{children:"<?>"}),". Dans ce cas,\ntoutes les classes sont accept\xe9es. Il n'est pas possible de modifier le\nconteneur et le \xe9l\xe9ment sont r\xe9cup\xe9r\xe9s sous le type ",(0,a.jsx)(n.code,{children:"Object"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'void bivariant(Vector<?> v){\n    v.add(new PorteCoulissante(999)); //erreur \xe0 la compilation\n    v.add("coucou"); //erreur \xe0 la compilation\n    Porte p1 = v.get(0); //erreur \xe0 la compilation\n\n    Porte p2 = (Porte) v.get(0);\n    Object o = v.get(0);\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>i});var s=r(96540);const a={},t=s.createContext(a);function o(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);