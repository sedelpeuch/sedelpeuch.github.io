"use strict";(self.webpackChunksedelpeuch_net=self.webpackChunksedelpeuch_net||[]).push([[1842],{79220:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>u,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var t=s(74848),r=s(28453);const a={title:"La couche objet - Partie 2 : Constructeur, Destructeurs, Pointeur this, Statique, Surcharge"},i=void 0,l={id:"enseirb/s7/cpp/2",title:"La couche objet - Partie 2 : Constructeur, Destructeurs, Pointeur this, Statique, Surcharge",description:"Constructeurs et destructeurs",source:"@site/docs/enseirb/s7/cpp/2.md",sourceDirName:"enseirb/s7/cpp",slug:"/enseirb/s7/cpp/2",permalink:"/pr-preview/pr-12/docs/enseirb/s7/cpp/2",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"La couche objet - Partie 2 : Constructeur, Destructeurs, Pointeur this, Statique, Surcharge"},sidebar:"tutorialSidebar",previous:{title:"La couche objet - Partie 1 : Classe, H\xe9ritage, Classe virtuelle, fonction et classes amies",permalink:"/pr-preview/pr-12/docs/enseirb/s7/cpp/1"},next:{title:"La couche Objet - Partie 3 : op\xe9rateurs",permalink:"/pr-preview/pr-12/docs/enseirb/s7/cpp/3"}},u={},c=[{value:"Constructeurs et destructeurs",id:"constructeurs-et-destructeurs",level:2},{value:"D\xe9finition des constructeurs et des destructeurs",id:"d\xe9finition-des-constructeurs-et-des-destructeurs",level:3},{value:"Constructeurs de copie",id:"constructeurs-de-copie",level:3},{value:"Utilisation des constructeurs dans les transtypages",id:"utilisation-des-constructeurs-dans-les-transtypages",level:3},{value:"Pointeur <code>this</code>",id:"pointeur-this",level:2},{value:"Donn\xe9es et fonctions membres statiques",id:"donn\xe9es-et-fonctions-membres-statiques",level:2},{value:"Donn\xe9es membres statiques",id:"donn\xe9es-membres-statiques",level:3},{value:"Fonctions membres statiques",id:"fonctions-membres-statiques",level:3},{value:"Surcharge des op\xe9rateurs",id:"surcharge-des-op\xe9rateurs",level:2},{value:"Surcharge des op\xe9rateurs internes",id:"surcharge-des-op\xe9rateurs-internes",level:3},{value:"Surcharge des op\xe9rateurs externes",id:"surcharge-des-op\xe9rateurs-externes",level:3}];function o(e){const n={blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"constructeurs-et-destructeurs",children:"Constructeurs et destructeurs"}),"\n",(0,t.jsxs)(n.p,{children:["Le ",(0,t.jsx)(n.em,{children:"constructeur"})," et le ",(0,t.jsx)(n.em,{children:"destructeur"})," sont deux m\xe9thodes particuli\xe8res qui sont\nappel\xe9es respectivement \xe0 la cr\xe9ation et \xe0 la destruction d'un objet. Toute\nclasse a un constructeur et un destructeur par d\xe9faut, fournis par le\ncompilateur. Ces constructeurs et destructeurs appellent les constructeurs par\nd\xe9faut et les destructeurs des classes de base et des donn\xe9es membre de la\nclasse, mais en dehors de cela, ils ne font absolument rien. Il est donc souvent\nn\xe9cessaire de les red\xe9finir afin de g\xe9rer certaines actions qui doivent avoir\nlieu lors de la cr\xe9ation d'un objet et de leur destruction. Par exemple, si\nl'objet doit contenir des objets allou\xe9es dynamiquement, il faut leur r\xe9server\nde la m\xe9moire \xe0 la cr\xe9ation de l'objet ou au moins mettre les pointeurs\ncorrespondants \xe0 NULL. \xc0 la destruction de l'objet, il convient de restituer la\nm\xe9moire allou\xe9e, s'il en a \xe9t\xe9 allou\xe9. On peut trouver bien d'autres situations\no\xf9 une phase d'initialisation et une phase de terminaison son n\xe9cessaires."]}),"\n",(0,t.jsx)(n.p,{children:"D\xe9s qu'un constructeur ou un destructeur a \xe9t\xe9 d\xe9fini par l'utilisateur, le\ncompilateur ne d\xe9finit plus automatiquement le constructeur ou le destructeur\npar d\xe9faut correspondant. En particulier, si l'utilisateur d\xe9finit un\nconstructeur prenant des param\xe8tres, il ne sera plus possible de construire un\nobjet simplement, sans fournir les param\xe8tres \xe0 ce constructeur, \xe0 moins bien\nentendu de d\xe9finir \xe9galement un constructeur qui ne prenne pas de param\xe8tres."}),"\n",(0,t.jsx)(n.h3,{id:"d\xe9finition-des-constructeurs-et-des-destructeurs",children:"D\xe9finition des constructeurs et des destructeurs"}),"\n",(0,t.jsx)(n.p,{children:"Le constructeur se d\xe9finit comme une m\xe9thode normale. Cependant, pour que le\ncompilateur puisse la reconna\xeetre en tant que constructeur, les deux conditions\nsuivantes doivent v\xe9rifi\xe9es :"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"elle doit porter le m\xeame nom que la classe"}),"\n",(0,t.jsx)(n.li,{children:"elle ne doit avoir aucun type, pas m\xeame le type void"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Le destructeur doit \xe9galement respecter ces r\xe8gles. Pour diff\xe9rencier du\nconstructeur, son nom sera toujours pr\xe9c\xe9d\xe9 du signe tilde."}),"\n",(0,t.jsxs)(n.p,{children:["Un constructeur est appel\xe9 automatiquement lors de l'instanciation de l'objet.\nLe destructeur est appel\xe9 automatiquement lors de sa destruction. Cette\ndestruction a lieu lors de la sortie du bloc de port\xe9e courante pour les objets\nde classe de stockage ",(0,t.jsx)(n.code,{children:"auto"}),". Pour les objets allou\xe9s dynamiquement, le\nconstructeur et le destructeur sont appel\xe9s automatiquement par les expressions\nqui utilisent les op\xe9rateurs ",(0,t.jsx)(n.code,{children:"new, new[], delete, delete[]"}),". C'est pour cela\nqu'il est recommand\xe9 de les utiliser \xe0 la place des fonctions ",(0,t.jsx)(n.code,{children:"malloc"})," et ",(0,t.jsx)(n.code,{children:"free"}),"\ndu C pour cr\xe9er dynamiquement des objets. De plus, il ne faut pas utiliser\n",(0,t.jsx)(n.code,{children:"delete"})," ou ",(0,t.jsx)(n.code,{children:"delete[]"})," sur des pointeurs de type void, car il n'existe pas\nd'objets de type void. La compilateur ne peut donc pas d\xe9terminer quel est le\ndestructeur \xe0 appeler avec ce type de pointer."]}),"\n",(0,t.jsx)(n.p,{children:"Le constructeur est appel\xe9 apr\xe8s l'allocation de la m\xe9moire de l'objet et le\ndestructeur est appel\xe9 avant la lib\xe9ration de cette m\xe9moire. La gestion de\nl'allocation dynamique de m\xe9moire avec les classes est ainsi simplifi\xe9e. Dans le\ncas des tables, l'ordre de construction est celui des adresses croissantes, et\nl'ordre de destruction est celui des adresses d\xe9croissantes. C'est dans cet\nordre que les constructeurs et destructeurs de chaque \xe9lement du tableau sont\nappel\xe9s."}),"\n",(0,t.jsx)(n.p,{children:"Les constructeurs pourront avoir des param\xe8tres. Ils peuvent donc \xeatre\nsurcharg\xe9s, mais pas les destructeurs. Cela est d\xfb au fait qu'en g\xe9n\xe9ral on\nconna\xeet le contexte dans lequel un objet est cr\xe9\xe9, mais qu'on ne peut pas\nconna\xeetre le contexte dans lequel il est d\xe9truit : il ne peut donc y avoir qu'un\nseul destructeur. Les constructeurs qui ne prennent pas de param\xe8tre ou dont\ntous les param\xe8tres ont une valeur par d\xe9faut, remplacent automatiquement les\nconstructeurs par d\xe9faut d\xe9finis par le compilateur lorsqu'il n'y a aucun\nconstructeur dans les classes. Cela signifie que ce sont ces constructeurs qui\nseront appel\xe9s automatiquement par les constructeurs par d\xe9faut des classes\nd\xe9riv\xe9es."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class chaine    // Impl\xe9mente une cha\xeene de caract\xe8res.\n{\n    char * s;   // Le pointeur sur la cha\xeene de caract\xe8res.\n\npublic:\n    chaine(void);           // Le constructeur par d\xe9faut.\n    chaine(unsigned int);   // Le constructeur. Il n'a pas de type.\n    ~chaine(void);          // Le destructeur.\n};\n\nchaine::chaine(void)\n{\n    s=NULL;                 // La cha\xeene est initialis\xe9e avec\n    return ;                // le pointeur nul.\n}\n\nchaine::chaine(unsigned int Taille)\n{\n    s = new char[Taille+1]; // Alloue de la m\xe9moire pour la cha\xeene.\n    s[0]='\\0';              // Initialise la cha\xeene \xe0 \"\".\n    return;\n}\n\nchaine::~chaine(void)\n{\n    if (s!=NULL) delete[] s; // Restitue la m\xe9moire utilis\xe9e si\n                             // n\xe9cessaire.\n    return;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Pour passer les param\xe8tres au constructeur, on donne la liste des param\xe8tres\nentre parenth\xe8ses juste apr\xe8s le nom de l'objet lors de son instanciation :"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"chaine s1;        // Instancie une cha\xeene de caract\xe8res\n                  // non initialis\xe9e.\nchaine s2(200);   // Instancie une cha\xeene de caract\xe8res\n                  // de 200 caract\xe8res.\n"})}),"\n",(0,t.jsx)(n.p,{children:"Les constructeurs devront parfois effectuer des t\xe2ches plus compliqu\xe9es que\ncelles donn\xe9es dans cet exemple. En g\xe9n\xe9ral, ils peuvent faire toutes les\nop\xe9rations faisables dans une m\xe9thode normale, sauf utiliser les donn\xe9es non\ninitialis\xe9es bien entendu. En particulier, les donn\xe9es des sous-objets d'un\nobjet ne sont pas initialis\xe9es tant que les constructeurs des classes de base ne\nsont pas appel\xe9s. C'est pour cela qu'il faut toujours appeler les constructeurs\ndes classes de base avant d'ex\xe9cuter le constructeur de la classe en cours\nd'instanciation. Si les constructeurs des classes de base ne sont pas appel\xe9s\nexplicitement, le compilateur appellera, par d\xe9faut, les constructeurs des\nclasses m\xe8res qui ne prennent pas de param\xe8tre ou dont tous les param\xe8tres ont\nune valeur par d\xe9faut."}),"\n",(0,t.jsx)(n.p,{children:"Comment appeler les constructeurs et les destructeurs des classes m\xe8res lors de\nl'instanciation et de la destruction d'une classe d\xe9riv\xe9e ? Le compilateur ne\npeut en effet pas savoir quel constructeur il faut appeler parmi les diff\xe9rents\nconstructeurs surcharg\xe9s potentiellement pr\xe9sents ... Pour appeler un autre\nconstructeur d'une classe de base que le constructeur ne prenant pas de\nparam\xe8tre, il faut sp\xe9cifier explicitement ce constructeur avec ses param\xe8tres\napr\xe8s le nom du constructeur de la classe fille, en les s\xe9parant de deux points."}),"\n",(0,t.jsx)(n.p,{children:"En revanche, il est inutile de pr\xe9ciser le destructeur \xe0 appeler, puisque\ncelui-ci est unique. Le programmeur ne doit donc pas appeler lui-m\xeame les\ndestructeurs des classes m\xe8res, le langage s'en charge."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'/* D\xe9claration de la classe m\xe8re. */\n\nclass Mere\n{\n    int m_i;\npublic:\n    Mere(int);\n    ~Mere(void);\n};\n\n/* D\xe9finition du constructeur de la classe m\xe8re. */\n\nMere::Mere(int i)\n{\n    m_i=i;\n    printf("Ex\xe9cution du constructeur de la classe m\xe8re.\\n");\n    return;\n}\n\n/* D\xe9finition du destructeur de la classe m\xe8re. */\n\nMere::~Mere(void)\n{\n    printf("Ex\xe9cution du destructeur de la classe m\xe8re.\\n");\n    return;\n}\n\n/* D\xe9claration de la classe fille. */\n\nclass Fille : public Mere\n{\npublic:\n    Fille(void);\n    ~Fille(void);\n};\n\n/* D\xe9finition du constructeur de la classe fille\n   avec appel du constructeur de la classe m\xe8re. */\n\nFille::Fille(void) : Mere(2)\n{\n    printf("Ex\xe9cution du constructeur de la classe fille.\\n");\n    return;\n}\n\n/* D\xe9finition du destructeur de la classe fille\n   avec appel automatique du destructeur de la classe m\xe8re. */\n\nFille::~Fille(void)\n{\n    printf("Ex\xe9cution du destructeur de la classe fille.\\n");\n    return;\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Lors de l'instanciation d'un objet de la classe fille, le programme affichera\ndans l'ordre les messages suivants :"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Ex\xe9cution du constructeur de la classe m\xe8re"}),"\n",(0,t.jsx)(n.li,{children:"Ex\xe9cution du constructeur de la classe fille"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"et lors de la destruction de l'objet"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Ex\xe9cution du destructeur de la classe fille"}),"\n",(0,t.jsx)(n.li,{children:"Ex\xe9cution du destructeur de la classe m\xe8re"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Si l'on n'avait pas pr\xe9cis\xe9 que le constructeur \xe0 appeler pour la classe M\xe8re\n\xe9tait le constructeur prenant un entier en param\xe8tre, le compilateur aurait\nessay\xe9 d'appeler le constructeur par d\xe9faut de cette classe. Or, ce constructeur\nn'\xe9tant plus g\xe9n\xe9r\xe9 automatiquement par le compilateur (\xe0 cause de la d\xe9finition\nd'un constructeur prenant un param\xe8tre), il y aurait eu une erreur de\ncompilation."}),"\n",(0,t.jsx)(n.p,{children:"Il est possible d'appeler plusieurs constructeurs si la class\xe9 d\xe9rive de\nplusieurs classes de base. Pour cela, il suffit de lister les constructeurs un \xe0\nun, en s\xe9parant leurs appels par des virgules. On notera cependant que l'ordre\ndans lequel les constructeurs sont appel\xe9s n'est pas forc\xe9ment l'ordre dans\nlequel ils sont list\xe9s dans la d\xe9finition du constructeur de la classe fille. En\neffet, le C++ appelle toujours les constructeurs dans l'ordre d'apparition de\nleurs classes dans la liste des classes de base de la classe d\xe9riv\xe9e."}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Une fonction virtuelle peut donc toujours \xeatre appel\xe9e dans un constructeur,\nmais la fonction effectivement appel\xe9e est celle de la classe du sous-objet en\ncours de construction : pas celle de la classe de l'objet complet. Ainsi, si\nune classe A h\xe9rite d'une classe B et qu'elles ont toutes les deux une\nfonction virtuelle f, l'appel de f dans le constructeur de B utilisera la\nfonction f de B, pas celle de A (m\xeame si l'objet que l'on instancie est de\nclasse A)."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"La syntaxe utilis\xe9e pour appeler les constructeurs des classes de base peut\n\xe9galement \xeatre utilis\xe9e pour initialiser les donn\xe9es membres de la classe. En\nparticulier, cette syntaxe est obligatoire pour les donn\xe9es membres constantes\net pour les r\xe9f\xe9rences, car le C++ ne permet pas l'affectation d'une valeur \xe0\ndes variables de ce type. Encore une fois, l'ordre d'appel des constructeurs des\ndonn\xe9es membres ainsi initialis\xe9es n'est pas forc\xe9ment l'ordre dans lequel ils\nsont list\xe9s dans le constructeur de classe. En effet, le C++ utilise cette fois\nl'ordre de d\xe9claration de chaque donn\xe9e membre."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class tableau\n{\n    const int m_iTailleMax;\n    const int *m_pDonnees;\npublic:\n    tableau(int iTailleMax);\n    ~tableau();\n};\n\ntableau::tableau(int iTailleMax) :\n    m_iTailleMax(iTailleMax)    // Initialise la donn\xe9e membre constante.\n{\n    // Allocation d'un tableau de m_iTailleMax entr\xe9es :\n    m_pDonnees = new int[m_iTailleMax];\n}\n\ntableau::~tableau()\n{\n    // Destruction des donn\xe9es :\n    delete[] m_pDonnees;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"constructeurs-de-copie",children:"Constructeurs de copie"}),"\n",(0,t.jsx)(n.p,{children:"Il faudra parfois cr\xe9er un constructeur de copie. Le but de ce type de\nconstructeur est d'initialiser un objet lors de son instanciation \xe0 partir d'un\nautre objet. Toute classe dispose d'un constructeur de copie par d\xe9faut g\xe9n\xe9r\xe9\nautomatiquement par le compilateur, dont le seul but est de recopier les champs\nde l'objet \xe0 recopier un \xe0 un dans les champs de l'objet \xe0 instancier.\nToutefois, ce constructeur par d\xe9faut ne suffira pas toujours, et le programmeur\ndevra parfois en fournir un explicitement."}),"\n",(0,t.jsx)(n.p,{children:"Ce sera notamment le cas lorsque certaines donn\xe9es des objets auront \xe9t\xe9\nallou\xe9es dynamiquement. Une copie brutale des champs d'un objet dans un autre ne\nferait que recopier les pointeurs, pas les donn\xe9es point\xe9es. Ainsi, la\nmodification de ces donn\xe9es pour un objet entra\xeenerait la modification des\ndonn\xe9es de l'autre objet, ce qui ne serait sans doute pas l'effet d\xe9sir\xe9."}),"\n",(0,t.jsx)(n.p,{children:"La d\xe9finition des constructeurs de copie se fait comme celle des constructeurs\nnormaux. Le nom doit \xeatre celui de la classe, et il ne doit y avoir aucun type.\nDans la liste des param\xe8tres cependant, il devra toujours y avoir une r\xe9f\xe9rence\nsur l'objet \xe0 copier."}),"\n",(0,t.jsx)(n.p,{children:"Pour la classe chaine d\xe9finie ci-dessus, il faut un constructeur de copie.\nCelui-ci peut \xeatre d\xe9clar\xe9 de la fa\xe7on suivante"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"chaine(const chaine &Source);\n"})}),"\n",(0,t.jsx)(n.p,{children:"o\xf9 Source est l'objet \xe0 copier. Si l'on rajoute la donn\xe9e membre Taille dans la\nd\xe9claration de la classe, la d\xe9finition de ce constructeur peut \xeatre :"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"chaine::chaine(const chaine &Source)\n{\n    int i = 0;                   // Compteur de caract\xe8res.\n    Taille = Source.Taille;\n    s = new char[Taille + 1];    // Effectue l'allocation.\n    strcpy(s, Source.s);         // Recopie la cha\xeene de caract\xe8res source.\n    return;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Le constructeur de copie est appel\xe9 dans toute instanciation avec\ninitialisation, comme celles qui suivent"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"chaine s2(s1);\nchainse s2 = s1;\n"})}),"\n",(0,t.jsx)(n.p,{children:"Dans les deux exemples, c'est le constructeur de copie qui est appel\xe9. En\nparticulier, \xe0 la deuxi\xe8me ligne, le constructeur normal n'est pas appel\xe9 et\naucune affectation entre objets n'a lieu."}),"\n",(0,t.jsx)(n.h3,{id:"utilisation-des-constructeurs-dans-les-transtypages",children:"Utilisation des constructeurs dans les transtypages"}),"\n",(0,t.jsx)(n.p,{children:"Les constructeurs sont utilis\xe9s dans les conversions de type dans lesquelles le\ntype cible est celui de la classe du constructeur. Ces conversions peuvent \xeatre\nsoit implicites (dans une expression), soit explicite (\xe0 l'aide d'un\ntranstypage). Par d\xe9faut, les conversions implicites sont l\xe9gales, pourvu qu'il\nexiste un constructeur dont le premier param\xe8tre a le m\xeame type que l'objet\nsource. Par exemple, la classe Entier suivante :"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class Entier\n{\n    int i;\npublic:\n    Entier(int j)\n    {\n        i=j;\n        return ;\n    }\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:"dispose d'un constructeur de transtypage pour les entiers. Les expressions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"int j=2;\nEntier e1, e2=j;\ne1=j;\n"})}),"\n",(0,t.jsx)(n.p,{children:"sont donc l\xe9gales, la valeur enti\xe8re situ\xe9e \xe0 la droite de l'expression \xe9tant\nconvertie implicitement en un objet du type de la classe Entier."}),"\n",(0,t.jsxs)(n.p,{children:["Si, pour une raison quelconque, ce comportement n'est pas souhaitable, on peut\nforcer le compilateur \xe0 n'accepter que les conversions explicites (\xe0 l'aide de\ntranstypage). Pour cela, il suffit de placer le mot cl\xe9 ",(0,t.jsx)(n.code,{children:"explicit"})," avant la\nd\xe9claration du constructeur. Par exemple, le constructeur de la classe chaine\nvue ci-dessus prenant un entier en param\xe8tre risque d'\xeatre utilis\xe9 dans des\nconversions implicites. Or ce constructeur ne permet pas de construire une\ncha\xeene de caract\xe8res \xe0 partir d'un entier, et ne doit pas \xeatre utilis\xe9 dans les\nop\xe9rations de transtypage. Ce constructeur doit donc \xeatre d\xe9clar\xe9 ",(0,t.jsx)(n.code,{children:"explicit"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class chaine\n{\n    size_t Taille;\n    char * s;\n\npublic:\n    chaine(void);\n    // Ce constructeur permet de pr\xe9ciser la taille de la cha\xeene\n // \xe0 sa cr\xe9ation :\n    explicit chaine(unsigned int);\n    ~chaine(void);\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:"Avec cette d\xe9claration, l'expression suivante"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"int j=2;\nchainse s=j;\n"})}),"\n",(0,t.jsx)(n.p,{children:"n'est plus valide, alors qu'elle l'\xe9tait lorsque le constructeur n'\xe9tait pas\nexplicit."}),"\n",(0,t.jsxs)(n.h2,{id:"pointeur-this",children:["Pointeur ",(0,t.jsx)(n.code,{children:"this"})]}),"\n",(0,t.jsx)(n.p,{children:"Nous allons \xe0 pr\xe9sent voir comment les fonctions membres, qui appartiennent \xe0 la\nclasse, peuvent acc\xe9der aux donn\xe9es d'un objet, qui est une instance de cette\nclasse. Cela est indispensable pour bien comprendre les paragraphes suivants."}),"\n",(0,t.jsx)(n.p,{children:"\xc0 chaque appel d'une fonction membre, le compilateur passe implicitement un\npointeur sur les donn\xe9es de l'objet en param\xe8tre. Ce param\xe8tre est le premier\nparam\xe8tre de la fonction. Ce m\xe9canisme est compl\xe8tement invisible au programmeur,\net nous ne nous attarderons pas dessus."}),"\n",(0,t.jsxs)(n.p,{children:["En revanche, in faut savoir que le pointeur sur l'objet est accessible \xe0\nl'int\xe9rieur de la fonction membre. Il porte le nom ",(0,t.jsx)(n.code,{children:"this"}),". Par cons\xe9quent,\n",(0,t.jsx)(n.code,{children:"*this"})," repr\xe9sente l'objet lui-m\xeame. Nous verrons une utilisation de ",(0,t.jsx)(n.code,{children:"this"})," dans\nle paragraphe suivant"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"this"})," est un pointeur constant, c'est \xe0 dire qu'on ne peut pas le modifier (il\nest donc impossible de faire des op\xe9rations arithm\xe9tiques dessus). Cela est tout\n\xe0 fait normal, puisque le faire reviendrait \xe0 sortir de l'objet en cours (celui\npour lequel la m\xe9thode en cours d'ex\xe9cution travaille)."]}),"\n",(0,t.jsxs)(n.p,{children:["Il est possible de transformer ce pointeur constant en un pointeur constant sur\ndes donn\xe9es constantes pour chaque fonction membre. Le pointeur ne peut toujours\npas \xeatre modifi\xe9, et les donn\xe9es de l'objet ne peuvent pas \xeatre modifi\xe9es non\nplus. L'objet est donc consid\xe9r\xe9 par la fonction membre concern\xe9e comme un objet\nconstant. Cela revient \xe0 dire que la fonction membre s'interdit la modification\ndes donn\xe9es de l'objet. On parvient \xe0 ce r\xe9sultat en ajoutant le mot cl\xe9 ",(0,t.jsx)(n.code,{children:"const"}),"\n\xe0 la suite de l'en te de la fonction membre."]}),"\n",(0,t.jsxs)(n.p,{children:["Il est \xe0 noter qu'une m\xe9thode qui n'est pas d\xe9clar\xe9e comme \xe9tant ",(0,t.jsx)(n.code,{children:"const"})," modifie\na priori les donn\xe9es de l'objet sur lequel elle travaille. Donc, si elle est\nappel\xe9e sur un objet d\xe9clar\xe9 ",(0,t.jsx)(n.code,{children:"const"}),", une erreur de compilation se produit. Ce\ncomportement est normal. On devra donc toujours d\xe9clarer ",(0,t.jsx)(n.code,{children:"const"})," une m\xe9thode qui\nne modifie pas r\xe9ellement l'objet, afin de laisse \xe0 l'utilisateur le choix de\nd\xe9clarer ",(0,t.jsx)(n.code,{children:"const"})," ou non les objets de sa classe."]}),"\n",(0,t.jsx)(n.h2,{id:"donn\xe9es-et-fonctions-membres-statiques",children:"Donn\xe9es et fonctions membres statiques"}),"\n",(0,t.jsxs)(n.p,{children:["Nous allons voir dans ce paragraphe l'emploi du mot cl\xe9 ",(0,t.jsx)(n.code,{children:"static"})," dans les\nclasses. Ce mot cl\xe9 intervient pour caract\xe9riser les donn\xe9es membres statiques\ndes classes, les fonctions membres statiques des classes, et les donn\xe9es\nstatiques des fonctions membres."]}),"\n",(0,t.jsx)(n.h3,{id:"donn\xe9es-membres-statiques",children:"Donn\xe9es membres statiques"}),"\n",(0,t.jsx)(n.p,{children:"Une classe peut contenir des donn\xe9es membres statiques. Ces donn\xe9es sont soit\ndes donn\xe9es membres propres \xe0 la classe, soit des donn\xe9es locales statiques des\nfonctions membres de la classe. Dans tous les cas, elles appartiennent \xe0 la\nclasse, et non pas aux objets de cette classe. Elles sont donc communes \xe0 tous\nces objets."}),"\n",(0,t.jsx)(n.p,{children:"Il est impossible d'initialiser les donn\xe9es d'une classe dans le constructeur de\nla classe, car le constructeur n'initialise que les donn\xe9es des nouveaux objets.\nLes donn\xe9es statiques ne sont pas sp\xe9cifiques \xe0 un objet particulier et ne\npeuvent donc pas \xeatre initialis\xe9es dans le constructeur. En fait, leur\ninitialisation doit se faire lors de leur d\xe9finition, en dehors de la\nd\xe9claration de la classe. Pour pr\xe9ciser la classe \xe0 laquelle les donn\xe9es sont\nd\xe9finies appartiennent, on devra utiliser l'op\xe9rateur de r\xe9solution de port\xe9e."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class test\n{\n    static int i;       // D\xe9claration dans la classe.\n    ...\n};\n\nint test::i=3;         // Initialisation en dehors de la classe.\n"})}),"\n",(0,t.jsxs)(n.p,{children:["La variable ",(0,t.jsx)(n.code,{children:"test::i"})," sera partag\xe9e par tous les objets de classe test, et sa\nvaleur initiale est 3."]}),"\n",(0,t.jsx)(n.p,{children:"Les variables statiques des fonctions membres doivent \xeatre initialis\xe9es \xe0\nl'int\xe9rieur des fonctions membres. Elles appartiennent \xe9galement \xe0 la classe, et\nnon pas aux objets. De plus, leur port\xe9e est r\xe9duite \xe0 celle du bloc dans lequel\nelles ont \xe9t\xe9 d\xe9clar\xe9es. Ainsi le code suivante :"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include <stdio.h>\n\nclass test\n{\npublic:\n    int n(void);\n};\n\nint test::n(void)\n{\n    static int compte=0;\n    return compte++;\n}\n\nint main(void)\n{\n    test objet1, objet2;\n    printf("%d ", objet1.n());   // Affiche 0\n    printf("%d\\n", objet2.n());  // Affiche 1\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"affichera 0 et 1, parque la variable statique compte est la m\xeame pour les deux\nobjets"}),"\n",(0,t.jsx)(n.h3,{id:"fonctions-membres-statiques",children:"Fonctions membres statiques"}),"\n",(0,t.jsxs)(n.p,{children:["Les classes peuvent \xe9galement contenir des fonctions membres statiques. Cela\npeut surprendre \xe0 premi\xe8re vue, puisque les fonctions membres appartiennent d\xe9j\xe0\n\xe0 la classe, c'est \xe0 dire \xe0 tous les objets. En fait, cela signifie que ces\nfonctions membres ne recevront pas le pointeur sur l'objet ",(0,t.jsx)(n.code,{children:"this"}),", comme c'est\nle cas pour les autres fonctions membres. Par cons\xe9quent, elles ne pourront\nacc\xe9der qu'aux donn\xe9es statiques de l'objet"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class Entier\n{\n    int i;\n    static int j;\npublic:\n    static int get_value(void);\n};\n\nint Entier::j=0;\n\nint Entier::get_value(void)\n{\n    j=1;         // L\xe9gal.\n    return i;    // ERREUR ! get_value ne peut pas acc\xe9der \xe0 i.\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["La fonction ",(0,t.jsx)(n.code,{children:"get_value"})," de l'exemple ci-dessus ne peut pas acc\xe9der \xe0 la donn\xe9e\nmembre non statique ",(0,t.jsx)(n.code,{children:"i"}),", parce qu'elle ne travaille sur aucun objet. Son champ\nd'action est uniquement la classe Entier. En revanche, elle peut modifier la\nvariable statique ",(0,t.jsx)(n.code,{children:"j"}),", puisque celle-ci appartient \xe0 la classe Entier et non aux\nobjets de cette classe."]}),"\n",(0,t.jsx)(n.p,{children:"L'appel des fonctions membre statiques se fait exactement comme celui des\nfonctions membres non statiques, en sp\xe9cifiant l'identificateur d'un des objets\nde la classe et le nom de la fonction membre, s\xe9par\xe9s par un point. Cependant,\ncomme les fonctions membres ne travaillent pas sur les objets des classes mais\nplut\xf4t sur les classes elles-m\xeames, la pr\xe9sence de l'objet lors de l'appel est\nfacultatif. On peut donc se contenter d'appeler une fonction statique en\nqualifiant son nom du nom de la classe \xe0 laquelle elle appartient \xe0 l'aide de\nl'op\xe9rateur de r\xe9solution de port\xe9e."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class Entier\n{\n    static int i;\npublic:\n    static int get_value(void);\n};\n\nint Entier::i=3;\n\nint Entier::get_value(void)\n{\n    return i;\n}\n\nint main(void)\n{\n    // Appelle la fonction statique get_value :\n    int resultat=Entier::get_value();\n    return 0;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Les fonctions membres statiques sont souvent utilis\xe9es afin de regrouper un\ncertain nombre de fonctionnalit\xe9s en rapport avec leur classe. Ainsi, elles sont\nfacilement localisable et les risques de conflits de noms entre deux fonctions\nmembres homonymes sont r\xe9duits. Nous verrons \xe9galement plus tard comment \xe9viter\nles conflits de noms globaux dans le cadre des espaces de nommage."}),"\n",(0,t.jsx)(n.h2,{id:"surcharge-des-op\xe9rateurs",children:"Surcharge des op\xe9rateurs"}),"\n",(0,t.jsx)(n.p,{children:"On a vu pr\xe9c\xe9demment que les op\xe9rateurs ne se diff\xe9rencient des fonctions que\nsyntaxiquement, pas logiquement. D'ailleurs, le compilateur traite un appel \xe0 un\nop\xe9rateur comme un appel \xe0 une fonction. Le C++ permet donc de surcharger les\nop\xe9rateurs pour les classes d\xe9finies par l'utilisateur, en utilisant une\nsyntaxe particuli\xe8re calqu\xe9e sur la syntaxe utilis\xe9e pour d\xe9finir des fonctions\nmembres normales. En fait, il est m\xeame possible de surcharger les op\xe9rateurs du\nlangage pour les classes de l'utilisateur en dehors de la d\xe9finition de ces\nclasses. Le C++ dispose donc de deux m\xe9thodes diff\xe9rentes pour surcharger les\nop\xe9rateurs."}),"\n",(0,t.jsx)(n.p,{children:"Nous allons \xe0 pr\xe9sent voir dans les sections suivantes les deux syntaxes\npermettant de surcharger les op\xe9rateurs pour les types de l'utilisateur, ainsi\nque les r\xe8gles sp\xe9cifiques \xe0 certains op\xe9rateurs particuliers."}),"\n",(0,t.jsx)(n.h3,{id:"surcharge-des-op\xe9rateurs-internes",children:"Surcharge des op\xe9rateurs internes"}),"\n",(0,t.jsxs)(n.p,{children:["Une premi\xe8re m\xe9thode pour surcharger les op\xe9rateurs consiste \xe0 les consid\xe9rer\ncomme des m\xe9thodes normales de la classe sur laquelle ils s'appliquent. Le nom\nde ces m\xe9thodes est donn\xe9 par le mot cl\xe9 ",(0,t.jsx)(n.code,{children:"operator"}),", suivi de l'op\xe9rateur \xe0\nsurcharger. Le type de la fonction de l'op\xe9rateur est le type du r\xe9sultat donn\xe9\npar l'op\xe9ration, et les param\xe8tres, donn\xe9s entre parenth\xe8ses, sont les\nop\xe9randes. Les op\xe9rateurs de ce type sont appel\xe9s op\xe9rateurs internes, parce\nqu'ils sont d\xe9clar\xe9s \xe0 l'int\xe9rieur de la classe."]}),"\n",(0,t.jsx)(n.p,{children:"Avec cette syntaxe, le premier op\xe9rande est toujours l'objet auquel cette\nfonction s'applique. Cette mani\xe8re de surcharger les op\xe9rateurs est donc\nparticuli\xe8rement bien adapt\xe9e pour les op\xe9rateurs qui modifient l'objet sur\nlequel ils travaillent, comme par exemple ,es op\xe9rateurs =, +=, ++, etc. Les\nparam\xe8tres de la fonction op\xe9rateur sont alors le deuxi\xe8me op\xe9rande et les\nsuivants."}),"\n",(0,t.jsxs)(n.p,{children:["Les op\xe9rateurs d\xe9finis en interne devront souvent renvoyer l'objet sur lequel\nils travaillent (ce n'est pas une n\xe9cessit\xe9 cependant). Cela est faisable gr\xe2ce\nau pointeur ",(0,t.jsx)(n.code,{children:"this"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"surcharge-des-op\xe9rateurs-externes",children:"Surcharge des op\xe9rateurs externes"}),"\n",(0,t.jsx)(n.p,{children:"Une deuxi\xe8me possibilit\xe9 nous est offerte par le langage pour surcharger les\nop\xe9rateurs. La d\xe9finition de l'op\xe9rateur ne se fait plus dans la classe qui\nl'utilise, mais en dehors de celle-ci, par surcharge d'un op\xe9rateur de l'espace\nde nommage global. Il s'agit donc d'op\xe9rateurs externes cette fois."}),"\n",(0,t.jsxs)(n.p,{children:["La surcharge des op\xe9rateurs externes se fait donc exactement comme on surcharge\nles fonctions normales. Dans ce cas, tous les op\xe9randes de l'op\xe9rateur devront\n\xeatre pass\xe9s en param\xe8tres : il n'y aura pas de param\xe8tre implicite (le pointeur\n",(0,t.jsx)(n.code,{children:"this"})," n'est pas pass\xe9 en param\xe8tre)."]}),"\n",(0,t.jsx)(n.p,{children:"L'avantage de cette syntaxe est que l'op\xe9rateur est r\xe9ellement sym\xe9trique,\ncontrairement \xe0 ce qui se passe pour ces op\xe9rateurs d\xe9finis \xe0 l'int\xe9rieur de la\nclasse. Ainsi, si l'utilisation de cet op\xe9rateur n\xe9cessite un transtypage sur\nl'un des op\xe9randes, il n'est pas n\xe9cessaire que cet op\xe9rande soit\nobligatoirement le deuxi\xe8me. Donc si la classe dispose de constructeurs\npermettant de convertir un type de donn\xe9e en son propre type, ce type de donn\xe9e\npeut \xeatre utilis\xe9 avec tous les op\xe9rateurs de la classe."}),"\n",(0,t.jsx)(n.p,{children:"On constatera que les op\xe9rateurs externes doivent \xeatre d\xe9clar\xe9s comme \xe9tant des\nfonctions amies de la classe sur laquelle ils travaillent, faut de quoi ils ne\npourraient pas manipuler les donn\xe9es membres de leurs op\xe9randes."}),"\n",(0,t.jsx)(n.p,{children:"La syntaxe des op\xe9rateurs externes permet \xe9galement d'impl\xe9menter les op\xe9rateurs\npour lesquels le type de la valeur de retour est celui de l'op\xe9rande de gauche\net que le type de cet op\xe9rande n'est pas une classe d\xe9finie par l'utilisateur\n(par exemple si c'est un type pr\xe9d\xe9fini). En effet, on ne peut pas d\xe9finir\nl'op\xe9rateur \xe0 l'int\xe9rieur de la classe du premier op\xe9rande dans ce cas, puisque\ncette classe est d\xe9j\xe0 d\xe9finie. De m\xeame, cette syntaxe peut \xeatre utile dans le\ncas de l'\xe9criture d'op\xe9rateurs optimis\xe9s pour certains types de donn\xe9es, pour\nlesquels les op\xe9rations r\xe9alis\xe9es par l'op\xe9rateur sont plus simples que celles\nqui auraient \xe9t\xe9 effectu\xe9es apr\xe8s transtypage."})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>l});var t=s(96540);const r={},a=t.createContext(r);function i(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);